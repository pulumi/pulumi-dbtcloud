// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dbtcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Teradata credential resource
type TeradataCredential struct {
	pulumi.CustomResourceState

	// The internal credential ID
	CredentialId pulumi.IntOutput `pulumi:"credentialId"`
	// The password for the Teradata account
	Password pulumi.StringOutput `pulumi:"password"`
	// Project ID to create the Teradata/Trino credential in
	ProjectId pulumi.IntOutput `pulumi:"projectId"`
	// The schema where to create models
	Schema pulumi.StringOutput `pulumi:"schema"`
	// The number of threads to use. Default is 1
	Threads pulumi.IntOutput `pulumi:"threads"`
	// The username for the Teradata account
	User pulumi.StringOutput `pulumi:"user"`
}

// NewTeradataCredential registers a new resource with the given unique name, arguments, and options.
func NewTeradataCredential(ctx *pulumi.Context,
	name string, args *TeradataCredentialArgs, opts ...pulumi.ResourceOption) (*TeradataCredential, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Password == nil {
		return nil, errors.New("invalid value for required argument 'Password'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.Schema == nil {
		return nil, errors.New("invalid value for required argument 'Schema'")
	}
	if args.User == nil {
		return nil, errors.New("invalid value for required argument 'User'")
	}
	if args.Password != nil {
		args.Password = pulumi.ToSecret(args.Password).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"password",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TeradataCredential
	err := ctx.RegisterResource("dbtcloud:index/teradataCredential:TeradataCredential", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeradataCredential gets an existing TeradataCredential resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeradataCredential(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeradataCredentialState, opts ...pulumi.ResourceOption) (*TeradataCredential, error) {
	var resource TeradataCredential
	err := ctx.ReadResource("dbtcloud:index/teradataCredential:TeradataCredential", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TeradataCredential resources.
type teradataCredentialState struct {
	// The internal credential ID
	CredentialId *int `pulumi:"credentialId"`
	// The password for the Teradata account
	Password *string `pulumi:"password"`
	// Project ID to create the Teradata/Trino credential in
	ProjectId *int `pulumi:"projectId"`
	// The schema where to create models
	Schema *string `pulumi:"schema"`
	// The number of threads to use. Default is 1
	Threads *int `pulumi:"threads"`
	// The username for the Teradata account
	User *string `pulumi:"user"`
}

type TeradataCredentialState struct {
	// The internal credential ID
	CredentialId pulumi.IntPtrInput
	// The password for the Teradata account
	Password pulumi.StringPtrInput
	// Project ID to create the Teradata/Trino credential in
	ProjectId pulumi.IntPtrInput
	// The schema where to create models
	Schema pulumi.StringPtrInput
	// The number of threads to use. Default is 1
	Threads pulumi.IntPtrInput
	// The username for the Teradata account
	User pulumi.StringPtrInput
}

func (TeradataCredentialState) ElementType() reflect.Type {
	return reflect.TypeOf((*teradataCredentialState)(nil)).Elem()
}

type teradataCredentialArgs struct {
	// The password for the Teradata account
	Password string `pulumi:"password"`
	// Project ID to create the Teradata/Trino credential in
	ProjectId int `pulumi:"projectId"`
	// The schema where to create models
	Schema string `pulumi:"schema"`
	// The number of threads to use. Default is 1
	Threads *int `pulumi:"threads"`
	// The username for the Teradata account
	User string `pulumi:"user"`
}

// The set of arguments for constructing a TeradataCredential resource.
type TeradataCredentialArgs struct {
	// The password for the Teradata account
	Password pulumi.StringInput
	// Project ID to create the Teradata/Trino credential in
	ProjectId pulumi.IntInput
	// The schema where to create models
	Schema pulumi.StringInput
	// The number of threads to use. Default is 1
	Threads pulumi.IntPtrInput
	// The username for the Teradata account
	User pulumi.StringInput
}

func (TeradataCredentialArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teradataCredentialArgs)(nil)).Elem()
}

type TeradataCredentialInput interface {
	pulumi.Input

	ToTeradataCredentialOutput() TeradataCredentialOutput
	ToTeradataCredentialOutputWithContext(ctx context.Context) TeradataCredentialOutput
}

func (*TeradataCredential) ElementType() reflect.Type {
	return reflect.TypeOf((**TeradataCredential)(nil)).Elem()
}

func (i *TeradataCredential) ToTeradataCredentialOutput() TeradataCredentialOutput {
	return i.ToTeradataCredentialOutputWithContext(context.Background())
}

func (i *TeradataCredential) ToTeradataCredentialOutputWithContext(ctx context.Context) TeradataCredentialOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeradataCredentialOutput)
}

// TeradataCredentialArrayInput is an input type that accepts TeradataCredentialArray and TeradataCredentialArrayOutput values.
// You can construct a concrete instance of `TeradataCredentialArrayInput` via:
//
//	TeradataCredentialArray{ TeradataCredentialArgs{...} }
type TeradataCredentialArrayInput interface {
	pulumi.Input

	ToTeradataCredentialArrayOutput() TeradataCredentialArrayOutput
	ToTeradataCredentialArrayOutputWithContext(context.Context) TeradataCredentialArrayOutput
}

type TeradataCredentialArray []TeradataCredentialInput

func (TeradataCredentialArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeradataCredential)(nil)).Elem()
}

func (i TeradataCredentialArray) ToTeradataCredentialArrayOutput() TeradataCredentialArrayOutput {
	return i.ToTeradataCredentialArrayOutputWithContext(context.Background())
}

func (i TeradataCredentialArray) ToTeradataCredentialArrayOutputWithContext(ctx context.Context) TeradataCredentialArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeradataCredentialArrayOutput)
}

// TeradataCredentialMapInput is an input type that accepts TeradataCredentialMap and TeradataCredentialMapOutput values.
// You can construct a concrete instance of `TeradataCredentialMapInput` via:
//
//	TeradataCredentialMap{ "key": TeradataCredentialArgs{...} }
type TeradataCredentialMapInput interface {
	pulumi.Input

	ToTeradataCredentialMapOutput() TeradataCredentialMapOutput
	ToTeradataCredentialMapOutputWithContext(context.Context) TeradataCredentialMapOutput
}

type TeradataCredentialMap map[string]TeradataCredentialInput

func (TeradataCredentialMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeradataCredential)(nil)).Elem()
}

func (i TeradataCredentialMap) ToTeradataCredentialMapOutput() TeradataCredentialMapOutput {
	return i.ToTeradataCredentialMapOutputWithContext(context.Background())
}

func (i TeradataCredentialMap) ToTeradataCredentialMapOutputWithContext(ctx context.Context) TeradataCredentialMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeradataCredentialMapOutput)
}

type TeradataCredentialOutput struct{ *pulumi.OutputState }

func (TeradataCredentialOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TeradataCredential)(nil)).Elem()
}

func (o TeradataCredentialOutput) ToTeradataCredentialOutput() TeradataCredentialOutput {
	return o
}

func (o TeradataCredentialOutput) ToTeradataCredentialOutputWithContext(ctx context.Context) TeradataCredentialOutput {
	return o
}

// The internal credential ID
func (o TeradataCredentialOutput) CredentialId() pulumi.IntOutput {
	return o.ApplyT(func(v *TeradataCredential) pulumi.IntOutput { return v.CredentialId }).(pulumi.IntOutput)
}

// The password for the Teradata account
func (o TeradataCredentialOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v *TeradataCredential) pulumi.StringOutput { return v.Password }).(pulumi.StringOutput)
}

// Project ID to create the Teradata/Trino credential in
func (o TeradataCredentialOutput) ProjectId() pulumi.IntOutput {
	return o.ApplyT(func(v *TeradataCredential) pulumi.IntOutput { return v.ProjectId }).(pulumi.IntOutput)
}

// The schema where to create models
func (o TeradataCredentialOutput) Schema() pulumi.StringOutput {
	return o.ApplyT(func(v *TeradataCredential) pulumi.StringOutput { return v.Schema }).(pulumi.StringOutput)
}

// The number of threads to use. Default is 1
func (o TeradataCredentialOutput) Threads() pulumi.IntOutput {
	return o.ApplyT(func(v *TeradataCredential) pulumi.IntOutput { return v.Threads }).(pulumi.IntOutput)
}

// The username for the Teradata account
func (o TeradataCredentialOutput) User() pulumi.StringOutput {
	return o.ApplyT(func(v *TeradataCredential) pulumi.StringOutput { return v.User }).(pulumi.StringOutput)
}

type TeradataCredentialArrayOutput struct{ *pulumi.OutputState }

func (TeradataCredentialArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeradataCredential)(nil)).Elem()
}

func (o TeradataCredentialArrayOutput) ToTeradataCredentialArrayOutput() TeradataCredentialArrayOutput {
	return o
}

func (o TeradataCredentialArrayOutput) ToTeradataCredentialArrayOutputWithContext(ctx context.Context) TeradataCredentialArrayOutput {
	return o
}

func (o TeradataCredentialArrayOutput) Index(i pulumi.IntInput) TeradataCredentialOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TeradataCredential {
		return vs[0].([]*TeradataCredential)[vs[1].(int)]
	}).(TeradataCredentialOutput)
}

type TeradataCredentialMapOutput struct{ *pulumi.OutputState }

func (TeradataCredentialMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeradataCredential)(nil)).Elem()
}

func (o TeradataCredentialMapOutput) ToTeradataCredentialMapOutput() TeradataCredentialMapOutput {
	return o
}

func (o TeradataCredentialMapOutput) ToTeradataCredentialMapOutputWithContext(ctx context.Context) TeradataCredentialMapOutput {
	return o
}

func (o TeradataCredentialMapOutput) MapIndex(k pulumi.StringInput) TeradataCredentialOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TeradataCredential {
		return vs[0].(map[string]*TeradataCredential)[vs[1].(string)]
	}).(TeradataCredentialOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeradataCredentialInput)(nil)).Elem(), &TeradataCredential{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeradataCredentialArrayInput)(nil)).Elem(), TeradataCredentialArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeradataCredentialMapInput)(nil)).Elem(), TeradataCredentialMap{})
	pulumi.RegisterOutputType(TeradataCredentialOutput{})
	pulumi.RegisterOutputType(TeradataCredentialArrayOutput{})
	pulumi.RegisterOutputType(TeradataCredentialMapOutput{})
}
