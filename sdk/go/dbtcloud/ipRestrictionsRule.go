// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dbtcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages IP restriction rules in dbt Cloud. IP restriction rules allow you to control access to your dbt Cloud instance based on IP address ranges.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := dbtcloud.NewIpRestrictionsRule(ctx, "test", &dbtcloud.IpRestrictionsRuleArgs{
//				Name:        pulumi.String("My restriction rule"),
//				Description: pulumi.String("Important description"),
//				Cidrs: dbtcloud.IpRestrictionsRuleCidrArray{
//					&dbtcloud.IpRestrictionsRuleCidrArgs{
//						Cidr: pulumi.String("::ffff:106:708"),
//					},
//					&dbtcloud.IpRestrictionsRuleCidrArgs{
//						Cidr: pulumi.String("1.6.7.10/24"),
//					},
//				},
//				Type:           pulumi.String("deny"),
//				RuleSetEnabled: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// using  import blocks (requires Terraform >= 1.5)
//
// import {
//
//	to = dbtcloud_ip_restrictions_rule.my_rule
//
//	id = "ip_restriction_rule_id"
//
// }
//
// import {
//
//	to = dbtcloud_ip_restrictions_rule.my_rule
//
//	id = "12345"
//
// }
//
// using the older import command
//
// ```sh
// $ pulumi import dbtcloud:index/ipRestrictionsRule:IpRestrictionsRule my_rule "ip_restriction_rule_id"
// ```
//
// ```sh
// $ pulumi import dbtcloud:index/ipRestrictionsRule:IpRestrictionsRule my_rule 12345
// ```
type IpRestrictionsRule struct {
	pulumi.CustomResourceState

	// Set of CIDR ranges for this rule
	Cidrs IpRestrictionsRuleCidrArrayOutput `pulumi:"cidrs"`
	// A description of the IP restriction rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The name of the IP restriction rule
	Name pulumi.StringOutput `pulumi:"name"`
	// Whether the IP restriction rule set is enabled or not. Important!: This value needs to be the same for all rules if multiple rules are defined. All rules must be active or inactive at the same time.
	RuleSetEnabled pulumi.BoolOutput `pulumi:"ruleSetEnabled"`
	// The type of the IP restriction rule (allow or deny)
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewIpRestrictionsRule registers a new resource with the given unique name, arguments, and options.
func NewIpRestrictionsRule(ctx *pulumi.Context,
	name string, args *IpRestrictionsRuleArgs, opts ...pulumi.ResourceOption) (*IpRestrictionsRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Cidrs == nil {
		return nil, errors.New("invalid value for required argument 'Cidrs'")
	}
	if args.RuleSetEnabled == nil {
		return nil, errors.New("invalid value for required argument 'RuleSetEnabled'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource IpRestrictionsRule
	err := ctx.RegisterResource("dbtcloud:index/ipRestrictionsRule:IpRestrictionsRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIpRestrictionsRule gets an existing IpRestrictionsRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIpRestrictionsRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IpRestrictionsRuleState, opts ...pulumi.ResourceOption) (*IpRestrictionsRule, error) {
	var resource IpRestrictionsRule
	err := ctx.ReadResource("dbtcloud:index/ipRestrictionsRule:IpRestrictionsRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IpRestrictionsRule resources.
type ipRestrictionsRuleState struct {
	// Set of CIDR ranges for this rule
	Cidrs []IpRestrictionsRuleCidr `pulumi:"cidrs"`
	// A description of the IP restriction rule
	Description *string `pulumi:"description"`
	// The name of the IP restriction rule
	Name *string `pulumi:"name"`
	// Whether the IP restriction rule set is enabled or not. Important!: This value needs to be the same for all rules if multiple rules are defined. All rules must be active or inactive at the same time.
	RuleSetEnabled *bool `pulumi:"ruleSetEnabled"`
	// The type of the IP restriction rule (allow or deny)
	Type *string `pulumi:"type"`
}

type IpRestrictionsRuleState struct {
	// Set of CIDR ranges for this rule
	Cidrs IpRestrictionsRuleCidrArrayInput
	// A description of the IP restriction rule
	Description pulumi.StringPtrInput
	// The name of the IP restriction rule
	Name pulumi.StringPtrInput
	// Whether the IP restriction rule set is enabled or not. Important!: This value needs to be the same for all rules if multiple rules are defined. All rules must be active or inactive at the same time.
	RuleSetEnabled pulumi.BoolPtrInput
	// The type of the IP restriction rule (allow or deny)
	Type pulumi.StringPtrInput
}

func (IpRestrictionsRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*ipRestrictionsRuleState)(nil)).Elem()
}

type ipRestrictionsRuleArgs struct {
	// Set of CIDR ranges for this rule
	Cidrs []IpRestrictionsRuleCidr `pulumi:"cidrs"`
	// A description of the IP restriction rule
	Description *string `pulumi:"description"`
	// The name of the IP restriction rule
	Name *string `pulumi:"name"`
	// Whether the IP restriction rule set is enabled or not. Important!: This value needs to be the same for all rules if multiple rules are defined. All rules must be active or inactive at the same time.
	RuleSetEnabled bool `pulumi:"ruleSetEnabled"`
	// The type of the IP restriction rule (allow or deny)
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a IpRestrictionsRule resource.
type IpRestrictionsRuleArgs struct {
	// Set of CIDR ranges for this rule
	Cidrs IpRestrictionsRuleCidrArrayInput
	// A description of the IP restriction rule
	Description pulumi.StringPtrInput
	// The name of the IP restriction rule
	Name pulumi.StringPtrInput
	// Whether the IP restriction rule set is enabled or not. Important!: This value needs to be the same for all rules if multiple rules are defined. All rules must be active or inactive at the same time.
	RuleSetEnabled pulumi.BoolInput
	// The type of the IP restriction rule (allow or deny)
	Type pulumi.StringInput
}

func (IpRestrictionsRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ipRestrictionsRuleArgs)(nil)).Elem()
}

type IpRestrictionsRuleInput interface {
	pulumi.Input

	ToIpRestrictionsRuleOutput() IpRestrictionsRuleOutput
	ToIpRestrictionsRuleOutputWithContext(ctx context.Context) IpRestrictionsRuleOutput
}

func (*IpRestrictionsRule) ElementType() reflect.Type {
	return reflect.TypeOf((**IpRestrictionsRule)(nil)).Elem()
}

func (i *IpRestrictionsRule) ToIpRestrictionsRuleOutput() IpRestrictionsRuleOutput {
	return i.ToIpRestrictionsRuleOutputWithContext(context.Background())
}

func (i *IpRestrictionsRule) ToIpRestrictionsRuleOutputWithContext(ctx context.Context) IpRestrictionsRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpRestrictionsRuleOutput)
}

// IpRestrictionsRuleArrayInput is an input type that accepts IpRestrictionsRuleArray and IpRestrictionsRuleArrayOutput values.
// You can construct a concrete instance of `IpRestrictionsRuleArrayInput` via:
//
//	IpRestrictionsRuleArray{ IpRestrictionsRuleArgs{...} }
type IpRestrictionsRuleArrayInput interface {
	pulumi.Input

	ToIpRestrictionsRuleArrayOutput() IpRestrictionsRuleArrayOutput
	ToIpRestrictionsRuleArrayOutputWithContext(context.Context) IpRestrictionsRuleArrayOutput
}

type IpRestrictionsRuleArray []IpRestrictionsRuleInput

func (IpRestrictionsRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpRestrictionsRule)(nil)).Elem()
}

func (i IpRestrictionsRuleArray) ToIpRestrictionsRuleArrayOutput() IpRestrictionsRuleArrayOutput {
	return i.ToIpRestrictionsRuleArrayOutputWithContext(context.Background())
}

func (i IpRestrictionsRuleArray) ToIpRestrictionsRuleArrayOutputWithContext(ctx context.Context) IpRestrictionsRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpRestrictionsRuleArrayOutput)
}

// IpRestrictionsRuleMapInput is an input type that accepts IpRestrictionsRuleMap and IpRestrictionsRuleMapOutput values.
// You can construct a concrete instance of `IpRestrictionsRuleMapInput` via:
//
//	IpRestrictionsRuleMap{ "key": IpRestrictionsRuleArgs{...} }
type IpRestrictionsRuleMapInput interface {
	pulumi.Input

	ToIpRestrictionsRuleMapOutput() IpRestrictionsRuleMapOutput
	ToIpRestrictionsRuleMapOutputWithContext(context.Context) IpRestrictionsRuleMapOutput
}

type IpRestrictionsRuleMap map[string]IpRestrictionsRuleInput

func (IpRestrictionsRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpRestrictionsRule)(nil)).Elem()
}

func (i IpRestrictionsRuleMap) ToIpRestrictionsRuleMapOutput() IpRestrictionsRuleMapOutput {
	return i.ToIpRestrictionsRuleMapOutputWithContext(context.Background())
}

func (i IpRestrictionsRuleMap) ToIpRestrictionsRuleMapOutputWithContext(ctx context.Context) IpRestrictionsRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpRestrictionsRuleMapOutput)
}

type IpRestrictionsRuleOutput struct{ *pulumi.OutputState }

func (IpRestrictionsRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IpRestrictionsRule)(nil)).Elem()
}

func (o IpRestrictionsRuleOutput) ToIpRestrictionsRuleOutput() IpRestrictionsRuleOutput {
	return o
}

func (o IpRestrictionsRuleOutput) ToIpRestrictionsRuleOutputWithContext(ctx context.Context) IpRestrictionsRuleOutput {
	return o
}

// Set of CIDR ranges for this rule
func (o IpRestrictionsRuleOutput) Cidrs() IpRestrictionsRuleCidrArrayOutput {
	return o.ApplyT(func(v *IpRestrictionsRule) IpRestrictionsRuleCidrArrayOutput { return v.Cidrs }).(IpRestrictionsRuleCidrArrayOutput)
}

// A description of the IP restriction rule
func (o IpRestrictionsRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpRestrictionsRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The name of the IP restriction rule
func (o IpRestrictionsRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *IpRestrictionsRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Whether the IP restriction rule set is enabled or not. Important!: This value needs to be the same for all rules if multiple rules are defined. All rules must be active or inactive at the same time.
func (o IpRestrictionsRuleOutput) RuleSetEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *IpRestrictionsRule) pulumi.BoolOutput { return v.RuleSetEnabled }).(pulumi.BoolOutput)
}

// The type of the IP restriction rule (allow or deny)
func (o IpRestrictionsRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *IpRestrictionsRule) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type IpRestrictionsRuleArrayOutput struct{ *pulumi.OutputState }

func (IpRestrictionsRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpRestrictionsRule)(nil)).Elem()
}

func (o IpRestrictionsRuleArrayOutput) ToIpRestrictionsRuleArrayOutput() IpRestrictionsRuleArrayOutput {
	return o
}

func (o IpRestrictionsRuleArrayOutput) ToIpRestrictionsRuleArrayOutputWithContext(ctx context.Context) IpRestrictionsRuleArrayOutput {
	return o
}

func (o IpRestrictionsRuleArrayOutput) Index(i pulumi.IntInput) IpRestrictionsRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IpRestrictionsRule {
		return vs[0].([]*IpRestrictionsRule)[vs[1].(int)]
	}).(IpRestrictionsRuleOutput)
}

type IpRestrictionsRuleMapOutput struct{ *pulumi.OutputState }

func (IpRestrictionsRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpRestrictionsRule)(nil)).Elem()
}

func (o IpRestrictionsRuleMapOutput) ToIpRestrictionsRuleMapOutput() IpRestrictionsRuleMapOutput {
	return o
}

func (o IpRestrictionsRuleMapOutput) ToIpRestrictionsRuleMapOutputWithContext(ctx context.Context) IpRestrictionsRuleMapOutput {
	return o
}

func (o IpRestrictionsRuleMapOutput) MapIndex(k pulumi.StringInput) IpRestrictionsRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IpRestrictionsRule {
		return vs[0].(map[string]*IpRestrictionsRule)[vs[1].(string)]
	}).(IpRestrictionsRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IpRestrictionsRuleInput)(nil)).Elem(), &IpRestrictionsRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpRestrictionsRuleArrayInput)(nil)).Elem(), IpRestrictionsRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpRestrictionsRuleMapInput)(nil)).Elem(), IpRestrictionsRuleMap{})
	pulumi.RegisterOutputType(IpRestrictionsRuleOutput{})
	pulumi.RegisterOutputType(IpRestrictionsRuleArrayOutput{})
	pulumi.RegisterOutputType(IpRestrictionsRuleMapOutput{})
}
