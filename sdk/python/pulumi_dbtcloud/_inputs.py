# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'GlobalConnectionApacheSparkArgs',
    'GlobalConnectionApacheSparkArgsDict',
    'GlobalConnectionAthenaArgs',
    'GlobalConnectionAthenaArgsDict',
    'GlobalConnectionBigqueryArgs',
    'GlobalConnectionBigqueryArgsDict',
    'GlobalConnectionDatabricksArgs',
    'GlobalConnectionDatabricksArgsDict',
    'GlobalConnectionFabricArgs',
    'GlobalConnectionFabricArgsDict',
    'GlobalConnectionPostgresArgs',
    'GlobalConnectionPostgresArgsDict',
    'GlobalConnectionPostgresSshTunnelArgs',
    'GlobalConnectionPostgresSshTunnelArgsDict',
    'GlobalConnectionRedshiftArgs',
    'GlobalConnectionRedshiftArgsDict',
    'GlobalConnectionRedshiftSshTunnelArgs',
    'GlobalConnectionRedshiftSshTunnelArgsDict',
    'GlobalConnectionSnowflakeArgs',
    'GlobalConnectionSnowflakeArgsDict',
    'GlobalConnectionStarburstArgs',
    'GlobalConnectionStarburstArgsDict',
    'GlobalConnectionSynapseArgs',
    'GlobalConnectionSynapseArgsDict',
    'GroupGroupPermissionArgs',
    'GroupGroupPermissionArgsDict',
    'GroupPartialPermissionsGroupPermissionArgs',
    'GroupPartialPermissionsGroupPermissionArgsDict',
    'IpRestrictionsRuleCidrArgs',
    'IpRestrictionsRuleCidrArgsDict',
    'JobJobCompletionTriggerConditionArgs',
    'JobJobCompletionTriggerConditionArgsDict',
    'ServiceTokenServiceTokenPermissionArgs',
    'ServiceTokenServiceTokenPermissionArgsDict',
    'GetServiceTokenServiceTokenPermissionArgs',
    'GetServiceTokenServiceTokenPermissionArgsDict',
]

MYPY = False

if not MYPY:
    class GlobalConnectionApacheSparkArgsDict(TypedDict):
        cluster: pulumi.Input[str]
        """
        Spark cluster for the connection
        """
        host: pulumi.Input[str]
        """
        Hostname of the connection
        """
        method: pulumi.Input[str]
        """
        Authentication method for the connection (http or thrift).
        """
        auth: NotRequired[pulumi.Input[str]]
        """
        Auth
        """
        connect_retries: NotRequired[pulumi.Input[int]]
        """
        Connection retries. Default=0
        """
        connect_timeout: NotRequired[pulumi.Input[int]]
        """
        Connection time out in seconds. Default=10
        """
        organization: NotRequired[pulumi.Input[str]]
        """
        Organization ID
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for the connection. Default=443
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User
        """
elif False:
    GlobalConnectionApacheSparkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionApacheSparkArgs:
    def __init__(__self__, *,
                 cluster: pulumi.Input[str],
                 host: pulumi.Input[str],
                 method: pulumi.Input[str],
                 auth: Optional[pulumi.Input[str]] = None,
                 connect_retries: Optional[pulumi.Input[int]] = None,
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 organization: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster: Spark cluster for the connection
        :param pulumi.Input[str] host: Hostname of the connection
        :param pulumi.Input[str] method: Authentication method for the connection (http or thrift).
        :param pulumi.Input[str] auth: Auth
        :param pulumi.Input[int] connect_retries: Connection retries. Default=0
        :param pulumi.Input[int] connect_timeout: Connection time out in seconds. Default=10
        :param pulumi.Input[str] organization: Organization ID
        :param pulumi.Input[int] port: Port for the connection. Default=443
        :param pulumi.Input[str] user: User
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "method", method)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if connect_retries is not None:
            pulumi.set(__self__, "connect_retries", connect_retries)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cluster(self) -> pulumi.Input[str]:
        """
        Spark cluster for the connection
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the connection
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Authentication method for the connection (http or thrift).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[str]]:
        """
        Auth
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="connectRetries")
    def connect_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Connection retries. Default=0
        """
        return pulumi.get(self, "connect_retries")

    @connect_retries.setter
    def connect_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_retries", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Connection time out in seconds. Default=10
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[str]]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for the connection. Default=443
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class GlobalConnectionAthenaArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Specify the database (data catalog) to build models into (lowercase only).
        """
        region_name: pulumi.Input[str]
        """
        AWS region of your Athena instance.
        """
        s3_staging_dir: pulumi.Input[str]
        """
        S3 location to store Athena query results and metadata.
        """
        num_boto3_retries: NotRequired[pulumi.Input[int]]
        """
        Number of times to retry boto3 requests (e.g. deleting S3 files for materialized tables).
        """
        num_iceberg_retries: NotRequired[pulumi.Input[int]]
        """
        Number of times to retry iceberg commit queries to fix ICEBERG*COMMIT*ERROR.
        """
        num_retries: NotRequired[pulumi.Input[int]]
        """
        Number of times to retry a failing query.
        """
        poll_interval: NotRequired[pulumi.Input[int]]
        """
        Interval in seconds to use for polling the status of query results in Athena.
        """
        s3_data_dir: NotRequired[pulumi.Input[str]]
        """
        Prefix for storing tables, if different from the connection's S3 staging directory.
        """
        s3_data_naming: NotRequired[pulumi.Input[str]]
        """
        How to generate table paths in the S3 data directory.
        """
        s3_tmp_table_dir: NotRequired[pulumi.Input[str]]
        """
        Prefix for storing temporary tables, if different from the connection's S3 data directory.
        """
        spark_work_group: NotRequired[pulumi.Input[str]]
        """
        Identifier of Athena Spark workgroup for running Python models.
        """
        work_group: NotRequired[pulumi.Input[str]]
        """
        Identifier of Athena workgroup.
        """
elif False:
    GlobalConnectionAthenaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionAthenaArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 region_name: pulumi.Input[str],
                 s3_staging_dir: pulumi.Input[str],
                 num_boto3_retries: Optional[pulumi.Input[int]] = None,
                 num_iceberg_retries: Optional[pulumi.Input[int]] = None,
                 num_retries: Optional[pulumi.Input[int]] = None,
                 poll_interval: Optional[pulumi.Input[int]] = None,
                 s3_data_dir: Optional[pulumi.Input[str]] = None,
                 s3_data_naming: Optional[pulumi.Input[str]] = None,
                 s3_tmp_table_dir: Optional[pulumi.Input[str]] = None,
                 spark_work_group: Optional[pulumi.Input[str]] = None,
                 work_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database: Specify the database (data catalog) to build models into (lowercase only).
        :param pulumi.Input[str] region_name: AWS region of your Athena instance.
        :param pulumi.Input[str] s3_staging_dir: S3 location to store Athena query results and metadata.
        :param pulumi.Input[int] num_boto3_retries: Number of times to retry boto3 requests (e.g. deleting S3 files for materialized tables).
        :param pulumi.Input[int] num_iceberg_retries: Number of times to retry iceberg commit queries to fix ICEBERG*COMMIT*ERROR.
        :param pulumi.Input[int] num_retries: Number of times to retry a failing query.
        :param pulumi.Input[int] poll_interval: Interval in seconds to use for polling the status of query results in Athena.
        :param pulumi.Input[str] s3_data_dir: Prefix for storing tables, if different from the connection's S3 staging directory.
        :param pulumi.Input[str] s3_data_naming: How to generate table paths in the S3 data directory.
        :param pulumi.Input[str] s3_tmp_table_dir: Prefix for storing temporary tables, if different from the connection's S3 data directory.
        :param pulumi.Input[str] spark_work_group: Identifier of Athena Spark workgroup for running Python models.
        :param pulumi.Input[str] work_group: Identifier of Athena workgroup.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "s3_staging_dir", s3_staging_dir)
        if num_boto3_retries is not None:
            pulumi.set(__self__, "num_boto3_retries", num_boto3_retries)
        if num_iceberg_retries is not None:
            pulumi.set(__self__, "num_iceberg_retries", num_iceberg_retries)
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if poll_interval is not None:
            pulumi.set(__self__, "poll_interval", poll_interval)
        if s3_data_dir is not None:
            pulumi.set(__self__, "s3_data_dir", s3_data_dir)
        if s3_data_naming is not None:
            pulumi.set(__self__, "s3_data_naming", s3_data_naming)
        if s3_tmp_table_dir is not None:
            pulumi.set(__self__, "s3_tmp_table_dir", s3_tmp_table_dir)
        if spark_work_group is not None:
            pulumi.set(__self__, "spark_work_group", spark_work_group)
        if work_group is not None:
            pulumi.set(__self__, "work_group", work_group)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Specify the database (data catalog) to build models into (lowercase only).
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        AWS region of your Athena instance.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="s3StagingDir")
    def s3_staging_dir(self) -> pulumi.Input[str]:
        """
        S3 location to store Athena query results and metadata.
        """
        return pulumi.get(self, "s3_staging_dir")

    @s3_staging_dir.setter
    def s3_staging_dir(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_staging_dir", value)

    @property
    @pulumi.getter(name="numBoto3Retries")
    def num_boto3_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of times to retry boto3 requests (e.g. deleting S3 files for materialized tables).
        """
        return pulumi.get(self, "num_boto3_retries")

    @num_boto3_retries.setter
    def num_boto3_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_boto3_retries", value)

    @property
    @pulumi.getter(name="numIcebergRetries")
    def num_iceberg_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of times to retry iceberg commit queries to fix ICEBERG*COMMIT*ERROR.
        """
        return pulumi.get(self, "num_iceberg_retries")

    @num_iceberg_retries.setter
    def num_iceberg_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_iceberg_retries", value)

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of times to retry a failing query.
        """
        return pulumi.get(self, "num_retries")

    @num_retries.setter
    def num_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_retries", value)

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Interval in seconds to use for polling the status of query results in Athena.
        """
        return pulumi.get(self, "poll_interval")

    @poll_interval.setter
    def poll_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "poll_interval", value)

    @property
    @pulumi.getter(name="s3DataDir")
    def s3_data_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix for storing tables, if different from the connection's S3 staging directory.
        """
        return pulumi.get(self, "s3_data_dir")

    @s3_data_dir.setter
    def s3_data_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_data_dir", value)

    @property
    @pulumi.getter(name="s3DataNaming")
    def s3_data_naming(self) -> Optional[pulumi.Input[str]]:
        """
        How to generate table paths in the S3 data directory.
        """
        return pulumi.get(self, "s3_data_naming")

    @s3_data_naming.setter
    def s3_data_naming(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_data_naming", value)

    @property
    @pulumi.getter(name="s3TmpTableDir")
    def s3_tmp_table_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix for storing temporary tables, if different from the connection's S3 data directory.
        """
        return pulumi.get(self, "s3_tmp_table_dir")

    @s3_tmp_table_dir.setter
    def s3_tmp_table_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_tmp_table_dir", value)

    @property
    @pulumi.getter(name="sparkWorkGroup")
    def spark_work_group(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of Athena Spark workgroup for running Python models.
        """
        return pulumi.get(self, "spark_work_group")

    @spark_work_group.setter
    def spark_work_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spark_work_group", value)

    @property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of Athena workgroup.
        """
        return pulumi.get(self, "work_group")

    @work_group.setter
    def work_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_group", value)


if not MYPY:
    class GlobalConnectionBigqueryArgsDict(TypedDict):
        auth_provider_x509_cert_url: pulumi.Input[str]
        """
        Auth Provider X509 Cert URL for the Service Account
        """
        auth_uri: pulumi.Input[str]
        """
        Auth URI for the Service Account
        """
        client_email: pulumi.Input[str]
        """
        Service Account email
        """
        client_id: pulumi.Input[str]
        """
        Client ID of the Service Account
        """
        client_x509_cert_url: pulumi.Input[str]
        """
        Client X509 Cert URL for the Service Account
        """
        gcp_project_id: pulumi.Input[str]
        """
        The GCP project ID to use for the connection
        """
        private_key: pulumi.Input[str]
        """
        Private Key for the Service Account
        """
        private_key_id: pulumi.Input[str]
        """
        Private Key ID for the Service Account
        """
        token_uri: pulumi.Input[str]
        """
        Token URI for the Service Account
        """
        application_id: NotRequired[pulumi.Input[str]]
        """
        OAuth Client ID
        """
        application_secret: NotRequired[pulumi.Input[str]]
        """
        OAuth Client Secret
        """
        dataproc_cluster_name: NotRequired[pulumi.Input[str]]
        """
        Dataproc cluster name for PySpark workloads
        """
        dataproc_region: NotRequired[pulumi.Input[str]]
        """
        Google Cloud region for PySpark workloads on Dataproc
        """
        execution_project: NotRequired[pulumi.Input[str]]
        """
        Project to bill for query execution
        """
        gcs_bucket: NotRequired[pulumi.Input[str]]
        """
        URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        """
        impersonate_service_account: NotRequired[pulumi.Input[str]]
        """
        Service Account to impersonate when running queries
        """
        job_creation_timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        Maximum timeout for the job creation step
        """
        job_retry_deadline_seconds: NotRequired[pulumi.Input[int]]
        """
        Total number of seconds to wait while retrying the same query
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Location to create new Datasets in
        """
        maximum_bytes_billed: NotRequired[pulumi.Input[int]]
        """
        Max number of bytes that can be billed for a given BigQuery query
        """
        priority: NotRequired[pulumi.Input[str]]
        """
        The priority with which to execute BigQuery queries (batch or interactive)
        """
        retries: NotRequired[pulumi.Input[int]]
        """
        Number of retries for queries
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        OAuth scopes for the BigQuery connection
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        Timeout in seconds for queries
        """
elif False:
    GlobalConnectionBigqueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionBigqueryArgs:
    def __init__(__self__, *,
                 auth_provider_x509_cert_url: pulumi.Input[str],
                 auth_uri: pulumi.Input[str],
                 client_email: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_x509_cert_url: pulumi.Input[str],
                 gcp_project_id: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 private_key_id: pulumi.Input[str],
                 token_uri: pulumi.Input[str],
                 application_id: Optional[pulumi.Input[str]] = None,
                 application_secret: Optional[pulumi.Input[str]] = None,
                 dataproc_cluster_name: Optional[pulumi.Input[str]] = None,
                 dataproc_region: Optional[pulumi.Input[str]] = None,
                 execution_project: Optional[pulumi.Input[str]] = None,
                 gcs_bucket: Optional[pulumi.Input[str]] = None,
                 impersonate_service_account: Optional[pulumi.Input[str]] = None,
                 job_creation_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 job_retry_deadline_seconds: Optional[pulumi.Input[int]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 maximum_bytes_billed: Optional[pulumi.Input[int]] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] auth_provider_x509_cert_url: Auth Provider X509 Cert URL for the Service Account
        :param pulumi.Input[str] auth_uri: Auth URI for the Service Account
        :param pulumi.Input[str] client_email: Service Account email
        :param pulumi.Input[str] client_id: Client ID of the Service Account
        :param pulumi.Input[str] client_x509_cert_url: Client X509 Cert URL for the Service Account
        :param pulumi.Input[str] gcp_project_id: The GCP project ID to use for the connection
        :param pulumi.Input[str] private_key: Private Key for the Service Account
        :param pulumi.Input[str] private_key_id: Private Key ID for the Service Account
        :param pulumi.Input[str] token_uri: Token URI for the Service Account
        :param pulumi.Input[str] application_id: OAuth Client ID
        :param pulumi.Input[str] application_secret: OAuth Client Secret
        :param pulumi.Input[str] dataproc_cluster_name: Dataproc cluster name for PySpark workloads
        :param pulumi.Input[str] dataproc_region: Google Cloud region for PySpark workloads on Dataproc
        :param pulumi.Input[str] execution_project: Project to bill for query execution
        :param pulumi.Input[str] gcs_bucket: URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        :param pulumi.Input[str] impersonate_service_account: Service Account to impersonate when running queries
        :param pulumi.Input[int] job_creation_timeout_seconds: Maximum timeout for the job creation step
        :param pulumi.Input[int] job_retry_deadline_seconds: Total number of seconds to wait while retrying the same query
        :param pulumi.Input[str] location: Location to create new Datasets in
        :param pulumi.Input[int] maximum_bytes_billed: Max number of bytes that can be billed for a given BigQuery query
        :param pulumi.Input[str] priority: The priority with which to execute BigQuery queries (batch or interactive)
        :param pulumi.Input[int] retries: Number of retries for queries
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: OAuth scopes for the BigQuery connection
        :param pulumi.Input[int] timeout_seconds: Timeout in seconds for queries
        """
        pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        pulumi.set(__self__, "auth_uri", auth_uri)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)
        pulumi.set(__self__, "token_uri", token_uri)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_secret is not None:
            pulumi.set(__self__, "application_secret", application_secret)
        if dataproc_cluster_name is not None:
            pulumi.set(__self__, "dataproc_cluster_name", dataproc_cluster_name)
        if dataproc_region is not None:
            pulumi.set(__self__, "dataproc_region", dataproc_region)
        if execution_project is not None:
            pulumi.set(__self__, "execution_project", execution_project)
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if impersonate_service_account is not None:
            pulumi.set(__self__, "impersonate_service_account", impersonate_service_account)
        if job_creation_timeout_seconds is not None:
            pulumi.set(__self__, "job_creation_timeout_seconds", job_creation_timeout_seconds)
        if job_retry_deadline_seconds is not None:
            pulumi.set(__self__, "job_retry_deadline_seconds", job_retry_deadline_seconds)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_bytes_billed is not None:
            pulumi.set(__self__, "maximum_bytes_billed", maximum_bytes_billed)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> pulumi.Input[str]:
        """
        Auth Provider X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> pulumi.Input[str]:
        """
        Auth URI for the Service Account
        """
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> pulumi.Input[str]:
        """
        Service Account email
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID of the Service Account
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> pulumi.Input[str]:
        """
        Client X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> pulumi.Input[str]:
        """
        The GCP project ID to use for the connection
        """
        return pulumi.get(self, "gcp_project_id")

    @gcp_project_id.setter
    def gcp_project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "gcp_project_id", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Private Key for the Service Account
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> pulumi.Input[str]:
        """
        Private Key ID for the Service Account
        """
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> pulumi.Input[str]:
        """
        Token URI for the Service Account
        """
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_uri", value)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="applicationSecret")
    def application_secret(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client Secret
        """
        return pulumi.get(self, "application_secret")

    @application_secret.setter
    def application_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_secret", value)

    @property
    @pulumi.getter(name="dataprocClusterName")
    def dataproc_cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Dataproc cluster name for PySpark workloads
        """
        return pulumi.get(self, "dataproc_cluster_name")

    @dataproc_cluster_name.setter
    def dataproc_cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataproc_cluster_name", value)

    @property
    @pulumi.getter(name="dataprocRegion")
    def dataproc_region(self) -> Optional[pulumi.Input[str]]:
        """
        Google Cloud region for PySpark workloads on Dataproc
        """
        return pulumi.get(self, "dataproc_region")

    @dataproc_region.setter
    def dataproc_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataproc_region", value)

    @property
    @pulumi.getter(name="executionProject")
    def execution_project(self) -> Optional[pulumi.Input[str]]:
        """
        Project to bill for query execution
        """
        return pulumi.get(self, "execution_project")

    @execution_project.setter
    def execution_project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_project", value)

    @property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[pulumi.Input[str]]:
        """
        URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        """
        return pulumi.get(self, "gcs_bucket")

    @gcs_bucket.setter
    def gcs_bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gcs_bucket", value)

    @property
    @pulumi.getter(name="impersonateServiceAccount")
    def impersonate_service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Service Account to impersonate when running queries
        """
        return pulumi.get(self, "impersonate_service_account")

    @impersonate_service_account.setter
    def impersonate_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "impersonate_service_account", value)

    @property
    @pulumi.getter(name="jobCreationTimeoutSeconds")
    def job_creation_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum timeout for the job creation step
        """
        return pulumi.get(self, "job_creation_timeout_seconds")

    @job_creation_timeout_seconds.setter
    def job_creation_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_creation_timeout_seconds", value)

    @property
    @pulumi.getter(name="jobRetryDeadlineSeconds")
    def job_retry_deadline_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of seconds to wait while retrying the same query
        """
        return pulumi.get(self, "job_retry_deadline_seconds")

    @job_retry_deadline_seconds.setter
    def job_retry_deadline_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "job_retry_deadline_seconds", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Location to create new Datasets in
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="maximumBytesBilled")
    def maximum_bytes_billed(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of bytes that can be billed for a given BigQuery query
        """
        return pulumi.get(self, "maximum_bytes_billed")

    @maximum_bytes_billed.setter
    def maximum_bytes_billed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_bytes_billed", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The priority with which to execute BigQuery queries (batch or interactive)
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries for queries
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        OAuth scopes for the BigQuery connection
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout in seconds for queries
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class GlobalConnectionDatabricksArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The hostname of the Databricks cluster or SQL warehouse.
        """
        http_path: pulumi.Input[str]
        """
        The HTTP path of the Databricks cluster or SQL warehouse.
        """
        catalog: NotRequired[pulumi.Input[str]]
        """
        Catalog name if Unity Catalog is enabled in your Databricks workspace.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
elif False:
    GlobalConnectionDatabricksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionDatabricksArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 http_path: pulumi.Input[str],
                 catalog: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The hostname of the Databricks cluster or SQL warehouse.
        :param pulumi.Input[str] http_path: The HTTP path of the Databricks cluster or SQL warehouse.
        :param pulumi.Input[str] catalog: Catalog name if Unity Catalog is enabled in your Databricks workspace.
        :param pulumi.Input[str] client_id: Required to enable Databricks OAuth authentication for IDE developers.
        :param pulumi.Input[str] client_secret: Required to enable Databricks OAuth authentication for IDE developers.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http_path", http_path)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The hostname of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> pulumi.Input[str]:
        """
        The HTTP path of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "http_path")

    @http_path.setter
    def http_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_path", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[str]]:
        """
        Catalog name if Unity Catalog is enabled in your Databricks workspace.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class GlobalConnectionFabricArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        The database to connect to for this connection.
        """
        server: pulumi.Input[str]
        """
        The server hostname.
        """
        login_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port to connect to for this connection. Default=1433
        """
        query_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        retries: NotRequired[pulumi.Input[int]]
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
elif False:
    GlobalConnectionFabricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionFabricArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 server: pulumi.Input[str],
                 login_timeout: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 query_timeout: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database: The database to connect to for this connection.
        :param pulumi.Input[str] server: The server hostname.
        :param pulumi.Input[int] login_timeout: The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param pulumi.Input[int] port: The port to connect to for this connection. Default=1433
        :param pulumi.Input[int] query_timeout: The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param pulumi.Input[int] retries: The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "server", server)
        if login_timeout is not None:
            pulumi.set(__self__, "login_timeout", login_timeout)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The database to connect to for this connection.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        """
        The server hostname.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="loginTimeout")
    def login_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "login_timeout")

    @login_timeout.setter
    def login_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "login_timeout", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to connect to for this connection. Default=1433
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


if not MYPY:
    class GlobalConnectionPostgresArgsDict(TypedDict):
        dbname: pulumi.Input[str]
        """
        The database name for this connection.
        """
        hostname: pulumi.Input[str]
        """
        The hostname of the database.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port to connect to for this connection. Default=5432
        """
        ssh_tunnel: NotRequired[pulumi.Input['GlobalConnectionPostgresSshTunnelArgsDict']]
        """
        PostgreSQL SSH Tunnel configuration
        """
elif False:
    GlobalConnectionPostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionPostgresArgs:
    def __init__(__self__, *,
                 dbname: pulumi.Input[str],
                 hostname: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 ssh_tunnel: Optional[pulumi.Input['GlobalConnectionPostgresSshTunnelArgs']] = None):
        """
        :param pulumi.Input[str] dbname: The database name for this connection.
        :param pulumi.Input[str] hostname: The hostname of the database.
        :param pulumi.Input[int] port: The port to connect to for this connection. Default=5432
        :param pulumi.Input['GlobalConnectionPostgresSshTunnelArgs'] ssh_tunnel: PostgreSQL SSH Tunnel configuration
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_tunnel is not None:
            pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)

    @property
    @pulumi.getter
    def dbname(self) -> pulumi.Input[str]:
        """
        The database name for this connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: pulumi.Input[str]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname of the database.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to connect to for this connection. Default=5432
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> Optional[pulumi.Input['GlobalConnectionPostgresSshTunnelArgs']]:
        """
        PostgreSQL SSH Tunnel configuration
        """
        return pulumi.get(self, "ssh_tunnel")

    @ssh_tunnel.setter
    def ssh_tunnel(self, value: Optional[pulumi.Input['GlobalConnectionPostgresSshTunnelArgs']]):
        pulumi.set(self, "ssh_tunnel", value)


if not MYPY:
    class GlobalConnectionPostgresSshTunnelArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        The hostname for the SSH tunnel.
        """
        port: pulumi.Input[int]
        """
        The HTTP port for the SSH tunnel.
        """
        username: pulumi.Input[str]
        """
        The username to use for the SSH tunnel.
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The ID of the SSH tunnel connection.
        """
        public_key: NotRequired[pulumi.Input[str]]
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
elif False:
    GlobalConnectionPostgresSshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionPostgresSshTunnelArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 port: pulumi.Input[int],
                 username: pulumi.Input[str],
                 id: Optional[pulumi.Input[int]] = None,
                 public_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: The hostname for the SSH tunnel.
        :param pulumi.Input[int] port: The HTTP port for the SSH tunnel.
        :param pulumi.Input[str] username: The username to use for the SSH tunnel.
        :param pulumi.Input[int] id: The ID of the SSH tunnel connection.
        :param pulumi.Input[str] public_key: The SSH public key generated to allow connecting via SSH tunnel.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The HTTP port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username to use for the SSH tunnel.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the SSH tunnel connection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class GlobalConnectionRedshiftArgsDict(TypedDict):
        dbname: pulumi.Input[str]
        """
        The database name for this connection.
        """
        hostname: pulumi.Input[str]
        """
        The hostname of the data warehouse.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port to connect to for this connection. Default=5432
        """
        ssh_tunnel: NotRequired[pulumi.Input['GlobalConnectionRedshiftSshTunnelArgsDict']]
        """
        Redshift SSH Tunnel configuration
        """
elif False:
    GlobalConnectionRedshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionRedshiftArgs:
    def __init__(__self__, *,
                 dbname: pulumi.Input[str],
                 hostname: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 ssh_tunnel: Optional[pulumi.Input['GlobalConnectionRedshiftSshTunnelArgs']] = None):
        """
        :param pulumi.Input[str] dbname: The database name for this connection.
        :param pulumi.Input[str] hostname: The hostname of the data warehouse.
        :param pulumi.Input[int] port: The port to connect to for this connection. Default=5432
        :param pulumi.Input['GlobalConnectionRedshiftSshTunnelArgs'] ssh_tunnel: Redshift SSH Tunnel configuration
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_tunnel is not None:
            pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)

    @property
    @pulumi.getter
    def dbname(self) -> pulumi.Input[str]:
        """
        The database name for this connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: pulumi.Input[str]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname of the data warehouse.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to connect to for this connection. Default=5432
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> Optional[pulumi.Input['GlobalConnectionRedshiftSshTunnelArgs']]:
        """
        Redshift SSH Tunnel configuration
        """
        return pulumi.get(self, "ssh_tunnel")

    @ssh_tunnel.setter
    def ssh_tunnel(self, value: Optional[pulumi.Input['GlobalConnectionRedshiftSshTunnelArgs']]):
        pulumi.set(self, "ssh_tunnel", value)


if not MYPY:
    class GlobalConnectionRedshiftSshTunnelArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        The hostname for the SSH tunnel.
        """
        port: pulumi.Input[int]
        """
        The HTTP port for the SSH tunnel.
        """
        username: pulumi.Input[str]
        """
        The username to use for the SSH tunnel.
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The ID of the SSH tunnel connection.
        """
        public_key: NotRequired[pulumi.Input[str]]
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
elif False:
    GlobalConnectionRedshiftSshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionRedshiftSshTunnelArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 port: pulumi.Input[int],
                 username: pulumi.Input[str],
                 id: Optional[pulumi.Input[int]] = None,
                 public_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: The hostname for the SSH tunnel.
        :param pulumi.Input[int] port: The HTTP port for the SSH tunnel.
        :param pulumi.Input[str] username: The username to use for the SSH tunnel.
        :param pulumi.Input[int] id: The ID of the SSH tunnel connection.
        :param pulumi.Input[str] public_key: The SSH public key generated to allow connecting via SSH tunnel.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The HTTP port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username to use for the SSH tunnel.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the SSH tunnel connection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class GlobalConnectionSnowflakeArgsDict(TypedDict):
        account: pulumi.Input[str]
        """
        The Snowflake account name
        """
        database: pulumi.Input[str]
        """
        The default database for the connection
        """
        warehouse: pulumi.Input[str]
        """
        The default Snowflake Warehouse to use for the connection
        """
        allow_sso: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        """
        client_session_keep_alive: NotRequired[pulumi.Input[bool]]
        """
        If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        """
        oauth_client_id: NotRequired[pulumi.Input[str]]
        """
        OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        """
        oauth_client_secret: NotRequired[pulumi.Input[str]]
        """
        OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        """
        role: NotRequired[pulumi.Input[str]]
        """
        The Snowflake role to use when running queries on the connection
        """
elif False:
    GlobalConnectionSnowflakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionSnowflakeArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[str],
                 database: pulumi.Input[str],
                 warehouse: pulumi.Input[str],
                 allow_sso: Optional[pulumi.Input[bool]] = None,
                 client_session_keep_alive: Optional[pulumi.Input[bool]] = None,
                 oauth_client_id: Optional[pulumi.Input[str]] = None,
                 oauth_client_secret: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account: The Snowflake account name
        :param pulumi.Input[str] database: The default database for the connection
        :param pulumi.Input[str] warehouse: The default Snowflake Warehouse to use for the connection
        :param pulumi.Input[bool] allow_sso: Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        :param pulumi.Input[bool] client_session_keep_alive: If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        :param pulumi.Input[str] oauth_client_id: OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        :param pulumi.Input[str] oauth_client_secret: OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        :param pulumi.Input[str] role: The Snowflake role to use when running queries on the connection
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "warehouse", warehouse)
        if allow_sso is not None:
            pulumi.set(__self__, "allow_sso", allow_sso)
        if client_session_keep_alive is not None:
            pulumi.set(__self__, "client_session_keep_alive", client_session_keep_alive)
        if oauth_client_id is not None:
            pulumi.set(__self__, "oauth_client_id", oauth_client_id)
        if oauth_client_secret is not None:
            pulumi.set(__self__, "oauth_client_secret", oauth_client_secret)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def account(self) -> pulumi.Input[str]:
        """
        The Snowflake account name
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[str]):
        pulumi.set(self, "account", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The default database for the connection
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def warehouse(self) -> pulumi.Input[str]:
        """
        The default Snowflake Warehouse to use for the connection
        """
        return pulumi.get(self, "warehouse")

    @warehouse.setter
    def warehouse(self, value: pulumi.Input[str]):
        pulumi.set(self, "warehouse", value)

    @property
    @pulumi.getter(name="allowSso")
    def allow_sso(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        """
        return pulumi.get(self, "allow_sso")

    @allow_sso.setter
    def allow_sso(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_sso", value)

    @property
    @pulumi.getter(name="clientSessionKeepAlive")
    def client_session_keep_alive(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        """
        return pulumi.get(self, "client_session_keep_alive")

    @client_session_keep_alive.setter
    def client_session_keep_alive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_session_keep_alive", value)

    @property
    @pulumi.getter(name="oauthClientId")
    def oauth_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_id")

    @oauth_client_id.setter
    def oauth_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oauth_client_id", value)

    @property
    @pulumi.getter(name="oauthClientSecret")
    def oauth_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_secret")

    @oauth_client_secret.setter
    def oauth_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oauth_client_secret", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The Snowflake role to use when running queries on the connection
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class GlobalConnectionStarburstArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The hostname of the account to connect to.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The authentication method. Only LDAP for now.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port to connect to for this connection. Default=443
        """
elif False:
    GlobalConnectionStarburstArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionStarburstArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 method: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: The hostname of the account to connect to.
        :param pulumi.Input[str] method: The authentication method. Only LDAP for now.
        :param pulumi.Input[int] port: The port to connect to for this connection. Default=443
        """
        pulumi.set(__self__, "host", host)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The hostname of the account to connect to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The authentication method. Only LDAP for now.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to connect to for this connection. Default=443
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GlobalConnectionSynapseArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        The database to connect to for this connection.
        """
        host: pulumi.Input[str]
        """
        The server hostname.
        """
        login_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port to connect to for this connection. Default=1433
        """
        query_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        retries: NotRequired[pulumi.Input[int]]
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
elif False:
    GlobalConnectionSynapseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalConnectionSynapseArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 login_timeout: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 query_timeout: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database: The database to connect to for this connection.
        :param pulumi.Input[str] host: The server hostname.
        :param pulumi.Input[int] login_timeout: The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param pulumi.Input[int] port: The port to connect to for this connection. Default=1433
        :param pulumi.Input[int] query_timeout: The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param pulumi.Input[int] retries: The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        if login_timeout is not None:
            pulumi.set(__self__, "login_timeout", login_timeout)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The database to connect to for this connection.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The server hostname.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="loginTimeout")
    def login_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "login_timeout")

    @login_timeout.setter
    def login_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "login_timeout", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to connect to for this connection. Default=1433
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "query_timeout")

    @query_timeout.setter
    def query_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_timeout", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


if not MYPY:
    class GroupGroupPermissionArgsDict(TypedDict):
        all_projects: pulumi.Input[bool]
        """
        Whether access should be provided for all projects or not.
        """
        permission_set: pulumi.Input[str]
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        project_id: NotRequired[pulumi.Input[int]]
        """
        Project ID to apply this permission to for this group.
        """
        writable_environment_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
elif False:
    GroupGroupPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupGroupPermissionArgs:
    def __init__(__self__, *,
                 all_projects: pulumi.Input[bool],
                 permission_set: pulumi.Input[str],
                 project_id: Optional[pulumi.Input[int]] = None,
                 writable_environment_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] all_projects: Whether access should be provided for all projects or not.
        :param pulumi.Input[str] permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param pulumi.Input[int] project_id: Project ID to apply this permission to for this group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> pulumi.Input[bool]:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @all_projects.setter
    def all_projects(self, value: pulumi.Input[bool]):
        pulumi.set(self, "all_projects", value)

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> pulumi.Input[str]:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @permission_set.setter
    def permission_set(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission_set", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[int]]:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")

    @writable_environment_categories.setter
    def writable_environment_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "writable_environment_categories", value)


if not MYPY:
    class GroupPartialPermissionsGroupPermissionArgsDict(TypedDict):
        all_projects: pulumi.Input[bool]
        """
        Whether access should be provided for all projects or not.
        """
        permission_set: pulumi.Input[str]
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        project_id: NotRequired[pulumi.Input[int]]
        """
        Project ID to apply this permission to for this group.
        """
        writable_environment_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
elif False:
    GroupPartialPermissionsGroupPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPartialPermissionsGroupPermissionArgs:
    def __init__(__self__, *,
                 all_projects: pulumi.Input[bool],
                 permission_set: pulumi.Input[str],
                 project_id: Optional[pulumi.Input[int]] = None,
                 writable_environment_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] all_projects: Whether access should be provided for all projects or not.
        :param pulumi.Input[str] permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param pulumi.Input[int] project_id: Project ID to apply this permission to for this group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> pulumi.Input[bool]:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @all_projects.setter
    def all_projects(self, value: pulumi.Input[bool]):
        pulumi.set(self, "all_projects", value)

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> pulumi.Input[str]:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @permission_set.setter
    def permission_set(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission_set", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[int]]:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")

    @writable_environment_categories.setter
    def writable_environment_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "writable_environment_categories", value)


if not MYPY:
    class IpRestrictionsRuleCidrArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[str]]
        """
        IP CIDR range (can be IPv4 or IPv6)
        """
        cidr_ipv6: NotRequired[pulumi.Input[str]]
        """
        IPv6 CIDR range (read-only)
        """
        id: NotRequired[pulumi.Input[int]]
        """
        ID of the CIDR range
        """
        ip_restriction_rule_id: NotRequired[pulumi.Input[int]]
        """
        ID of the IP restriction rule
        """
elif False:
    IpRestrictionsRuleCidrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpRestrictionsRuleCidrArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 cidr_ipv6: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 ip_restriction_rule_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cidr: IP CIDR range (can be IPv4 or IPv6)
        :param pulumi.Input[str] cidr_ipv6: IPv6 CIDR range (read-only)
        :param pulumi.Input[int] id: ID of the CIDR range
        :param pulumi.Input[int] ip_restriction_rule_id: ID of the IP restriction rule
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_restriction_rule_id is not None:
            pulumi.set(__self__, "ip_restriction_rule_id", ip_restriction_rule_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        """
        IP CIDR range (can be IPv4 or IPv6)
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 CIDR range (read-only)
        """
        return pulumi.get(self, "cidr_ipv6")

    @cidr_ipv6.setter
    def cidr_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_ipv6", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        ID of the CIDR range
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipRestrictionRuleId")
    def ip_restriction_rule_id(self) -> Optional[pulumi.Input[int]]:
        """
        ID of the IP restriction rule
        """
        return pulumi.get(self, "ip_restriction_rule_id")

    @ip_restriction_rule_id.setter
    def ip_restriction_rule_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ip_restriction_rule_id", value)


if not MYPY:
    class JobJobCompletionTriggerConditionArgsDict(TypedDict):
        job_id: pulumi.Input[int]
        """
        The ID of the job that would trigger this job after completion.
        """
        project_id: pulumi.Input[int]
        """
        The ID of the project where the trigger job is running in.
        """
        statuses: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.
        """
elif False:
    JobJobCompletionTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobCompletionTriggerConditionArgs:
    def __init__(__self__, *,
                 job_id: pulumi.Input[int],
                 project_id: pulumi.Input[int],
                 statuses: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[int] job_id: The ID of the job that would trigger this job after completion.
        :param pulumi.Input[int] project_id: The ID of the project where the trigger job is running in.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statuses: List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.
        """
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[int]:
        """
        The ID of the job that would trigger this job after completion.
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[int]:
        """
        The ID of the project where the trigger job is running in.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def statuses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "statuses", value)


if not MYPY:
    class ServiceTokenServiceTokenPermissionArgsDict(TypedDict):
        all_projects: pulumi.Input[bool]
        """
        Whether or not to apply this permission to all projects for this service token
        """
        permission_set: pulumi.Input[str]
        """
        Set of permissions to apply
        """
        project_id: NotRequired[pulumi.Input[int]]
        """
        Project ID to apply this permission to for this service token
        """
        writable_environment_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
elif False:
    ServiceTokenServiceTokenPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTokenServiceTokenPermissionArgs:
    def __init__(__self__, *,
                 all_projects: pulumi.Input[bool],
                 permission_set: pulumi.Input[str],
                 project_id: Optional[pulumi.Input[int]] = None,
                 writable_environment_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] all_projects: Whether or not to apply this permission to all projects for this service token
        :param pulumi.Input[str] permission_set: Set of permissions to apply
        :param pulumi.Input[int] project_id: Project ID to apply this permission to for this service token
        :param pulumi.Input[Sequence[pulumi.Input[str]]] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> pulumi.Input[bool]:
        """
        Whether or not to apply this permission to all projects for this service token
        """
        return pulumi.get(self, "all_projects")

    @all_projects.setter
    def all_projects(self, value: pulumi.Input[bool]):
        pulumi.set(self, "all_projects", value)

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> pulumi.Input[str]:
        """
        Set of permissions to apply
        """
        return pulumi.get(self, "permission_set")

    @permission_set.setter
    def permission_set(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission_set", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[int]]:
        """
        Project ID to apply this permission to for this service token
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")

    @writable_environment_categories.setter
    def writable_environment_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "writable_environment_categories", value)


if not MYPY:
    class GetServiceTokenServiceTokenPermissionArgsDict(TypedDict):
        all_projects: bool
        """
        Whether or not to apply this permission to all projects for this service token
        """
        permission_set: str
        """
        Set of permissions to apply
        """
        project_id: int
        """
        Project ID to apply this permission to for this service token
        """
        writable_environment_categories: Sequence[str]
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
elif False:
    GetServiceTokenServiceTokenPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceTokenServiceTokenPermissionArgs:
    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: int,
                 writable_environment_categories: Sequence[str]):
        """
        :param bool all_projects: Whether or not to apply this permission to all projects for this service token
        :param str permission_set: Set of permissions to apply
        :param int project_id: Project ID to apply this permission to for this service token
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether or not to apply this permission to all projects for this service token
        """
        return pulumi.get(self, "all_projects")

    @all_projects.setter
    def all_projects(self, value: bool):
        pulumi.set(self, "all_projects", value)

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply
        """
        return pulumi.get(self, "permission_set")

    @permission_set.setter
    def permission_set(self, value: str):
        pulumi.set(self, "permission_set", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        Project ID to apply this permission to for this service token
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: int):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Sequence[str]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")

    @writable_environment_categories.setter
    def writable_environment_categories(self, value: Sequence[str]):
        pulumi.set(self, "writable_environment_categories", value)


