# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ScimGroupPartialPermissionsArgs', 'ScimGroupPartialPermissions']

@pulumi.input_type
class ScimGroupPartialPermissionsArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[_builtins.int],
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]]] = None):
        """
        The set of arguments for constructing a ScimGroupPartialPermissions resource.

        :param pulumi.Input[_builtins.int] group_id: The ID of the existing group to manage partial permissions for. This group must already exist and is typically from an external identity provider synced via SCIM.
        :param pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]] permissions: Partial set of permissions to apply to the group. These permissions will be added to any existing permissions. Other permissions on the group will not be affected.
        """
        pulumi.set(__self__, "group_id", group_id)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[_builtins.int]:
        """
        The ID of the existing group to manage partial permissions for. This group must already exist and is typically from an external identity provider synced via SCIM.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]]]:
        """
        Partial set of permissions to apply to the group. These permissions will be added to any existing permissions. Other permissions on the group will not be affected.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class _ScimGroupPartialPermissionsState:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]]] = None):
        """
        Input properties used for looking up and filtering ScimGroupPartialPermissions resources.

        :param pulumi.Input[_builtins.int] group_id: The ID of the existing group to manage partial permissions for. This group must already exist and is typically from an external identity provider synced via SCIM.
        :param pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]] permissions: Partial set of permissions to apply to the group. These permissions will be added to any existing permissions. Other permissions on the group will not be affected.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the existing group to manage partial permissions for. This group must already exist and is typically from an external identity provider synced via SCIM.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]]]:
        """
        Partial set of permissions to apply to the group. These permissions will be added to any existing permissions. Other permissions on the group will not be affected.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScimGroupPartialPermissionsPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)


@pulumi.type_token("dbtcloud:index/scimGroupPartialPermissions:ScimGroupPartialPermissions")
class ScimGroupPartialPermissions(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ScimGroupPartialPermissionsPermissionArgs', 'ScimGroupPartialPermissionsPermissionArgsDict']]]]] = None,
                 __props__=None):
        """
        Provide a partial set of permissions for an externally managed group (e.g., SCIM, manually created).
        This resource ONLY manages a subset of permissions and never creates or deletes groups.

        This is designed for federated permission management where a platform team sets global permissions
        and individual teams manage their own project-specific permissions for the same group.

        ⚠️  **Important Differences:**
        - `dbt_cloud_group`: Creates group and fully manages ALL permissions (single Pulumi Stack)
        - `dbt_cloud_group_partial_permissions`: Creates group and manages PARTIAL permissions (multiple Pulumi Stacks)
        - `dbt_cloud_scim_group_permissions`: Externally-managed group, fully manages ALL permissions (replaces all permissions)
        - `dbt_cloud_scim_group_partial_permissions`: Externally-managed group, manages PARTIAL permissions (adds/removes only specified permissions)

        **Use Case:**
        - Group exists in external identity provider (e.g., Okta, Azure AD) and syncs via SCIM
        - Platform team manages base permissions (e.g., account-level access)
        - Individual teams manage their own project-specific permissions
        - Multiple Pulumi Stacks can safely manage different permissions for the same group

        ⚠️  Do not mix different resource types for the same group:
        - Don't use `dbt_cloud_scim_group_permissions` (full permissions) with `dbt_cloud_scim_group_partial_permissions` (partial permissions)
        - Don't use `dbt_cloud_group` or `dbt_cloud_group_partial_permissions` for externally managed groups

        The resource currently requires a Service Token with Account Admin access.

        **Behavior:**
        - When creating: Adds specified permissions to the existing group (if not already present)
        - When updating: Adds new permissions and removes old permissions from this resource
        - When deleting: Removes only the permissions managed by this resource (group and other permissions remain)

        > This resource is designed for **federated permission management** where multiple teams manage different permissions for the same externally-managed group (e.g., SCIM groups).

        > **Warning: Duplicate Permissions Across States** - If multiple Terraform states define the **exact same permission** (identical `permission_set`, `project_id`, `all_projects`, and `writable_environment_categories`), they will reference the same underlying permission object in dbt Cloud. This creates a conflict: when one state deletes its resource, it removes the permission from dbt Cloud, causing drift in other states that reference the same permission. **Best Practice:** Ensure each Terraform state manages **distinct** permissions. Coordinate with other teams to avoid defining identical permissions, or differentiate them using `writable_environment_categories`.

        ## Use Case Guidelines

        Choose the right resource for your use case:

        | Resource | Group Creation | Permission Management | Use When |
        |----------|---------------|----------------------|----------|
        | `Group` | ✅ Terraform creates | Full (replaces all) | Single Pulumi Stack manages everything |
        | `GroupPartialPermissions` | ✅ Terraform creates | Partial (adds/removes) | Multiple workspaces manage same Terraform-created group |
        | `ScimGroupPermissions` | ❌ External (SCIM) | Full (replaces all) | External group, single workspace manages all permissions |
        | `ScimGroupPartialPermissions` | ❌ External (SCIM) | Partial (adds/removes) | External group, multiple workspaces manage different permissions |

        ### Duplicate Permissions Across States

        **The Problem:** If multiple Terraform states define identical permissions, they will reference the same permission object in dbt Cloud's API. There is no reference counting or ownership tracking.

        **What Happens:**
        1. State A creates a permission (e.g., developer on project 100)
        2. State B defines the same permission and references the existing one
        3. State A destroys its resource → permission is deleted from dbt Cloud
        4. State B still expects the permission to exist → **drift and conflicts**

        **Example of Conflict (❌ Avoid):**

        ```python
        import pulumi
        import pulumi_dbtcloud as dbtcloud

        # Terraform State 1 (Platform Team)
        platform = dbtcloud.ScimGroupPartialPermissions("platform",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        # Terraform State 2 (Another Team) - IDENTICAL permission!
        other_team = dbtcloud.ScimGroupPartialPermissions("other_team",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        ```

        **Example of Safe Usage (✅ Recommended):**

        ```python
        import pulumi
        import pulumi_dbtcloud as dbtcloud

        # Terraform State 1 (Platform Team) - Development environments
        platform_dev = dbtcloud.ScimGroupPartialPermissions("platform_dev",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        # Terraform State 2 (SRE Team) - Production environments
        sre_prod = dbtcloud.ScimGroupPartialPermissions("sre_prod",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": [
                    "staging",
                    "production",
                ],
            }])
        ```

        **Coordination Strategies:**

        1. **Differentiate by writable environments** - Most common and recommended
        2. **Assign permission ownership** - Document which team manages which permission
        3. **Use single state for identical permissions** - If needed, manage from one place
        4. **Consider full permissions resource** - Use `ScimGroupPermissions` if one state should own all permissions

        ## Example Usage

        ```python
        import pulumi
        import pulumi_dbtcloud as dbtcloud

        # Retrieve the SCIM-managed group
        engineering = dbtcloud.get_groups(name="Engineering Team")
        # Get the project to apply permissions to
        my_project = dbtcloud.get_project(name="My Analytics Project")
        # Platform team can manage base account permissions
        base_access = dbtcloud.ScimGroupPartialPermissions("base_access",
            group_id=engineering.groups[0].id,
            permissions=[{
                "permission_set": "member",
                "all_projects": True,
            }])
        # Project team can manage project-specific permissions independently
        project_access = dbtcloud.ScimGroupPartialPermissions("project_access",
            group_id=engineering.groups[0].id,
            permissions=[
                {
                    "permission_set": "developer",
                    "project_id": my_project.id,
                    "all_projects": False,
                    "writable_environment_categories": [
                        "development",
                        "staging",
                    ],
                },
                {
                    "permission_set": "job_admin",
                    "project_id": my_project.id,
                    "all_projects": False,
                },
            ])
        # Example: Multiple projects managed by different teams
        analytics = dbtcloud.get_project(name="Analytics")
        data_science = dbtcloud.get_project(name="Data Science")
        # Analytics team manages their own project permissions
        analytics_scim_group_partial_permissions = dbtcloud.ScimGroupPartialPermissions("analytics",
            group_id=engineering.groups[0].id,
            permissions=[{
                "permission_set": "developer",
                "project_id": analytics.id,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        # Data Science team manages their own project permissions
        data_science_scim_group_partial_permissions = dbtcloud.ScimGroupPartialPermissions("data_science",
            group_id=engineering.groups[0].id,
            permissions=[{
                "permission_set": "analyst",
                "project_id": data_science.id,
                "all_projects": False,
            }])
        ```

        ## Import

        > **Import Not Supported:** This resource does not support `pulumi import` because it manages only a partial subset of permissions.
        There is no way for Terraform to know which specific permissions this resource instance should manage versus permissions
        managed by other resources or applied outside of Terraform. You must define the resource in your configuration from the start.


        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.int] group_id: The ID of the existing group to manage partial permissions for. This group must already exist and is typically from an external identity provider synced via SCIM.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ScimGroupPartialPermissionsPermissionArgs', 'ScimGroupPartialPermissionsPermissionArgsDict']]]] permissions: Partial set of permissions to apply to the group. These permissions will be added to any existing permissions. Other permissions on the group will not be affected.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ScimGroupPartialPermissionsArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Provide a partial set of permissions for an externally managed group (e.g., SCIM, manually created).
        This resource ONLY manages a subset of permissions and never creates or deletes groups.

        This is designed for federated permission management where a platform team sets global permissions
        and individual teams manage their own project-specific permissions for the same group.

        ⚠️  **Important Differences:**
        - `dbt_cloud_group`: Creates group and fully manages ALL permissions (single Pulumi Stack)
        - `dbt_cloud_group_partial_permissions`: Creates group and manages PARTIAL permissions (multiple Pulumi Stacks)
        - `dbt_cloud_scim_group_permissions`: Externally-managed group, fully manages ALL permissions (replaces all permissions)
        - `dbt_cloud_scim_group_partial_permissions`: Externally-managed group, manages PARTIAL permissions (adds/removes only specified permissions)

        **Use Case:**
        - Group exists in external identity provider (e.g., Okta, Azure AD) and syncs via SCIM
        - Platform team manages base permissions (e.g., account-level access)
        - Individual teams manage their own project-specific permissions
        - Multiple Pulumi Stacks can safely manage different permissions for the same group

        ⚠️  Do not mix different resource types for the same group:
        - Don't use `dbt_cloud_scim_group_permissions` (full permissions) with `dbt_cloud_scim_group_partial_permissions` (partial permissions)
        - Don't use `dbt_cloud_group` or `dbt_cloud_group_partial_permissions` for externally managed groups

        The resource currently requires a Service Token with Account Admin access.

        **Behavior:**
        - When creating: Adds specified permissions to the existing group (if not already present)
        - When updating: Adds new permissions and removes old permissions from this resource
        - When deleting: Removes only the permissions managed by this resource (group and other permissions remain)

        > This resource is designed for **federated permission management** where multiple teams manage different permissions for the same externally-managed group (e.g., SCIM groups).

        > **Warning: Duplicate Permissions Across States** - If multiple Terraform states define the **exact same permission** (identical `permission_set`, `project_id`, `all_projects`, and `writable_environment_categories`), they will reference the same underlying permission object in dbt Cloud. This creates a conflict: when one state deletes its resource, it removes the permission from dbt Cloud, causing drift in other states that reference the same permission. **Best Practice:** Ensure each Terraform state manages **distinct** permissions. Coordinate with other teams to avoid defining identical permissions, or differentiate them using `writable_environment_categories`.

        ## Use Case Guidelines

        Choose the right resource for your use case:

        | Resource | Group Creation | Permission Management | Use When |
        |----------|---------------|----------------------|----------|
        | `Group` | ✅ Terraform creates | Full (replaces all) | Single Pulumi Stack manages everything |
        | `GroupPartialPermissions` | ✅ Terraform creates | Partial (adds/removes) | Multiple workspaces manage same Terraform-created group |
        | `ScimGroupPermissions` | ❌ External (SCIM) | Full (replaces all) | External group, single workspace manages all permissions |
        | `ScimGroupPartialPermissions` | ❌ External (SCIM) | Partial (adds/removes) | External group, multiple workspaces manage different permissions |

        ### Duplicate Permissions Across States

        **The Problem:** If multiple Terraform states define identical permissions, they will reference the same permission object in dbt Cloud's API. There is no reference counting or ownership tracking.

        **What Happens:**
        1. State A creates a permission (e.g., developer on project 100)
        2. State B defines the same permission and references the existing one
        3. State A destroys its resource → permission is deleted from dbt Cloud
        4. State B still expects the permission to exist → **drift and conflicts**

        **Example of Conflict (❌ Avoid):**

        ```python
        import pulumi
        import pulumi_dbtcloud as dbtcloud

        # Terraform State 1 (Platform Team)
        platform = dbtcloud.ScimGroupPartialPermissions("platform",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        # Terraform State 2 (Another Team) - IDENTICAL permission!
        other_team = dbtcloud.ScimGroupPartialPermissions("other_team",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        ```

        **Example of Safe Usage (✅ Recommended):**

        ```python
        import pulumi
        import pulumi_dbtcloud as dbtcloud

        # Terraform State 1 (Platform Team) - Development environments
        platform_dev = dbtcloud.ScimGroupPartialPermissions("platform_dev",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        # Terraform State 2 (SRE Team) - Production environments
        sre_prod = dbtcloud.ScimGroupPartialPermissions("sre_prod",
            group_id=12345,
            permissions=[{
                "permission_set": "developer",
                "project_id": 100,
                "all_projects": False,
                "writable_environment_categories": [
                    "staging",
                    "production",
                ],
            }])
        ```

        **Coordination Strategies:**

        1. **Differentiate by writable environments** - Most common and recommended
        2. **Assign permission ownership** - Document which team manages which permission
        3. **Use single state for identical permissions** - If needed, manage from one place
        4. **Consider full permissions resource** - Use `ScimGroupPermissions` if one state should own all permissions

        ## Example Usage

        ```python
        import pulumi
        import pulumi_dbtcloud as dbtcloud

        # Retrieve the SCIM-managed group
        engineering = dbtcloud.get_groups(name="Engineering Team")
        # Get the project to apply permissions to
        my_project = dbtcloud.get_project(name="My Analytics Project")
        # Platform team can manage base account permissions
        base_access = dbtcloud.ScimGroupPartialPermissions("base_access",
            group_id=engineering.groups[0].id,
            permissions=[{
                "permission_set": "member",
                "all_projects": True,
            }])
        # Project team can manage project-specific permissions independently
        project_access = dbtcloud.ScimGroupPartialPermissions("project_access",
            group_id=engineering.groups[0].id,
            permissions=[
                {
                    "permission_set": "developer",
                    "project_id": my_project.id,
                    "all_projects": False,
                    "writable_environment_categories": [
                        "development",
                        "staging",
                    ],
                },
                {
                    "permission_set": "job_admin",
                    "project_id": my_project.id,
                    "all_projects": False,
                },
            ])
        # Example: Multiple projects managed by different teams
        analytics = dbtcloud.get_project(name="Analytics")
        data_science = dbtcloud.get_project(name="Data Science")
        # Analytics team manages their own project permissions
        analytics_scim_group_partial_permissions = dbtcloud.ScimGroupPartialPermissions("analytics",
            group_id=engineering.groups[0].id,
            permissions=[{
                "permission_set": "developer",
                "project_id": analytics.id,
                "all_projects": False,
                "writable_environment_categories": ["development"],
            }])
        # Data Science team manages their own project permissions
        data_science_scim_group_partial_permissions = dbtcloud.ScimGroupPartialPermissions("data_science",
            group_id=engineering.groups[0].id,
            permissions=[{
                "permission_set": "analyst",
                "project_id": data_science.id,
                "all_projects": False,
            }])
        ```

        ## Import

        > **Import Not Supported:** This resource does not support `pulumi import` because it manages only a partial subset of permissions.
        There is no way for Terraform to know which specific permissions this resource instance should manage versus permissions
        managed by other resources or applied outside of Terraform. You must define the resource in your configuration from the start.


        :param str resource_name: The name of the resource.
        :param ScimGroupPartialPermissionsArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ScimGroupPartialPermissionsArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ScimGroupPartialPermissionsPermissionArgs', 'ScimGroupPartialPermissionsPermissionArgsDict']]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ScimGroupPartialPermissionsArgs.__new__(ScimGroupPartialPermissionsArgs)

            if group_id is None and not opts.urn:
                raise TypeError("Missing required property 'group_id'")
            __props__.__dict__["group_id"] = group_id
            __props__.__dict__["permissions"] = permissions
        super(ScimGroupPartialPermissions, __self__).__init__(
            'dbtcloud:index/scimGroupPartialPermissions:ScimGroupPartialPermissions',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            group_id: Optional[pulumi.Input[_builtins.int]] = None,
            permissions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ScimGroupPartialPermissionsPermissionArgs', 'ScimGroupPartialPermissionsPermissionArgsDict']]]]] = None) -> 'ScimGroupPartialPermissions':
        """
        Get an existing ScimGroupPartialPermissions resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.int] group_id: The ID of the existing group to manage partial permissions for. This group must already exist and is typically from an external identity provider synced via SCIM.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ScimGroupPartialPermissionsPermissionArgs', 'ScimGroupPartialPermissionsPermissionArgsDict']]]] permissions: Partial set of permissions to apply to the group. These permissions will be added to any existing permissions. Other permissions on the group will not be affected.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ScimGroupPartialPermissionsState.__new__(_ScimGroupPartialPermissionsState)

        __props__.__dict__["group_id"] = group_id
        __props__.__dict__["permissions"] = permissions
        return ScimGroupPartialPermissions(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Output[_builtins.int]:
        """
        The ID of the existing group to manage partial permissions for. This group must already exist and is typically from an external identity provider synced via SCIM.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Output[Optional[Sequence['outputs.ScimGroupPartialPermissionsPermission']]]:
        """
        Partial set of permissions to apply to the group. These permissions will be added to any existing permissions. Other permissions on the group will not be affected.
        """
        return pulumi.get(self, "permissions")

