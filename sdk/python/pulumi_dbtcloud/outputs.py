# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GlobalConnectionApacheSpark',
    'GlobalConnectionAthena',
    'GlobalConnectionBigquery',
    'GlobalConnectionDatabricks',
    'GlobalConnectionFabric',
    'GlobalConnectionPostgres',
    'GlobalConnectionPostgresSshTunnel',
    'GlobalConnectionRedshift',
    'GlobalConnectionRedshiftSshTunnel',
    'GlobalConnectionSnowflake',
    'GlobalConnectionStarburst',
    'GlobalConnectionSynapse',
    'GroupGroupPermission',
    'GroupPartialPermissionsGroupPermission',
    'JobJobCompletionTriggerCondition',
    'ServiceTokenServiceTokenPermission',
    'GetEnvironmentsEnvironmentResult',
    'GetGlobalConnectionApacheSparkResult',
    'GetGlobalConnectionAthenaResult',
    'GetGlobalConnectionBigqueryResult',
    'GetGlobalConnectionDatabricksResult',
    'GetGlobalConnectionFabricResult',
    'GetGlobalConnectionPostgresResult',
    'GetGlobalConnectionPostgresSshTunnelResult',
    'GetGlobalConnectionRedshiftResult',
    'GetGlobalConnectionRedshiftSshTunnelResult',
    'GetGlobalConnectionSnowflakeResult',
    'GetGlobalConnectionStarburstResult',
    'GetGlobalConnectionSynapseResult',
    'GetGlobalConnectionsConnectionResult',
    'GetGroupGroupPermissionResult',
    'GetGroupUsersUserResult',
    'GetJobJobCompletionTriggerConditionResult',
    'GetJobsJobResult',
    'GetJobsJobEnvironmentResult',
    'GetJobsJobExecutionResult',
    'GetJobsJobJobCompletionTriggerConditionResult',
    'GetJobsJobJobCompletionTriggerConditionConditionResult',
    'GetJobsJobScheduleResult',
    'GetJobsJobSettingsResult',
    'GetJobsJobTriggersResult',
    'GetProjectsProjectResult',
    'GetProjectsProjectConnectionResult',
    'GetProjectsProjectRepositoryResult',
    'GetServiceTokenServiceTokenPermissionResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class GlobalConnectionApacheSpark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectRetries":
            suggest = "connect_retries"
        elif key == "connectTimeout":
            suggest = "connect_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionApacheSpark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionApacheSpark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionApacheSpark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: str,
                 host: str,
                 method: str,
                 auth: Optional[str] = None,
                 connect_retries: Optional[int] = None,
                 connect_timeout: Optional[int] = None,
                 organization: Optional[str] = None,
                 port: Optional[int] = None,
                 user: Optional[str] = None):
        """
        :param str cluster: Spark cluster for the connection
        :param str host: Hostname of the connection
        :param str method: Authentication method for the connection (http or thrift).
        :param str auth: Auth
        :param int connect_retries: Connection retries. Default=0
        :param int connect_timeout: Connection time out in seconds. Default=10
        :param str organization: Organization ID
        :param int port: Port for the connection. Default=443
        :param str user: User
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "method", method)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if connect_retries is not None:
            pulumi.set(__self__, "connect_retries", connect_retries)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cluster(self) -> str:
        """
        Spark cluster for the connection
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the connection
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Authentication method for the connection (http or thrift).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def auth(self) -> Optional[str]:
        """
        Auth
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="connectRetries")
    def connect_retries(self) -> Optional[int]:
        """
        Connection retries. Default=0
        """
        return pulumi.get(self, "connect_retries")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        Connection time out in seconds. Default=10
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter
    def organization(self) -> Optional[str]:
        """
        Organization ID
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for the connection. Default=443
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GlobalConnectionAthena(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"
        elif key == "s3StagingDir":
            suggest = "s3_staging_dir"
        elif key == "numBoto3Retries":
            suggest = "num_boto3_retries"
        elif key == "numIcebergRetries":
            suggest = "num_iceberg_retries"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "pollInterval":
            suggest = "poll_interval"
        elif key == "s3DataDir":
            suggest = "s3_data_dir"
        elif key == "s3DataNaming":
            suggest = "s3_data_naming"
        elif key == "s3TmpTableDir":
            suggest = "s3_tmp_table_dir"
        elif key == "sparkWorkGroup":
            suggest = "spark_work_group"
        elif key == "workGroup":
            suggest = "work_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionAthena. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionAthena.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionAthena.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 region_name: str,
                 s3_staging_dir: str,
                 num_boto3_retries: Optional[int] = None,
                 num_iceberg_retries: Optional[int] = None,
                 num_retries: Optional[int] = None,
                 poll_interval: Optional[int] = None,
                 s3_data_dir: Optional[str] = None,
                 s3_data_naming: Optional[str] = None,
                 s3_tmp_table_dir: Optional[str] = None,
                 spark_work_group: Optional[str] = None,
                 work_group: Optional[str] = None):
        """
        :param str database: Specify the database (data catalog) to build models into (lowercase only).
        :param str region_name: AWS region of your Athena instance.
        :param str s3_staging_dir: S3 location to store Athena query results and metadata.
        :param int num_boto3_retries: Number of times to retry boto3 requests (e.g. deleting S3 files for materialized tables).
        :param int num_iceberg_retries: Number of times to retry iceberg commit queries to fix ICEBERG*COMMIT*ERROR.
        :param int num_retries: Number of times to retry a failing query.
        :param int poll_interval: Interval in seconds to use for polling the status of query results in Athena.
        :param str s3_data_dir: Prefix for storing tables, if different from the connection's S3 staging directory.
        :param str s3_data_naming: How to generate table paths in the S3 data directory.
        :param str s3_tmp_table_dir: Prefix for storing temporary tables, if different from the connection's S3 data directory.
        :param str spark_work_group: Identifier of Athena Spark workgroup for running Python models.
        :param str work_group: Identifier of Athena workgroup.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "s3_staging_dir", s3_staging_dir)
        if num_boto3_retries is not None:
            pulumi.set(__self__, "num_boto3_retries", num_boto3_retries)
        if num_iceberg_retries is not None:
            pulumi.set(__self__, "num_iceberg_retries", num_iceberg_retries)
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if poll_interval is not None:
            pulumi.set(__self__, "poll_interval", poll_interval)
        if s3_data_dir is not None:
            pulumi.set(__self__, "s3_data_dir", s3_data_dir)
        if s3_data_naming is not None:
            pulumi.set(__self__, "s3_data_naming", s3_data_naming)
        if s3_tmp_table_dir is not None:
            pulumi.set(__self__, "s3_tmp_table_dir", s3_tmp_table_dir)
        if spark_work_group is not None:
            pulumi.set(__self__, "spark_work_group", spark_work_group)
        if work_group is not None:
            pulumi.set(__self__, "work_group", work_group)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Specify the database (data catalog) to build models into (lowercase only).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        AWS region of your Athena instance.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="s3StagingDir")
    def s3_staging_dir(self) -> str:
        """
        S3 location to store Athena query results and metadata.
        """
        return pulumi.get(self, "s3_staging_dir")

    @property
    @pulumi.getter(name="numBoto3Retries")
    def num_boto3_retries(self) -> Optional[int]:
        """
        Number of times to retry boto3 requests (e.g. deleting S3 files for materialized tables).
        """
        return pulumi.get(self, "num_boto3_retries")

    @property
    @pulumi.getter(name="numIcebergRetries")
    def num_iceberg_retries(self) -> Optional[int]:
        """
        Number of times to retry iceberg commit queries to fix ICEBERG*COMMIT*ERROR.
        """
        return pulumi.get(self, "num_iceberg_retries")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        """
        Number of times to retry a failing query.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[int]:
        """
        Interval in seconds to use for polling the status of query results in Athena.
        """
        return pulumi.get(self, "poll_interval")

    @property
    @pulumi.getter(name="s3DataDir")
    def s3_data_dir(self) -> Optional[str]:
        """
        Prefix for storing tables, if different from the connection's S3 staging directory.
        """
        return pulumi.get(self, "s3_data_dir")

    @property
    @pulumi.getter(name="s3DataNaming")
    def s3_data_naming(self) -> Optional[str]:
        """
        How to generate table paths in the S3 data directory.
        """
        return pulumi.get(self, "s3_data_naming")

    @property
    @pulumi.getter(name="s3TmpTableDir")
    def s3_tmp_table_dir(self) -> Optional[str]:
        """
        Prefix for storing temporary tables, if different from the connection's S3 data directory.
        """
        return pulumi.get(self, "s3_tmp_table_dir")

    @property
    @pulumi.getter(name="sparkWorkGroup")
    def spark_work_group(self) -> Optional[str]:
        """
        Identifier of Athena Spark workgroup for running Python models.
        """
        return pulumi.get(self, "spark_work_group")

    @property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> Optional[str]:
        """
        Identifier of Athena workgroup.
        """
        return pulumi.get(self, "work_group")


@pulumi.output_type
class GlobalConnectionBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "gcpProjectId":
            suggest = "gcp_project_id"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "tokenUri":
            suggest = "token_uri"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "applicationSecret":
            suggest = "application_secret"
        elif key == "dataprocClusterName":
            suggest = "dataproc_cluster_name"
        elif key == "dataprocRegion":
            suggest = "dataproc_region"
        elif key == "executionProject":
            suggest = "execution_project"
        elif key == "gcsBucket":
            suggest = "gcs_bucket"
        elif key == "impersonateServiceAccount":
            suggest = "impersonate_service_account"
        elif key == "jobCreationTimeoutSeconds":
            suggest = "job_creation_timeout_seconds"
        elif key == "jobRetryDeadlineSeconds":
            suggest = "job_retry_deadline_seconds"
        elif key == "maximumBytesBilled":
            suggest = "maximum_bytes_billed"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_provider_x509_cert_url: str,
                 auth_uri: str,
                 client_email: str,
                 client_id: str,
                 client_x509_cert_url: str,
                 gcp_project_id: str,
                 private_key: str,
                 private_key_id: str,
                 token_uri: str,
                 application_id: Optional[str] = None,
                 application_secret: Optional[str] = None,
                 dataproc_cluster_name: Optional[str] = None,
                 dataproc_region: Optional[str] = None,
                 execution_project: Optional[str] = None,
                 gcs_bucket: Optional[str] = None,
                 impersonate_service_account: Optional[str] = None,
                 job_creation_timeout_seconds: Optional[int] = None,
                 job_retry_deadline_seconds: Optional[int] = None,
                 location: Optional[str] = None,
                 maximum_bytes_billed: Optional[int] = None,
                 priority: Optional[str] = None,
                 retries: Optional[int] = None,
                 scopes: Optional[Sequence[str]] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param str auth_provider_x509_cert_url: Auth Provider X509 Cert URL for the Service Account
        :param str auth_uri: Auth URI for the Service Account
        :param str client_email: Service Account email
        :param str client_id: Client ID of the Service Account
        :param str client_x509_cert_url: Client X509 Cert URL for the Service Account
        :param str gcp_project_id: The GCP project ID to use for the connection
        :param str private_key: Private Key for the Service Account
        :param str private_key_id: Private Key ID for the Service Account
        :param str token_uri: Token URI for the Service Account
        :param str application_id: OAuth Client ID
        :param str application_secret: OAuth Client Secret
        :param str dataproc_cluster_name: Dataproc cluster name for PySpark workloads
        :param str dataproc_region: Google Cloud region for PySpark workloads on Dataproc
        :param str execution_project: Project to bill for query execution
        :param str gcs_bucket: URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        :param str impersonate_service_account: Service Account to impersonate when running queries
        :param int job_creation_timeout_seconds: Maximum timeout for the job creation step
        :param int job_retry_deadline_seconds: Total number of seconds to wait while retrying the same query
        :param str location: Location to create new Datasets in
        :param int maximum_bytes_billed: Max number of bytes that can be billed for a given BigQuery query
        :param str priority: The priority with which to execute BigQuery queries (batch or interactive)
        :param int retries: Number of retries for queries
        :param Sequence[str] scopes: OAuth scopes for the BigQuery connection
        :param int timeout_seconds: Timeout in seconds for queries
        """
        pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        pulumi.set(__self__, "auth_uri", auth_uri)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)
        pulumi.set(__self__, "token_uri", token_uri)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_secret is not None:
            pulumi.set(__self__, "application_secret", application_secret)
        if dataproc_cluster_name is not None:
            pulumi.set(__self__, "dataproc_cluster_name", dataproc_cluster_name)
        if dataproc_region is not None:
            pulumi.set(__self__, "dataproc_region", dataproc_region)
        if execution_project is not None:
            pulumi.set(__self__, "execution_project", execution_project)
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if impersonate_service_account is not None:
            pulumi.set(__self__, "impersonate_service_account", impersonate_service_account)
        if job_creation_timeout_seconds is not None:
            pulumi.set(__self__, "job_creation_timeout_seconds", job_creation_timeout_seconds)
        if job_retry_deadline_seconds is not None:
            pulumi.set(__self__, "job_retry_deadline_seconds", job_retry_deadline_seconds)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_bytes_billed is not None:
            pulumi.set(__self__, "maximum_bytes_billed", maximum_bytes_billed)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> str:
        """
        Auth Provider X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> str:
        """
        Auth URI for the Service Account
        """
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Service Account email
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of the Service Account
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> str:
        """
        Client X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The GCP project ID to use for the connection
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private Key for the Service Account
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> str:
        """
        Private Key ID for the Service Account
        """
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> str:
        """
        Token URI for the Service Account
        """
        return pulumi.get(self, "token_uri")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        OAuth Client ID
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationSecret")
    def application_secret(self) -> Optional[str]:
        """
        OAuth Client Secret
        """
        return pulumi.get(self, "application_secret")

    @property
    @pulumi.getter(name="dataprocClusterName")
    def dataproc_cluster_name(self) -> Optional[str]:
        """
        Dataproc cluster name for PySpark workloads
        """
        return pulumi.get(self, "dataproc_cluster_name")

    @property
    @pulumi.getter(name="dataprocRegion")
    def dataproc_region(self) -> Optional[str]:
        """
        Google Cloud region for PySpark workloads on Dataproc
        """
        return pulumi.get(self, "dataproc_region")

    @property
    @pulumi.getter(name="executionProject")
    def execution_project(self) -> Optional[str]:
        """
        Project to bill for query execution
        """
        return pulumi.get(self, "execution_project")

    @property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[str]:
        """
        URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        """
        return pulumi.get(self, "gcs_bucket")

    @property
    @pulumi.getter(name="impersonateServiceAccount")
    def impersonate_service_account(self) -> Optional[str]:
        """
        Service Account to impersonate when running queries
        """
        return pulumi.get(self, "impersonate_service_account")

    @property
    @pulumi.getter(name="jobCreationTimeoutSeconds")
    def job_creation_timeout_seconds(self) -> Optional[int]:
        """
        Maximum timeout for the job creation step
        """
        return pulumi.get(self, "job_creation_timeout_seconds")

    @property
    @pulumi.getter(name="jobRetryDeadlineSeconds")
    def job_retry_deadline_seconds(self) -> Optional[int]:
        """
        Total number of seconds to wait while retrying the same query
        """
        return pulumi.get(self, "job_retry_deadline_seconds")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location to create new Datasets in
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maximumBytesBilled")
    def maximum_bytes_billed(self) -> Optional[int]:
        """
        Max number of bytes that can be billed for a given BigQuery query
        """
        return pulumi.get(self, "maximum_bytes_billed")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        The priority with which to execute BigQuery queries (batch or interactive)
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        Number of retries for queries
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        OAuth scopes for the BigQuery connection
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Timeout in seconds for queries
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GlobalConnectionDatabricks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPath":
            suggest = "http_path"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionDatabricks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionDatabricks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionDatabricks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 http_path: str,
                 catalog: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str host: The hostname of the Databricks cluster or SQL warehouse.
        :param str http_path: The HTTP path of the Databricks cluster or SQL warehouse.
        :param str catalog: Catalog name if Unity Catalog is enabled in your Databricks workspace.
        :param str client_id: Required to enable Databricks OAuth authentication for IDE developers.
        :param str client_secret: Required to enable Databricks OAuth authentication for IDE developers.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http_path", http_path)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> str:
        """
        The HTTP path of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        """
        Catalog name if Unity Catalog is enabled in your Databricks workspace.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class GlobalConnectionFabric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginTimeout":
            suggest = "login_timeout"
        elif key == "queryTimeout":
            suggest = "query_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionFabric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionFabric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionFabric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 server: str,
                 login_timeout: Optional[int] = None,
                 port: Optional[int] = None,
                 query_timeout: Optional[int] = None,
                 retries: Optional[int] = None):
        """
        :param str database: The database to connect to for this connection.
        :param str server: The server hostname.
        :param int login_timeout: The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int port: The port to connect to for this connection. Default=1433
        :param int query_timeout: The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int retries: The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "server", server)
        if login_timeout is not None:
            pulumi.set(__self__, "login_timeout", login_timeout)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to connect to for this connection.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The server hostname.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="loginTimeout")
    def login_timeout(self) -> Optional[int]:
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "login_timeout")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to connect to for this connection. Default=1433
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[int]:
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class GlobalConnectionPostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshTunnel":
            suggest = "ssh_tunnel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionPostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionPostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionPostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: str,
                 hostname: str,
                 port: Optional[int] = None,
                 ssh_tunnel: Optional['outputs.GlobalConnectionPostgresSshTunnel'] = None):
        """
        :param str dbname: The database name for this connection.
        :param str hostname: The hostname of the database.
        :param int port: The port to connect to for this connection. Default=5432
        :param 'GlobalConnectionPostgresSshTunnelArgs' ssh_tunnel: PostgreSQL SSH Tunnel configuration
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_tunnel is not None:
            pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        """
        The database name for this connection.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of the database.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to connect to for this connection. Default=5432
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> Optional['outputs.GlobalConnectionPostgresSshTunnel']:
        """
        PostgreSQL SSH Tunnel configuration
        """
        return pulumi.get(self, "ssh_tunnel")


@pulumi.output_type
class GlobalConnectionPostgresSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionPostgresSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionPostgresSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionPostgresSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 port: int,
                 username: str,
                 id: Optional[int] = None,
                 public_key: Optional[str] = None):
        """
        :param str hostname: The hostname for the SSH tunnel.
        :param int port: The HTTP port for the SSH tunnel.
        :param str username: The username to use for the SSH tunnel.
        :param int id: The ID of the SSH tunnel connection.
        :param str public_key: The SSH public key generated to allow connecting via SSH tunnel.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The HTTP port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for the SSH tunnel.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the SSH tunnel connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GlobalConnectionRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshTunnel":
            suggest = "ssh_tunnel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: str,
                 hostname: str,
                 port: Optional[int] = None,
                 ssh_tunnel: Optional['outputs.GlobalConnectionRedshiftSshTunnel'] = None):
        """
        :param str dbname: The database name for this connection.
        :param str hostname: The hostname of the data warehouse.
        :param int port: The port to connect to for this connection. Default=5432
        :param 'GlobalConnectionRedshiftSshTunnelArgs' ssh_tunnel: Redshift SSH Tunnel configuration
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_tunnel is not None:
            pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        """
        The database name for this connection.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of the data warehouse.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to connect to for this connection. Default=5432
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> Optional['outputs.GlobalConnectionRedshiftSshTunnel']:
        """
        Redshift SSH Tunnel configuration
        """
        return pulumi.get(self, "ssh_tunnel")


@pulumi.output_type
class GlobalConnectionRedshiftSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionRedshiftSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionRedshiftSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionRedshiftSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 port: int,
                 username: str,
                 id: Optional[int] = None,
                 public_key: Optional[str] = None):
        """
        :param str hostname: The hostname for the SSH tunnel.
        :param int port: The HTTP port for the SSH tunnel.
        :param str username: The username to use for the SSH tunnel.
        :param int id: The ID of the SSH tunnel connection.
        :param str public_key: The SSH public key generated to allow connecting via SSH tunnel.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The HTTP port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for the SSH tunnel.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the SSH tunnel connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GlobalConnectionSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSso":
            suggest = "allow_sso"
        elif key == "clientSessionKeepAlive":
            suggest = "client_session_keep_alive"
        elif key == "oauthClientId":
            suggest = "oauth_client_id"
        elif key == "oauthClientSecret":
            suggest = "oauth_client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 database: str,
                 warehouse: str,
                 allow_sso: Optional[bool] = None,
                 client_session_keep_alive: Optional[bool] = None,
                 oauth_client_id: Optional[str] = None,
                 oauth_client_secret: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str account: The Snowflake account name
        :param str database: The default database for the connection
        :param str warehouse: The default Snowflake Warehouse to use for the connection
        :param bool allow_sso: Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        :param bool client_session_keep_alive: If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        :param str oauth_client_id: OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        :param str oauth_client_secret: OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        :param str role: The Snowflake role to use when running queries on the connection
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "warehouse", warehouse)
        if allow_sso is not None:
            pulumi.set(__self__, "allow_sso", allow_sso)
        if client_session_keep_alive is not None:
            pulumi.set(__self__, "client_session_keep_alive", client_session_keep_alive)
        if oauth_client_id is not None:
            pulumi.set(__self__, "oauth_client_id", oauth_client_id)
        if oauth_client_secret is not None:
            pulumi.set(__self__, "oauth_client_secret", oauth_client_secret)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The Snowflake account name
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The default database for the connection
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        The default Snowflake Warehouse to use for the connection
        """
        return pulumi.get(self, "warehouse")

    @property
    @pulumi.getter(name="allowSso")
    def allow_sso(self) -> Optional[bool]:
        """
        Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        """
        return pulumi.get(self, "allow_sso")

    @property
    @pulumi.getter(name="clientSessionKeepAlive")
    def client_session_keep_alive(self) -> Optional[bool]:
        """
        If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        """
        return pulumi.get(self, "client_session_keep_alive")

    @property
    @pulumi.getter(name="oauthClientId")
    def oauth_client_id(self) -> Optional[str]:
        """
        OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_id")

    @property
    @pulumi.getter(name="oauthClientSecret")
    def oauth_client_secret(self) -> Optional[str]:
        """
        OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_secret")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The Snowflake role to use when running queries on the connection
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GlobalConnectionStarburst(dict):
    def __init__(__self__, *,
                 host: str,
                 method: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str host: The hostname of the account to connect to.
        :param str method: The authentication method. Only LDAP for now.
        :param int port: The port to connect to for this connection. Default=443
        """
        pulumi.set(__self__, "host", host)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname of the account to connect to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The authentication method. Only LDAP for now.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to connect to for this connection. Default=443
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GlobalConnectionSynapse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginTimeout":
            suggest = "login_timeout"
        elif key == "queryTimeout":
            suggest = "query_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionSynapse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionSynapse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionSynapse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 login_timeout: Optional[int] = None,
                 port: Optional[int] = None,
                 query_timeout: Optional[int] = None,
                 retries: Optional[int] = None):
        """
        :param str database: The database to connect to for this connection.
        :param str host: The server hostname.
        :param int login_timeout: The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int port: The port to connect to for this connection. Default=1433
        :param int query_timeout: The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int retries: The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        if login_timeout is not None:
            pulumi.set(__self__, "login_timeout", login_timeout)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if query_timeout is not None:
            pulumi.set(__self__, "query_timeout", query_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to connect to for this connection.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The server hostname.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="loginTimeout")
    def login_timeout(self) -> Optional[int]:
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "login_timeout")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to connect to for this connection. Default=1433
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> Optional[int]:
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class GroupGroupPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allProjects":
            suggest = "all_projects"
        elif key == "permissionSet":
            suggest = "permission_set"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "writableEnvironmentCategories":
            suggest = "writable_environment_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupGroupPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupGroupPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupGroupPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: Optional[int] = None,
                 writable_environment_categories: Optional[Sequence[str]] = None):
        """
        :param bool all_projects: Whether access should be provided for all projects or not.
        :param str permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param int project_id: Project ID to apply this permission to for this group.
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[int]:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[Sequence[str]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GroupPartialPermissionsGroupPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allProjects":
            suggest = "all_projects"
        elif key == "permissionSet":
            suggest = "permission_set"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "writableEnvironmentCategories":
            suggest = "writable_environment_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPartialPermissionsGroupPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPartialPermissionsGroupPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPartialPermissionsGroupPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: Optional[int] = None,
                 writable_environment_categories: Optional[Sequence[str]] = None):
        """
        :param bool all_projects: Whether access should be provided for all projects or not.
        :param str permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param int project_id: Project ID to apply this permission to for this group.
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[int]:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[Sequence[str]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class JobJobCompletionTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobId":
            suggest = "job_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobCompletionTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobCompletionTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobCompletionTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_id: int,
                 project_id: int,
                 statuses: Sequence[str]):
        """
        :param int job_id: The ID of the job that would trigger this job after completion.
        :param int project_id: The ID of the project where the trigger job is running in.
        :param Sequence[str] statuses: List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.
        """
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        """
        The ID of the job that would trigger this job after completion.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The ID of the project where the trigger job is running in.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        """
        List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class ServiceTokenServiceTokenPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allProjects":
            suggest = "all_projects"
        elif key == "permissionSet":
            suggest = "permission_set"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "writableEnvironmentCategories":
            suggest = "writable_environment_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceTokenServiceTokenPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceTokenServiceTokenPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceTokenServiceTokenPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: Optional[int] = None,
                 writable_environment_categories: Optional[Sequence[str]] = None):
        """
        :param bool all_projects: Whether or not to apply this permission to all projects for this service token
        :param str permission_set: Set of permissions to apply
        :param int project_id: Project ID to apply this permission to for this service token
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether or not to apply this permission to all projects for this service token
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[int]:
        """
        Project ID to apply this permission to for this service token
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[Sequence[str]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GetEnvironmentsEnvironmentResult(dict):
    def __init__(__self__, *,
                 connection_id: int,
                 credentials_id: int,
                 custom_branch: str,
                 dbt_version: str,
                 deployment_type: str,
                 enable_model_query_history: bool,
                 environment_id: int,
                 extended_attributes_id: int,
                 name: str,
                 project_id: int,
                 type: str,
                 use_custom_branch: bool):
        """
        :param int connection_id: A connection ID (used with Global Connections)
        :param int credentials_id: Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments
        :param str custom_branch: The custom branch name to use
        :param str dbt_version: Version number of dbt to use in this environment.
        :param str deployment_type: The type of deployment environment (currently 'production', 'staging' or empty)
        :param bool enable_model_query_history: Whether model query history is on
        :param int environment_id: The ID of the environment
        :param int extended_attributes_id: The ID of the extended attributes applied
        :param str name: The name of the environment
        :param int project_id: The project ID to which the environment belong
        :param str type: The type of environment (must be either development or deployment)
        :param bool use_custom_branch: Whether to use a custom git branch in this environment
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "credentials_id", credentials_id)
        pulumi.set(__self__, "custom_branch", custom_branch)
        pulumi.set(__self__, "dbt_version", dbt_version)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "enable_model_query_history", enable_model_query_history)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "extended_attributes_id", extended_attributes_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "use_custom_branch", use_custom_branch)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> int:
        """
        A connection ID (used with Global Connections)
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="credentialsId")
    def credentials_id(self) -> int:
        """
        Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments
        """
        return pulumi.get(self, "credentials_id")

    @property
    @pulumi.getter(name="customBranch")
    def custom_branch(self) -> str:
        """
        The custom branch name to use
        """
        return pulumi.get(self, "custom_branch")

    @property
    @pulumi.getter(name="dbtVersion")
    def dbt_version(self) -> str:
        """
        Version number of dbt to use in this environment.
        """
        return pulumi.get(self, "dbt_version")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        The type of deployment environment (currently 'production', 'staging' or empty)
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="enableModelQueryHistory")
    def enable_model_query_history(self) -> bool:
        """
        Whether model query history is on
        """
        return pulumi.get(self, "enable_model_query_history")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> int:
        """
        The ID of the environment
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="extendedAttributesId")
    def extended_attributes_id(self) -> int:
        """
        The ID of the extended attributes applied
        """
        return pulumi.get(self, "extended_attributes_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the environment
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The project ID to which the environment belong
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of environment (must be either development or deployment)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useCustomBranch")
    def use_custom_branch(self) -> bool:
        """
        Whether to use a custom git branch in this environment
        """
        return pulumi.get(self, "use_custom_branch")


@pulumi.output_type
class GetGlobalConnectionApacheSparkResult(dict):
    def __init__(__self__, *,
                 auth: str,
                 cluster: str,
                 connect_retries: int,
                 connect_timeout: int,
                 host: str,
                 method: str,
                 organization: str,
                 port: int,
                 user: str):
        """
        :param str auth: Auth
        :param str cluster: Spark cluster for the connection
        :param int connect_retries: Connection retries. Default=0
        :param int connect_timeout: Connection time out in seconds. Default=10
        :param str host: Hostname of the connection
        :param str method: Authentication method for the connection (http or thrift).
        :param str organization: Organization ID
        :param int port: Port for the connection. Default=443
        :param str user: User
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "connect_retries", connect_retries)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def auth(self) -> str:
        """
        Auth
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def cluster(self) -> str:
        """
        Spark cluster for the connection
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="connectRetries")
    def connect_retries(self) -> int:
        """
        Connection retries. Default=0
        """
        return pulumi.get(self, "connect_retries")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> int:
        """
        Connection time out in seconds. Default=10
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the connection
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Authentication method for the connection (http or thrift).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        Organization ID
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for the connection. Default=443
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        User
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetGlobalConnectionAthenaResult(dict):
    def __init__(__self__, *,
                 database: str,
                 num_boto3_retries: int,
                 num_iceberg_retries: int,
                 num_retries: int,
                 poll_interval: int,
                 region_name: str,
                 s3_data_dir: str,
                 s3_data_naming: str,
                 s3_staging_dir: str,
                 s3_tmp_table_dir: str,
                 spark_work_group: str,
                 work_group: str):
        """
        :param str database: Specify the database (data catalog) to build models into (lowercase only).
        :param int num_boto3_retries: Number of times to retry boto3 requests (e.g. deleting S3 files for materialized tables).
        :param int num_iceberg_retries: Number of times to retry iceberg commit queries to fix ICEBERG*COMMIT*ERROR.
        :param int num_retries: Number of times to retry a failing query.
        :param int poll_interval: Interval in seconds to use for polling the status of query results in Athena.
        :param str region_name: AWS region of your Athena instance.
        :param str s3_data_dir: Prefix for storing tables, if different from the connection's S3 staging directory.
        :param str s3_data_naming: How to generate table paths in the S3 data directory.
        :param str s3_staging_dir: S3 location to store Athena query results and metadata.
        :param str s3_tmp_table_dir: Prefix for storing temporary tables, if different from the connection's S3 data directory.
        :param str spark_work_group: Identifier of Athena Spark workgroup for running Python models.
        :param str work_group: Identifier of Athena workgroup.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "num_boto3_retries", num_boto3_retries)
        pulumi.set(__self__, "num_iceberg_retries", num_iceberg_retries)
        pulumi.set(__self__, "num_retries", num_retries)
        pulumi.set(__self__, "poll_interval", poll_interval)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "s3_data_dir", s3_data_dir)
        pulumi.set(__self__, "s3_data_naming", s3_data_naming)
        pulumi.set(__self__, "s3_staging_dir", s3_staging_dir)
        pulumi.set(__self__, "s3_tmp_table_dir", s3_tmp_table_dir)
        pulumi.set(__self__, "spark_work_group", spark_work_group)
        pulumi.set(__self__, "work_group", work_group)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Specify the database (data catalog) to build models into (lowercase only).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="numBoto3Retries")
    def num_boto3_retries(self) -> int:
        """
        Number of times to retry boto3 requests (e.g. deleting S3 files for materialized tables).
        """
        return pulumi.get(self, "num_boto3_retries")

    @property
    @pulumi.getter(name="numIcebergRetries")
    def num_iceberg_retries(self) -> int:
        """
        Number of times to retry iceberg commit queries to fix ICEBERG*COMMIT*ERROR.
        """
        return pulumi.get(self, "num_iceberg_retries")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> int:
        """
        Number of times to retry a failing query.
        """
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> int:
        """
        Interval in seconds to use for polling the status of query results in Athena.
        """
        return pulumi.get(self, "poll_interval")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        AWS region of your Athena instance.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="s3DataDir")
    def s3_data_dir(self) -> str:
        """
        Prefix for storing tables, if different from the connection's S3 staging directory.
        """
        return pulumi.get(self, "s3_data_dir")

    @property
    @pulumi.getter(name="s3DataNaming")
    def s3_data_naming(self) -> str:
        """
        How to generate table paths in the S3 data directory.
        """
        return pulumi.get(self, "s3_data_naming")

    @property
    @pulumi.getter(name="s3StagingDir")
    def s3_staging_dir(self) -> str:
        """
        S3 location to store Athena query results and metadata.
        """
        return pulumi.get(self, "s3_staging_dir")

    @property
    @pulumi.getter(name="s3TmpTableDir")
    def s3_tmp_table_dir(self) -> str:
        """
        Prefix for storing temporary tables, if different from the connection's S3 data directory.
        """
        return pulumi.get(self, "s3_tmp_table_dir")

    @property
    @pulumi.getter(name="sparkWorkGroup")
    def spark_work_group(self) -> str:
        """
        Identifier of Athena Spark workgroup for running Python models.
        """
        return pulumi.get(self, "spark_work_group")

    @property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> str:
        """
        Identifier of Athena workgroup.
        """
        return pulumi.get(self, "work_group")


@pulumi.output_type
class GetGlobalConnectionBigqueryResult(dict):
    def __init__(__self__, *,
                 application_id: str,
                 application_secret: str,
                 auth_provider_x509_cert_url: str,
                 auth_uri: str,
                 client_email: str,
                 client_id: str,
                 client_x509_cert_url: str,
                 dataproc_cluster_name: str,
                 dataproc_region: str,
                 execution_project: str,
                 gcp_project_id: str,
                 gcs_bucket: str,
                 impersonate_service_account: str,
                 job_creation_timeout_seconds: int,
                 job_retry_deadline_seconds: int,
                 location: str,
                 maximum_bytes_billed: int,
                 priority: str,
                 private_key: str,
                 private_key_id: str,
                 retries: int,
                 scopes: Sequence[str],
                 timeout_seconds: int,
                 token_uri: str):
        """
        :param str application_id: OAuth Client ID
        :param str application_secret: OAuth Client Secret
        :param str auth_provider_x509_cert_url: Auth Provider X509 Cert URL for the Service Account
        :param str auth_uri: Auth URI for the Service Account
        :param str client_email: Service Account email
        :param str client_id: Client ID of the Service Account
        :param str client_x509_cert_url: Client X509 Cert URL for the Service Account
        :param str dataproc_cluster_name: Dataproc cluster name for PySpark workloads
        :param str dataproc_region: Google Cloud region for PySpark workloads on Dataproc
        :param str execution_project: Project to bill for query execution
        :param str gcp_project_id: The GCP project ID to use for the connection
        :param str gcs_bucket: URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        :param str impersonate_service_account: Service Account to impersonate when running queries
        :param int job_creation_timeout_seconds: Maximum timeout for the job creation step
        :param int job_retry_deadline_seconds: Total number of seconds to wait while retrying the same query
        :param str location: Location to create new Datasets in
        :param int maximum_bytes_billed: Max number of bytes that can be billed for a given BigQuery query
        :param str priority: The priority with which to execute BigQuery queries (batch or interactive)
        :param str private_key: Private Key for the Service Account
        :param str private_key_id: Private Key ID for the Service Account
        :param int retries: Number of retries for queries
        :param Sequence[str] scopes: OAuth scopes for the BigQuery connection
        :param int timeout_seconds: Timeout in seconds for queries
        :param str token_uri: Token URI for the Service Account
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "application_secret", application_secret)
        pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        pulumi.set(__self__, "auth_uri", auth_uri)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        pulumi.set(__self__, "dataproc_cluster_name", dataproc_cluster_name)
        pulumi.set(__self__, "dataproc_region", dataproc_region)
        pulumi.set(__self__, "execution_project", execution_project)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        pulumi.set(__self__, "impersonate_service_account", impersonate_service_account)
        pulumi.set(__self__, "job_creation_timeout_seconds", job_creation_timeout_seconds)
        pulumi.set(__self__, "job_retry_deadline_seconds", job_retry_deadline_seconds)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "maximum_bytes_billed", maximum_bytes_billed)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        OAuth Client ID
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationSecret")
    def application_secret(self) -> str:
        """
        OAuth Client Secret
        """
        return pulumi.get(self, "application_secret")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> str:
        """
        Auth Provider X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> str:
        """
        Auth URI for the Service Account
        """
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Service Account email
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of the Service Account
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> str:
        """
        Client X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="dataprocClusterName")
    def dataproc_cluster_name(self) -> str:
        """
        Dataproc cluster name for PySpark workloads
        """
        return pulumi.get(self, "dataproc_cluster_name")

    @property
    @pulumi.getter(name="dataprocRegion")
    def dataproc_region(self) -> str:
        """
        Google Cloud region for PySpark workloads on Dataproc
        """
        return pulumi.get(self, "dataproc_region")

    @property
    @pulumi.getter(name="executionProject")
    def execution_project(self) -> str:
        """
        Project to bill for query execution
        """
        return pulumi.get(self, "execution_project")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The GCP project ID to use for the connection
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> str:
        """
        URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        """
        return pulumi.get(self, "gcs_bucket")

    @property
    @pulumi.getter(name="impersonateServiceAccount")
    def impersonate_service_account(self) -> str:
        """
        Service Account to impersonate when running queries
        """
        return pulumi.get(self, "impersonate_service_account")

    @property
    @pulumi.getter(name="jobCreationTimeoutSeconds")
    def job_creation_timeout_seconds(self) -> int:
        """
        Maximum timeout for the job creation step
        """
        return pulumi.get(self, "job_creation_timeout_seconds")

    @property
    @pulumi.getter(name="jobRetryDeadlineSeconds")
    def job_retry_deadline_seconds(self) -> int:
        """
        Total number of seconds to wait while retrying the same query
        """
        return pulumi.get(self, "job_retry_deadline_seconds")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location to create new Datasets in
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maximumBytesBilled")
    def maximum_bytes_billed(self) -> int:
        """
        Max number of bytes that can be billed for a given BigQuery query
        """
        return pulumi.get(self, "maximum_bytes_billed")

    @property
    @pulumi.getter
    def priority(self) -> str:
        """
        The priority with which to execute BigQuery queries (batch or interactive)
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private Key for the Service Account
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> str:
        """
        Private Key ID for the Service Account
        """
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        Number of retries for queries
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        OAuth scopes for the BigQuery connection
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> int:
        """
        Timeout in seconds for queries
        """
        return pulumi.get(self, "timeout_seconds")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> str:
        """
        Token URI for the Service Account
        """
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class GetGlobalConnectionDatabricksResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 client_id: str,
                 client_secret: str,
                 host: str,
                 http_path: str):
        """
        :param str catalog: Catalog name if Unity Catalog is enabled in your Databricks workspace.
        :param str client_id: Required to enable Databricks OAuth authentication for IDE developers.
        :param str client_secret: Required to enable Databricks OAuth authentication for IDE developers.
        :param str host: The hostname of the Databricks cluster or SQL warehouse.
        :param str http_path: The HTTP path of the Databricks cluster or SQL warehouse.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http_path", http_path)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        Catalog name if Unity Catalog is enabled in your Databricks workspace.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> str:
        """
        The HTTP path of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "http_path")


@pulumi.output_type
class GetGlobalConnectionFabricResult(dict):
    def __init__(__self__, *,
                 database: str,
                 login_timeout: int,
                 port: int,
                 query_timeout: int,
                 retries: int,
                 server: str):
        """
        :param str database: The database to connect to for this connection.
        :param int login_timeout: The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int port: The port to connect to for this connection. Default=1433
        :param int query_timeout: The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int retries: The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        :param str server: The server hostname.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "login_timeout", login_timeout)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "query_timeout", query_timeout)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to connect to for this connection.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="loginTimeout")
    def login_timeout(self) -> int:
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "login_timeout")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to connect to for this connection. Default=1433
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> int:
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The server hostname.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetGlobalConnectionPostgresResult(dict):
    def __init__(__self__, *,
                 dbname: str,
                 hostname: str,
                 port: int,
                 ssh_tunnel: 'outputs.GetGlobalConnectionPostgresSshTunnelResult'):
        """
        :param str dbname: The database name for this connection.
        :param str hostname: The hostname of the database.
        :param int port: The port to connect to for this connection. Default=5432
        :param 'GetGlobalConnectionPostgresSshTunnelArgs' ssh_tunnel: PostgreSQL SSH Tunnel configuration
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        """
        The database name for this connection.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of the database.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to connect to for this connection. Default=5432
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> 'outputs.GetGlobalConnectionPostgresSshTunnelResult':
        """
        PostgreSQL SSH Tunnel configuration
        """
        return pulumi.get(self, "ssh_tunnel")


@pulumi.output_type
class GetGlobalConnectionPostgresSshTunnelResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 id: int,
                 port: int,
                 public_key: str,
                 username: str):
        """
        :param str hostname: The hostname for the SSH tunnel.
        :param int id: The ID of the SSH tunnel connection.
        :param int port: The HTTP port for the SSH tunnel.
        :param str public_key: The SSH public key generated to allow connecting via SSH tunnel.
        :param str username: The username to use for the SSH tunnel.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the SSH tunnel connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The HTTP port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for the SSH tunnel.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGlobalConnectionRedshiftResult(dict):
    def __init__(__self__, *,
                 dbname: str,
                 hostname: str,
                 port: int,
                 ssh_tunnel: 'outputs.GetGlobalConnectionRedshiftSshTunnelResult'):
        """
        :param str dbname: The database name for this connection.
        :param str hostname: The hostname of the data warehouse.
        :param int port: The port to connect to for this connection. Default=5432
        :param 'GetGlobalConnectionRedshiftSshTunnelArgs' ssh_tunnel: Redshift SSH Tunnel configuration
        """
        pulumi.set(__self__, "dbname", dbname)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        """
        The database name for this connection.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname of the data warehouse.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to connect to for this connection. Default=5432
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> 'outputs.GetGlobalConnectionRedshiftSshTunnelResult':
        """
        Redshift SSH Tunnel configuration
        """
        return pulumi.get(self, "ssh_tunnel")


@pulumi.output_type
class GetGlobalConnectionRedshiftSshTunnelResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 id: int,
                 port: int,
                 public_key: str,
                 username: str):
        """
        :param str hostname: The hostname for the SSH tunnel.
        :param int id: The ID of the SSH tunnel connection.
        :param int port: The HTTP port for the SSH tunnel.
        :param str public_key: The SSH public key generated to allow connecting via SSH tunnel.
        :param str username: The username to use for the SSH tunnel.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the SSH tunnel connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The HTTP port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        The SSH public key generated to allow connecting via SSH tunnel.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for the SSH tunnel.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGlobalConnectionSnowflakeResult(dict):
    def __init__(__self__, *,
                 account: str,
                 allow_sso: bool,
                 client_session_keep_alive: bool,
                 database: str,
                 oauth_client_id: str,
                 oauth_client_secret: str,
                 role: str,
                 warehouse: str):
        """
        :param str account: The Snowflake account name
        :param bool allow_sso: Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        :param bool client_session_keep_alive: If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        :param str database: The default database for the connection
        :param str oauth_client_id: OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        :param str oauth_client_secret: OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        :param str role: The Snowflake role to use when running queries on the connection
        :param str warehouse: The default Snowflake Warehouse to use for the connection
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "allow_sso", allow_sso)
        pulumi.set(__self__, "client_session_keep_alive", client_session_keep_alive)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "oauth_client_id", oauth_client_id)
        pulumi.set(__self__, "oauth_client_secret", oauth_client_secret)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "warehouse", warehouse)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The Snowflake account name
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="allowSso")
    def allow_sso(self) -> bool:
        """
        Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        """
        return pulumi.get(self, "allow_sso")

    @property
    @pulumi.getter(name="clientSessionKeepAlive")
    def client_session_keep_alive(self) -> bool:
        """
        If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        """
        return pulumi.get(self, "client_session_keep_alive")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The default database for the connection
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="oauthClientId")
    def oauth_client_id(self) -> str:
        """
        OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_id")

    @property
    @pulumi.getter(name="oauthClientSecret")
    def oauth_client_secret(self) -> str:
        """
        OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_secret")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The Snowflake role to use when running queries on the connection
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        The default Snowflake Warehouse to use for the connection
        """
        return pulumi.get(self, "warehouse")


@pulumi.output_type
class GetGlobalConnectionStarburstResult(dict):
    def __init__(__self__, *,
                 host: str,
                 method: str,
                 port: int):
        """
        :param str host: The hostname of the account to connect to.
        :param str method: The authentication method. Only LDAP for now.
        :param int port: The port to connect to for this connection. Default=443
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname of the account to connect to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The authentication method. Only LDAP for now.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to connect to for this connection. Default=443
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetGlobalConnectionSynapseResult(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 login_timeout: int,
                 port: int,
                 query_timeout: int,
                 retries: int):
        """
        :param str database: The database to connect to for this connection.
        :param str host: The server hostname.
        :param int login_timeout: The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int port: The port to connect to for this connection. Default=1433
        :param int query_timeout: The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        :param int retries: The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "login_timeout", login_timeout)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "query_timeout", query_timeout)
        pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to connect to for this connection.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The server hostname.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="loginTimeout")
    def login_timeout(self) -> int:
        """
        The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "login_timeout")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to connect to for this connection. Default=1433
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> int:
        """
        The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class GetGlobalConnectionsConnectionResult(dict):
    def __init__(__self__, *,
                 adapter_version: str,
                 created_at: str,
                 environment_count: int,
                 id: int,
                 is_ssh_tunnel_enabled: bool,
                 name: str,
                 oauth_configuration_id: int,
                 private_link_endpoint_id: str,
                 updated_at: str):
        """
        :param str adapter_version: Type of adapter used for the connection
        :param str created_at: When the connection was created
        :param int environment_count: Number of environments using this connection
        :param int id: Connection Identifier
        :param str name: Connection name
        :param str private_link_endpoint_id: Private Link Endpoint ID.
        :param str updated_at: When the connection was updated
        """
        pulumi.set(__self__, "adapter_version", adapter_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "environment_count", environment_count)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_ssh_tunnel_enabled", is_ssh_tunnel_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oauth_configuration_id", oauth_configuration_id)
        pulumi.set(__self__, "private_link_endpoint_id", private_link_endpoint_id)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="adapterVersion")
    def adapter_version(self) -> str:
        """
        Type of adapter used for the connection
        """
        return pulumi.get(self, "adapter_version")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        When the connection was created
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="environmentCount")
    def environment_count(self) -> int:
        """
        Number of environments using this connection
        """
        return pulumi.get(self, "environment_count")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Connection Identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSshTunnelEnabled")
    def is_ssh_tunnel_enabled(self) -> bool:
        return pulumi.get(self, "is_ssh_tunnel_enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Connection name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="oauthConfigurationId")
    def oauth_configuration_id(self) -> int:
        return pulumi.get(self, "oauth_configuration_id")

    @property
    @pulumi.getter(name="privateLinkEndpointId")
    def private_link_endpoint_id(self) -> str:
        """
        Private Link Endpoint ID.
        """
        return pulumi.get(self, "private_link_endpoint_id")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        When the connection was updated
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetGroupGroupPermissionResult(dict):
    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: int,
                 writable_environment_categories: Sequence[str]):
        """
        :param bool all_projects: Whether access should be provided for all projects or not.
        :param str permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param int project_id: Project ID to apply this permission to for this group.
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Sequence[str]:
        """
        What types of environments to apply Write permissions to.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GetGroupUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: int):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobCompletionTriggerConditionResult(dict):
    def __init__(__self__, *,
                 job_id: int,
                 project_id: int,
                 statuses: Sequence[str]):
        """
        :param int job_id: The ID of the job that would trigger this job after completion.
        :param int project_id: The ID of the project where the trigger job is running in.
        :param Sequence[str] statuses: List of statuses to trigger the job on.
        """
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        """
        The ID of the job that would trigger this job after completion.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The ID of the project where the trigger job is running in.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        """
        List of statuses to trigger the job on.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class GetJobsJobResult(dict):
    def __init__(__self__, *,
                 dbt_version: str,
                 deferring_environment_id: int,
                 deferring_job_definition_id: int,
                 description: str,
                 environment: 'outputs.GetJobsJobEnvironmentResult',
                 environment_id: int,
                 execute_steps: Sequence[str],
                 execution: 'outputs.GetJobsJobExecutionResult',
                 generate_docs: bool,
                 id: int,
                 job_completion_trigger_condition: 'outputs.GetJobsJobJobCompletionTriggerConditionResult',
                 job_type: str,
                 name: str,
                 project_id: int,
                 run_compare_changes: bool,
                 run_generate_sources: bool,
                 schedule: 'outputs.GetJobsJobScheduleResult',
                 settings: 'outputs.GetJobsJobSettingsResult',
                 triggers: 'outputs.GetJobsJobTriggersResult',
                 triggers_on_draft_pr: bool):
        """
        :param str dbt_version: The version of dbt used for the job. If not set, the environment version will be used.
        :param int deferring_environment_id: The ID of the environment this job defers to
        :param int deferring_job_definition_id: [Deprecated - deferral is now set at the environment level] The ID of the job definition this job defers to
        :param str description: The description of the job
        :param 'GetJobsJobEnvironmentArgs' environment: Details of the environment the job is running in
        :param int environment_id: The ID of environment
        :param Sequence[str] execute_steps: The list of steps to run in the job
        :param bool generate_docs: Whether the job generate docs
        :param int id: The ID of the job
        :param 'GetJobsJobJobCompletionTriggerConditionArgs' job_completion_trigger_condition: Whether the job is triggered by the completion of another job
        :param str job_type: The type of job (e.g. CI, scheduled)
        :param str name: The name of the job
        :param int project_id: The ID of the project
        :param bool run_compare_changes: Whether the job should compare data changes introduced by the code change in the PR
        :param bool run_generate_sources: Whether the job test source freshness
        :param bool triggers_on_draft_pr: Whether the CI job should be automatically triggered on draft PRs
        """
        pulumi.set(__self__, "dbt_version", dbt_version)
        pulumi.set(__self__, "deferring_environment_id", deferring_environment_id)
        pulumi.set(__self__, "deferring_job_definition_id", deferring_job_definition_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "execute_steps", execute_steps)
        pulumi.set(__self__, "execution", execution)
        pulumi.set(__self__, "generate_docs", generate_docs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_completion_trigger_condition", job_completion_trigger_condition)
        pulumi.set(__self__, "job_type", job_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "run_compare_changes", run_compare_changes)
        pulumi.set(__self__, "run_generate_sources", run_generate_sources)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "triggers", triggers)
        pulumi.set(__self__, "triggers_on_draft_pr", triggers_on_draft_pr)

    @property
    @pulumi.getter(name="dbtVersion")
    def dbt_version(self) -> str:
        """
        The version of dbt used for the job. If not set, the environment version will be used.
        """
        return pulumi.get(self, "dbt_version")

    @property
    @pulumi.getter(name="deferringEnvironmentId")
    def deferring_environment_id(self) -> int:
        """
        The ID of the environment this job defers to
        """
        return pulumi.get(self, "deferring_environment_id")

    @property
    @pulumi.getter(name="deferringJobDefinitionId")
    def deferring_job_definition_id(self) -> int:
        """
        [Deprecated - deferral is now set at the environment level] The ID of the job definition this job defers to
        """
        return pulumi.get(self, "deferring_job_definition_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the job
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def environment(self) -> 'outputs.GetJobsJobEnvironmentResult':
        """
        Details of the environment the job is running in
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> int:
        """
        The ID of environment
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="executeSteps")
    def execute_steps(self) -> Sequence[str]:
        """
        The list of steps to run in the job
        """
        return pulumi.get(self, "execute_steps")

    @property
    @pulumi.getter
    def execution(self) -> 'outputs.GetJobsJobExecutionResult':
        return pulumi.get(self, "execution")

    @property
    @pulumi.getter(name="generateDocs")
    def generate_docs(self) -> bool:
        """
        Whether the job generate docs
        """
        return pulumi.get(self, "generate_docs")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the job
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="jobCompletionTriggerCondition")
    def job_completion_trigger_condition(self) -> 'outputs.GetJobsJobJobCompletionTriggerConditionResult':
        """
        Whether the job is triggered by the completion of another job
        """
        return pulumi.get(self, "job_completion_trigger_condition")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        The type of job (e.g. CI, scheduled)
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the job
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The ID of the project
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="runCompareChanges")
    def run_compare_changes(self) -> bool:
        """
        Whether the job should compare data changes introduced by the code change in the PR
        """
        return pulumi.get(self, "run_compare_changes")

    @property
    @pulumi.getter(name="runGenerateSources")
    def run_generate_sources(self) -> bool:
        """
        Whether the job test source freshness
        """
        return pulumi.get(self, "run_generate_sources")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.GetJobsJobScheduleResult':
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetJobsJobSettingsResult':
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def triggers(self) -> 'outputs.GetJobsJobTriggersResult':
        return pulumi.get(self, "triggers")

    @property
    @pulumi.getter(name="triggersOnDraftPr")
    def triggers_on_draft_pr(self) -> bool:
        """
        Whether the CI job should be automatically triggered on draft PRs
        """
        return pulumi.get(self, "triggers_on_draft_pr")


@pulumi.output_type
class GetJobsJobEnvironmentResult(dict):
    def __init__(__self__, *,
                 deployment_type: str,
                 id: int,
                 name: str,
                 project_id: int,
                 type: str):
        """
        :param str deployment_type: Type of deployment environment: staging, production
        :param int id: ID of the environment
        :param str name: Name of the environment
        :param str type: Environment type: development or deployment
        """
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        Type of deployment environment: staging, production
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID of the environment
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Environment type: development or deployment
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetJobsJobExecutionResult(dict):
    def __init__(__self__, *,
                 timeout_seconds: int):
        """
        :param int timeout_seconds: The number of seconds before the job times out
        """
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> int:
        """
        The number of seconds before the job times out
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetJobsJobJobCompletionTriggerConditionResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetJobsJobJobCompletionTriggerConditionConditionResult'):
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetJobsJobJobCompletionTriggerConditionConditionResult':
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetJobsJobJobCompletionTriggerConditionConditionResult(dict):
    def __init__(__self__, *,
                 job_id: int,
                 project_id: int,
                 statuses: Sequence[str]):
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        return pulumi.get(self, "statuses")


@pulumi.output_type
class GetJobsJobScheduleResult(dict):
    def __init__(__self__, *,
                 cron: str):
        """
        :param str cron: The cron schedule for the job. Only used if triggers.schedule is true
        """
        pulumi.set(__self__, "cron", cron)

    @property
    @pulumi.getter
    def cron(self) -> str:
        """
        The cron schedule for the job. Only used if triggers.schedule is true
        """
        return pulumi.get(self, "cron")


@pulumi.output_type
class GetJobsJobSettingsResult(dict):
    def __init__(__self__, *,
                 target_name: str,
                 threads: int):
        """
        :param str target_name: Value for `target.name` in the Jinja context
        :param int threads: Number of threads to run dbt with
        """
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "threads", threads)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> str:
        """
        Value for `target.name` in the Jinja context
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter
    def threads(self) -> int:
        """
        Number of threads to run dbt with
        """
        return pulumi.get(self, "threads")


@pulumi.output_type
class GetJobsJobTriggersResult(dict):
    def __init__(__self__, *,
                 git_provider_webhook: bool,
                 github_webhook: bool,
                 on_merge: bool,
                 schedule: bool):
        """
        :param bool git_provider_webhook: Whether the job runs automatically on PR creation
        :param bool github_webhook: Whether the job runs automatically on PR creation
        :param bool on_merge: Whether the job runs automatically once a PR is merged
        :param bool schedule: Whether the job runs on a schedule
        """
        pulumi.set(__self__, "git_provider_webhook", git_provider_webhook)
        pulumi.set(__self__, "github_webhook", github_webhook)
        pulumi.set(__self__, "on_merge", on_merge)
        pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="gitProviderWebhook")
    def git_provider_webhook(self) -> bool:
        """
        Whether the job runs automatically on PR creation
        """
        return pulumi.get(self, "git_provider_webhook")

    @property
    @pulumi.getter(name="githubWebhook")
    def github_webhook(self) -> bool:
        """
        Whether the job runs automatically on PR creation
        """
        return pulumi.get(self, "github_webhook")

    @property
    @pulumi.getter(name="onMerge")
    def on_merge(self) -> bool:
        """
        Whether the job runs automatically once a PR is merged
        """
        return pulumi.get(self, "on_merge")

    @property
    @pulumi.getter
    def schedule(self) -> bool:
        """
        Whether the job runs on a schedule
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class GetProjectsProjectResult(dict):
    def __init__(__self__, *,
                 connection: 'outputs.GetProjectsProjectConnectionResult',
                 created_at: str,
                 dbt_project_subdirectory: str,
                 description: str,
                 id: int,
                 name: str,
                 repository: 'outputs.GetProjectsProjectRepositoryResult',
                 semantic_layer_config_id: int,
                 updated_at: str):
        """
        :param 'GetProjectsProjectConnectionArgs' connection: Details for the connection linked to the project
        :param str created_at: When the project was created
        :param str dbt_project_subdirectory: Subdirectory for the dbt project inside the git repo
        :param str description: Project description
        :param int id: Project ID
        :param str name: Project name
        :param 'GetProjectsProjectRepositoryArgs' repository: Details for the repository linked to the project
        :param int semantic_layer_config_id: Semantic layer config ID
        :param str updated_at: When the project was last updated
        """
        pulumi.set(__self__, "connection", connection)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "dbt_project_subdirectory", dbt_project_subdirectory)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "semantic_layer_config_id", semantic_layer_config_id)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def connection(self) -> 'outputs.GetProjectsProjectConnectionResult':
        """
        Details for the connection linked to the project
        """
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        When the project was created
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="dbtProjectSubdirectory")
    def dbt_project_subdirectory(self) -> str:
        """
        Subdirectory for the dbt project inside the git repo
        """
        return pulumi.get(self, "dbt_project_subdirectory")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Project description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Project ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Project name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def repository(self) -> 'outputs.GetProjectsProjectRepositoryResult':
        """
        Details for the repository linked to the project
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="semanticLayerConfigId")
    def semantic_layer_config_id(self) -> int:
        """
        Semantic layer config ID
        """
        return pulumi.get(self, "semantic_layer_config_id")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        When the project was last updated
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetProjectsProjectConnectionResult(dict):
    def __init__(__self__, *,
                 adapter_version: str,
                 id: int,
                 name: str):
        """
        :param str adapter_version: Version of the adapter for the connection. Will tell what connection type it is
        :param int id: Connection ID
        :param str name: Connection name
        """
        pulumi.set(__self__, "adapter_version", adapter_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="adapterVersion")
    def adapter_version(self) -> str:
        """
        Version of the adapter for the connection. Will tell what connection type it is
        """
        return pulumi.get(self, "adapter_version")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Connection ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Connection name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProjectsProjectRepositoryResult(dict):
    def __init__(__self__, *,
                 id: int,
                 pull_request_url_template: str,
                 remote_url: str):
        """
        :param int id: Repository ID
        :param str pull_request_url_template: URL template for PRs
        :param str remote_url: URL of the git repo remote
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "pull_request_url_template", pull_request_url_template)
        pulumi.set(__self__, "remote_url", remote_url)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Repository ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="pullRequestUrlTemplate")
    def pull_request_url_template(self) -> str:
        """
        URL template for PRs
        """
        return pulumi.get(self, "pull_request_url_template")

    @property
    @pulumi.getter(name="remoteUrl")
    def remote_url(self) -> str:
        """
        URL of the git repo remote
        """
        return pulumi.get(self, "remote_url")


@pulumi.output_type
class GetServiceTokenServiceTokenPermissionResult(dict):
    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: int,
                 writable_environment_categories: Sequence[str]):
        """
        :param bool all_projects: Whether or not to apply this permission to all projects for this service token
        :param str permission_set: Set of permissions to apply
        :param int project_id: Project ID to apply this permission to for this service token
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether or not to apply this permission to all projects for this service token
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        Project ID to apply this permission to for this service token
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Sequence[str]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: int):
        """
        :param str email: Email for the user
        :param int id: ID of the user
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        Email for the user
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID of the user
        """
        return pulumi.get(self, "id")


