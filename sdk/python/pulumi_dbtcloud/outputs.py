# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'GlobalConnectionBigquery',
    'GlobalConnectionDatabricks',
    'GlobalConnectionSnowflake',
    'GroupGroupPermission',
    'GroupPartialPermissionsGroupPermission',
    'JobJobCompletionTriggerCondition',
    'ServiceTokenServiceTokenPermission',
    'GetEnvironmentsEnvironmentResult',
    'GetGroupGroupPermissionResult',
    'GetGroupUsersUserResult',
    'GetJobJobCompletionTriggerConditionResult',
    'GetJobsJobResult',
    'GetJobsJobEnvironmentResult',
    'GetJobsJobExecutionResult',
    'GetJobsJobJobCompletionTriggerConditionResult',
    'GetJobsJobJobCompletionTriggerConditionConditionResult',
    'GetJobsJobScheduleResult',
    'GetJobsJobSettingsResult',
    'GetJobsJobTriggersResult',
    'GetServiceTokenServiceTokenPermissionResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class GlobalConnectionBigquery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "gcpProjectId":
            suggest = "gcp_project_id"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "tokenUri":
            suggest = "token_uri"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "applicationSecret":
            suggest = "application_secret"
        elif key == "dataprocClusterName":
            suggest = "dataproc_cluster_name"
        elif key == "dataprocRegion":
            suggest = "dataproc_region"
        elif key == "executionProject":
            suggest = "execution_project"
        elif key == "gcsBucket":
            suggest = "gcs_bucket"
        elif key == "impersonateServiceAccount":
            suggest = "impersonate_service_account"
        elif key == "jobCreationTimeoutSeconds":
            suggest = "job_creation_timeout_seconds"
        elif key == "jobRetryDeadlineSeconds":
            suggest = "job_retry_deadline_seconds"
        elif key == "maximumBytesBilled":
            suggest = "maximum_bytes_billed"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionBigquery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionBigquery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionBigquery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_provider_x509_cert_url: str,
                 auth_uri: str,
                 client_email: str,
                 client_id: str,
                 client_x509_cert_url: str,
                 gcp_project_id: str,
                 private_key: str,
                 private_key_id: str,
                 token_uri: str,
                 application_id: Optional[str] = None,
                 application_secret: Optional[str] = None,
                 dataproc_cluster_name: Optional[str] = None,
                 dataproc_region: Optional[str] = None,
                 execution_project: Optional[str] = None,
                 gcs_bucket: Optional[str] = None,
                 impersonate_service_account: Optional[str] = None,
                 job_creation_timeout_seconds: Optional[int] = None,
                 job_retry_deadline_seconds: Optional[int] = None,
                 location: Optional[str] = None,
                 maximum_bytes_billed: Optional[int] = None,
                 priority: Optional[str] = None,
                 retries: Optional[int] = None,
                 scopes: Optional[Sequence[str]] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param str auth_provider_x509_cert_url: Auth Provider X509 Cert URL for the Service Account
        :param str auth_uri: Auth URI for the Service Account
        :param str client_email: Service Account email
        :param str client_id: Client ID of the Service Account
        :param str client_x509_cert_url: Client X509 Cert URL for the Service Account
        :param str gcp_project_id: The GCP project ID to use for the connection
        :param str private_key: Private Key for the Service Account
        :param str private_key_id: Private Key ID for the Service Account
        :param str token_uri: Token URI for the Service Account
        :param str application_id: OAuth Client ID
        :param str application_secret: OAuth Client Secret
        :param str dataproc_cluster_name: Dataproc cluster name for PySpark workloads
        :param str dataproc_region: Google Cloud region for PySpark workloads on Dataproc
        :param str execution_project: Project to bill for query execution
        :param str gcs_bucket: URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        :param str impersonate_service_account: Service Account to impersonate when running queries
        :param int job_creation_timeout_seconds: Maximum timeout for the job creation step
        :param int job_retry_deadline_seconds: Total number of seconds to wait while retrying the same query
        :param str location: Location to create new Datasets in
        :param int maximum_bytes_billed: Max number of bytes that can be billed for a given BigQuery query
        :param str priority: The priority with which to execute BigQuery queries (batch or interactive)
        :param int retries: Number of retries for queries
        :param Sequence[str] scopes: OAuth scopes for the BigQuery connection
        :param int timeout_seconds: Timeout in seconds for queries
        """
        pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        pulumi.set(__self__, "auth_uri", auth_uri)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)
        pulumi.set(__self__, "token_uri", token_uri)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_secret is not None:
            pulumi.set(__self__, "application_secret", application_secret)
        if dataproc_cluster_name is not None:
            pulumi.set(__self__, "dataproc_cluster_name", dataproc_cluster_name)
        if dataproc_region is not None:
            pulumi.set(__self__, "dataproc_region", dataproc_region)
        if execution_project is not None:
            pulumi.set(__self__, "execution_project", execution_project)
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if impersonate_service_account is not None:
            pulumi.set(__self__, "impersonate_service_account", impersonate_service_account)
        if job_creation_timeout_seconds is not None:
            pulumi.set(__self__, "job_creation_timeout_seconds", job_creation_timeout_seconds)
        if job_retry_deadline_seconds is not None:
            pulumi.set(__self__, "job_retry_deadline_seconds", job_retry_deadline_seconds)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_bytes_billed is not None:
            pulumi.set(__self__, "maximum_bytes_billed", maximum_bytes_billed)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> str:
        """
        Auth Provider X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> str:
        """
        Auth URI for the Service Account
        """
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Service Account email
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of the Service Account
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> str:
        """
        Client X509 Cert URL for the Service Account
        """
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The GCP project ID to use for the connection
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private Key for the Service Account
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> str:
        """
        Private Key ID for the Service Account
        """
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> str:
        """
        Token URI for the Service Account
        """
        return pulumi.get(self, "token_uri")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        OAuth Client ID
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationSecret")
    def application_secret(self) -> Optional[str]:
        """
        OAuth Client Secret
        """
        return pulumi.get(self, "application_secret")

    @property
    @pulumi.getter(name="dataprocClusterName")
    def dataproc_cluster_name(self) -> Optional[str]:
        """
        Dataproc cluster name for PySpark workloads
        """
        return pulumi.get(self, "dataproc_cluster_name")

    @property
    @pulumi.getter(name="dataprocRegion")
    def dataproc_region(self) -> Optional[str]:
        """
        Google Cloud region for PySpark workloads on Dataproc
        """
        return pulumi.get(self, "dataproc_region")

    @property
    @pulumi.getter(name="executionProject")
    def execution_project(self) -> Optional[str]:
        """
        Project to bill for query execution
        """
        return pulumi.get(self, "execution_project")

    @property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[str]:
        """
        URI for a Google Cloud Storage bucket to host Python code executed via Datapro
        """
        return pulumi.get(self, "gcs_bucket")

    @property
    @pulumi.getter(name="impersonateServiceAccount")
    def impersonate_service_account(self) -> Optional[str]:
        """
        Service Account to impersonate when running queries
        """
        return pulumi.get(self, "impersonate_service_account")

    @property
    @pulumi.getter(name="jobCreationTimeoutSeconds")
    def job_creation_timeout_seconds(self) -> Optional[int]:
        """
        Maximum timeout for the job creation step
        """
        return pulumi.get(self, "job_creation_timeout_seconds")

    @property
    @pulumi.getter(name="jobRetryDeadlineSeconds")
    def job_retry_deadline_seconds(self) -> Optional[int]:
        """
        Total number of seconds to wait while retrying the same query
        """
        return pulumi.get(self, "job_retry_deadline_seconds")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location to create new Datasets in
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maximumBytesBilled")
    def maximum_bytes_billed(self) -> Optional[int]:
        """
        Max number of bytes that can be billed for a given BigQuery query
        """
        return pulumi.get(self, "maximum_bytes_billed")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        The priority with which to execute BigQuery queries (batch or interactive)
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        Number of retries for queries
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        OAuth scopes for the BigQuery connection
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Timeout in seconds for queries
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GlobalConnectionDatabricks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPath":
            suggest = "http_path"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionDatabricks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionDatabricks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionDatabricks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 http_path: str,
                 catalog: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str host: The hostname of the Databricks cluster or SQL warehouse.
        :param str http_path: The HTTP path of the Databricks cluster or SQL warehouse.
        :param str catalog: Catalog name if Unity Catalog is enabled in your Databricks workspace.
        :param str client_id: Required to enable Databricks OAuth authentication for IDE developers.
        :param str client_secret: Required to enable Databricks OAuth authentication for IDE developers.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http_path", http_path)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> str:
        """
        The HTTP path of the Databricks cluster or SQL warehouse.
        """
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        """
        Catalog name if Unity Catalog is enabled in your Databricks workspace.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Required to enable Databricks OAuth authentication for IDE developers.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class GlobalConnectionSnowflake(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSso":
            suggest = "allow_sso"
        elif key == "clientSessionKeepAlive":
            suggest = "client_session_keep_alive"
        elif key == "oauthClientId":
            suggest = "oauth_client_id"
        elif key == "oauthClientSecret":
            suggest = "oauth_client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalConnectionSnowflake. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalConnectionSnowflake.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalConnectionSnowflake.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 database: str,
                 warehouse: str,
                 allow_sso: Optional[bool] = None,
                 client_session_keep_alive: Optional[bool] = None,
                 oauth_client_id: Optional[str] = None,
                 oauth_client_secret: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str account: The Snowflake account name
        :param str database: The default database for the connection
        :param str warehouse: The default Snowflake Warehouse to use for the connection
        :param bool allow_sso: Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        :param bool client_session_keep_alive: If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        :param str oauth_client_id: OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        :param str oauth_client_secret: OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        :param str role: The Snowflake role to use when running queries on the connection
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "warehouse", warehouse)
        if allow_sso is not None:
            pulumi.set(__self__, "allow_sso", allow_sso)
        if client_session_keep_alive is not None:
            pulumi.set(__self__, "client_session_keep_alive", client_session_keep_alive)
        if oauth_client_id is not None:
            pulumi.set(__self__, "oauth_client_id", oauth_client_id)
        if oauth_client_secret is not None:
            pulumi.set(__self__, "oauth_client_secret", oauth_client_secret)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The Snowflake account name
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The default database for the connection
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        The default Snowflake Warehouse to use for the connection
        """
        return pulumi.get(self, "warehouse")

    @property
    @pulumi.getter(name="allowSso")
    def allow_sso(self) -> Optional[bool]:
        """
        Whether to allow Snowflake OAuth for the connection. If true, the `oauth_client_id` and `oauth_client_secret` fields must be set
        """
        return pulumi.get(self, "allow_sso")

    @property
    @pulumi.getter(name="clientSessionKeepAlive")
    def client_session_keep_alive(self) -> Optional[bool]:
        """
        If true, the snowflake client will keep connections for longer than the default 4 hours. This is helpful when particularly long-running queries are executing (> 4 hours)
        """
        return pulumi.get(self, "client_session_keep_alive")

    @property
    @pulumi.getter(name="oauthClientId")
    def oauth_client_id(self) -> Optional[str]:
        """
        OAuth Client ID. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_id")

    @property
    @pulumi.getter(name="oauthClientSecret")
    def oauth_client_secret(self) -> Optional[str]:
        """
        OAuth Client Secret. Required to allow OAuth between dbt Cloud and Snowflake
        """
        return pulumi.get(self, "oauth_client_secret")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The Snowflake role to use when running queries on the connection
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GroupGroupPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allProjects":
            suggest = "all_projects"
        elif key == "permissionSet":
            suggest = "permission_set"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "writableEnvironmentCategories":
            suggest = "writable_environment_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupGroupPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupGroupPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupGroupPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: Optional[int] = None,
                 writable_environment_categories: Optional[Sequence[str]] = None):
        """
        :param bool all_projects: Whether access should be provided for all projects or not.
        :param str permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param int project_id: Project ID to apply this permission to for this group.
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[int]:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[Sequence[str]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GroupPartialPermissionsGroupPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allProjects":
            suggest = "all_projects"
        elif key == "permissionSet":
            suggest = "permission_set"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "writableEnvironmentCategories":
            suggest = "writable_environment_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPartialPermissionsGroupPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPartialPermissionsGroupPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPartialPermissionsGroupPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: Optional[int] = None,
                 writable_environment_categories: Optional[Sequence[str]] = None):
        """
        :param bool all_projects: Whether access should be provided for all projects or not.
        :param str permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param int project_id: Project ID to apply this permission to for this group.
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[int]:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[Sequence[str]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class JobJobCompletionTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobId":
            suggest = "job_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobCompletionTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobCompletionTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobCompletionTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_id: int,
                 project_id: int,
                 statuses: Sequence[str]):
        """
        :param int job_id: The ID of the job that would trigger this job after completion.
        :param int project_id: The ID of the project where the trigger job is running in.
        :param Sequence[str] statuses: List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.
        """
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        """
        The ID of the job that would trigger this job after completion.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The ID of the project where the trigger job is running in.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        """
        List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class ServiceTokenServiceTokenPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allProjects":
            suggest = "all_projects"
        elif key == "permissionSet":
            suggest = "permission_set"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "writableEnvironmentCategories":
            suggest = "writable_environment_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceTokenServiceTokenPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceTokenServiceTokenPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceTokenServiceTokenPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: Optional[int] = None,
                 writable_environment_categories: Optional[Sequence[str]] = None):
        """
        :param bool all_projects: Whether or not to apply this permission to all projects for this service token
        :param str permission_set: Set of permissions to apply
        :param int project_id: Project ID to apply this permission to for this service token
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if writable_environment_categories is not None:
            pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether or not to apply this permission to all projects for this service token
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[int]:
        """
        Project ID to apply this permission to for this service token
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Optional[Sequence[str]]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GetEnvironmentsEnvironmentResult(dict):
    def __init__(__self__, *,
                 connection_id: int,
                 credentials_id: int,
                 custom_branch: str,
                 dbt_version: str,
                 deployment_type: str,
                 environment_id: int,
                 extended_attributes_id: int,
                 name: str,
                 project_id: int,
                 type: str,
                 use_custom_branch: bool):
        """
        :param int connection_id: A connection ID (used with Global Connections)
        :param int credentials_id: Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments
        :param str custom_branch: The custom branch name to use
        :param str dbt_version: Version number of dbt to use in this environment.
        :param str deployment_type: The type of deployment environment (currently 'production', 'staging' or empty)
        :param int environment_id: The ID of the environment
        :param int extended_attributes_id: The ID of the extended attributes applied
        :param str name: The name of the environment
        :param int project_id: The project ID to which the environment belong
        :param str type: The type of environment (must be either development or deployment)
        :param bool use_custom_branch: Whether to use a custom git branch in this environment
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "credentials_id", credentials_id)
        pulumi.set(__self__, "custom_branch", custom_branch)
        pulumi.set(__self__, "dbt_version", dbt_version)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "extended_attributes_id", extended_attributes_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "use_custom_branch", use_custom_branch)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> int:
        """
        A connection ID (used with Global Connections)
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="credentialsId")
    def credentials_id(self) -> int:
        """
        Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments
        """
        return pulumi.get(self, "credentials_id")

    @property
    @pulumi.getter(name="customBranch")
    def custom_branch(self) -> str:
        """
        The custom branch name to use
        """
        return pulumi.get(self, "custom_branch")

    @property
    @pulumi.getter(name="dbtVersion")
    def dbt_version(self) -> str:
        """
        Version number of dbt to use in this environment.
        """
        return pulumi.get(self, "dbt_version")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        The type of deployment environment (currently 'production', 'staging' or empty)
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> int:
        """
        The ID of the environment
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="extendedAttributesId")
    def extended_attributes_id(self) -> int:
        """
        The ID of the extended attributes applied
        """
        return pulumi.get(self, "extended_attributes_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the environment
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The project ID to which the environment belong
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of environment (must be either development or deployment)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useCustomBranch")
    def use_custom_branch(self) -> bool:
        """
        Whether to use a custom git branch in this environment
        """
        return pulumi.get(self, "use_custom_branch")


@pulumi.output_type
class GetGroupGroupPermissionResult(dict):
    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: int,
                 writable_environment_categories: Sequence[str]):
        """
        :param bool all_projects: Whether access should be provided for all projects or not.
        :param str permission_set: Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        :param int project_id: Project ID to apply this permission to for this group.
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether access should be provided for all projects or not.
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply. The permissions allowed are the same as the ones for the `Group` resource.
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        Project ID to apply this permission to for this group.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Sequence[str]:
        """
        What types of environments to apply Write permissions to.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GetGroupUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: int):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobCompletionTriggerConditionResult(dict):
    def __init__(__self__, *,
                 job_id: int,
                 project_id: int,
                 statuses: Sequence[str]):
        """
        :param int job_id: The ID of the job that would trigger this job after completion.
        :param int project_id: The ID of the project where the trigger job is running in.
        :param Sequence[str] statuses: List of statuses to trigger the job on.
        """
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        """
        The ID of the job that would trigger this job after completion.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The ID of the project where the trigger job is running in.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        """
        List of statuses to trigger the job on.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class GetJobsJobResult(dict):
    def __init__(__self__, *,
                 dbt_version: str,
                 deferring_environment_id: int,
                 deferring_job_definition_id: int,
                 description: str,
                 environment: 'outputs.GetJobsJobEnvironmentResult',
                 environment_id: int,
                 execute_steps: Sequence[str],
                 execution: 'outputs.GetJobsJobExecutionResult',
                 generate_docs: bool,
                 id: int,
                 job_completion_trigger_condition: 'outputs.GetJobsJobJobCompletionTriggerConditionResult',
                 job_type: str,
                 name: str,
                 project_id: int,
                 run_generate_sources: bool,
                 schedule: 'outputs.GetJobsJobScheduleResult',
                 settings: 'outputs.GetJobsJobSettingsResult',
                 triggers: 'outputs.GetJobsJobTriggersResult',
                 triggers_on_draft_pr: bool):
        """
        :param str dbt_version: The version of dbt used for the job. If not set, the environment version will be used.
        :param int deferring_environment_id: The ID of the environment this job defers to
        :param int deferring_job_definition_id: [Deprecated - deferral is now set at the environment level] The ID of the job definition this job defers to
        :param str description: The description of the job
        :param 'GetJobsJobEnvironmentArgs' environment: Details of the environment the job is running in
        :param int environment_id: The ID of environment
        :param Sequence[str] execute_steps: The list of steps to run in the job
        :param bool generate_docs: Whether the job generate docs
        :param int id: The ID of the job
        :param 'GetJobsJobJobCompletionTriggerConditionArgs' job_completion_trigger_condition: Whether the job is triggered by the completion of another job
        :param str job_type: The type of job (e.g. CI, scheduled)
        :param str name: The name of the job
        :param int project_id: The ID of the project
        :param bool run_generate_sources: Whether the job test source freshness
        :param bool triggers_on_draft_pr: Whether the CI job should be automatically triggered on draft PRs
        """
        pulumi.set(__self__, "dbt_version", dbt_version)
        pulumi.set(__self__, "deferring_environment_id", deferring_environment_id)
        pulumi.set(__self__, "deferring_job_definition_id", deferring_job_definition_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "execute_steps", execute_steps)
        pulumi.set(__self__, "execution", execution)
        pulumi.set(__self__, "generate_docs", generate_docs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_completion_trigger_condition", job_completion_trigger_condition)
        pulumi.set(__self__, "job_type", job_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "run_generate_sources", run_generate_sources)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "triggers", triggers)
        pulumi.set(__self__, "triggers_on_draft_pr", triggers_on_draft_pr)

    @property
    @pulumi.getter(name="dbtVersion")
    def dbt_version(self) -> str:
        """
        The version of dbt used for the job. If not set, the environment version will be used.
        """
        return pulumi.get(self, "dbt_version")

    @property
    @pulumi.getter(name="deferringEnvironmentId")
    def deferring_environment_id(self) -> int:
        """
        The ID of the environment this job defers to
        """
        return pulumi.get(self, "deferring_environment_id")

    @property
    @pulumi.getter(name="deferringJobDefinitionId")
    def deferring_job_definition_id(self) -> int:
        """
        [Deprecated - deferral is now set at the environment level] The ID of the job definition this job defers to
        """
        return pulumi.get(self, "deferring_job_definition_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the job
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def environment(self) -> 'outputs.GetJobsJobEnvironmentResult':
        """
        Details of the environment the job is running in
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> int:
        """
        The ID of environment
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="executeSteps")
    def execute_steps(self) -> Sequence[str]:
        """
        The list of steps to run in the job
        """
        return pulumi.get(self, "execute_steps")

    @property
    @pulumi.getter
    def execution(self) -> 'outputs.GetJobsJobExecutionResult':
        return pulumi.get(self, "execution")

    @property
    @pulumi.getter(name="generateDocs")
    def generate_docs(self) -> bool:
        """
        Whether the job generate docs
        """
        return pulumi.get(self, "generate_docs")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the job
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="jobCompletionTriggerCondition")
    def job_completion_trigger_condition(self) -> 'outputs.GetJobsJobJobCompletionTriggerConditionResult':
        """
        Whether the job is triggered by the completion of another job
        """
        return pulumi.get(self, "job_completion_trigger_condition")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        The type of job (e.g. CI, scheduled)
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the job
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        The ID of the project
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="runGenerateSources")
    def run_generate_sources(self) -> bool:
        """
        Whether the job test source freshness
        """
        return pulumi.get(self, "run_generate_sources")

    @property
    @pulumi.getter
    def schedule(self) -> 'outputs.GetJobsJobScheduleResult':
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def settings(self) -> 'outputs.GetJobsJobSettingsResult':
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def triggers(self) -> 'outputs.GetJobsJobTriggersResult':
        return pulumi.get(self, "triggers")

    @property
    @pulumi.getter(name="triggersOnDraftPr")
    def triggers_on_draft_pr(self) -> bool:
        """
        Whether the CI job should be automatically triggered on draft PRs
        """
        return pulumi.get(self, "triggers_on_draft_pr")


@pulumi.output_type
class GetJobsJobEnvironmentResult(dict):
    def __init__(__self__, *,
                 deployment_type: str,
                 id: int,
                 name: str,
                 project_id: int,
                 type: str):
        """
        :param str deployment_type: Type of deployment environment: staging, production
        :param int id: ID of the environment
        :param str name: Name of the environment
        :param str type: Environment type: development or deployment
        """
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        Type of deployment environment: staging, production
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID of the environment
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Environment type: development or deployment
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetJobsJobExecutionResult(dict):
    def __init__(__self__, *,
                 timeout_seconds: int):
        """
        :param int timeout_seconds: The number of seconds before the job times out
        """
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> int:
        """
        The number of seconds before the job times out
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetJobsJobJobCompletionTriggerConditionResult(dict):
    def __init__(__self__, *,
                 condition: 'outputs.GetJobsJobJobCompletionTriggerConditionConditionResult'):
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.GetJobsJobJobCompletionTriggerConditionConditionResult':
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetJobsJobJobCompletionTriggerConditionConditionResult(dict):
    def __init__(__self__, *,
                 job_id: int,
                 project_id: int,
                 statuses: Sequence[str]):
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def statuses(self) -> Sequence[str]:
        return pulumi.get(self, "statuses")


@pulumi.output_type
class GetJobsJobScheduleResult(dict):
    def __init__(__self__, *,
                 cron: str):
        """
        :param str cron: The cron schedule for the job. Only used if triggers.schedule is true
        """
        pulumi.set(__self__, "cron", cron)

    @property
    @pulumi.getter
    def cron(self) -> str:
        """
        The cron schedule for the job. Only used if triggers.schedule is true
        """
        return pulumi.get(self, "cron")


@pulumi.output_type
class GetJobsJobSettingsResult(dict):
    def __init__(__self__, *,
                 target_name: str,
                 threads: int):
        """
        :param str target_name: Value for `target.name` in the Jinja context
        :param int threads: Number of threads to run dbt with
        """
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "threads", threads)

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> str:
        """
        Value for `target.name` in the Jinja context
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter
    def threads(self) -> int:
        """
        Number of threads to run dbt with
        """
        return pulumi.get(self, "threads")


@pulumi.output_type
class GetJobsJobTriggersResult(dict):
    def __init__(__self__, *,
                 git_provider_webhook: bool,
                 github_webhook: bool,
                 on_merge: bool,
                 schedule: bool):
        """
        :param bool git_provider_webhook: Whether the job runs automatically on PR creation
        :param bool github_webhook: Whether the job runs automatically on PR creation
        :param bool on_merge: Whether the job runs automatically once a PR is merged
        :param bool schedule: Whether the job runs on a schedule
        """
        pulumi.set(__self__, "git_provider_webhook", git_provider_webhook)
        pulumi.set(__self__, "github_webhook", github_webhook)
        pulumi.set(__self__, "on_merge", on_merge)
        pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="gitProviderWebhook")
    def git_provider_webhook(self) -> bool:
        """
        Whether the job runs automatically on PR creation
        """
        return pulumi.get(self, "git_provider_webhook")

    @property
    @pulumi.getter(name="githubWebhook")
    def github_webhook(self) -> bool:
        """
        Whether the job runs automatically on PR creation
        """
        return pulumi.get(self, "github_webhook")

    @property
    @pulumi.getter(name="onMerge")
    def on_merge(self) -> bool:
        """
        Whether the job runs automatically once a PR is merged
        """
        return pulumi.get(self, "on_merge")

    @property
    @pulumi.getter
    def schedule(self) -> bool:
        """
        Whether the job runs on a schedule
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class GetServiceTokenServiceTokenPermissionResult(dict):
    def __init__(__self__, *,
                 all_projects: bool,
                 permission_set: str,
                 project_id: int,
                 writable_environment_categories: Sequence[str]):
        """
        :param bool all_projects: Whether or not to apply this permission to all projects for this service token
        :param str permission_set: Set of permissions to apply
        :param int project_id: Project ID to apply this permission to for this service token
        :param Sequence[str] writable_environment_categories: What types of environments to apply Write permissions to.
               Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
               The values allowed are `all`, `development`, `staging`, `production` and `other`.
               Not setting a value is the same as selecting `all`.
               Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        pulumi.set(__self__, "all_projects", all_projects)
        pulumi.set(__self__, "permission_set", permission_set)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "writable_environment_categories", writable_environment_categories)

    @property
    @pulumi.getter(name="allProjects")
    def all_projects(self) -> bool:
        """
        Whether or not to apply this permission to all projects for this service token
        """
        return pulumi.get(self, "all_projects")

    @property
    @pulumi.getter(name="permissionSet")
    def permission_set(self) -> str:
        """
        Set of permissions to apply
        """
        return pulumi.get(self, "permission_set")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        Project ID to apply this permission to for this service token
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="writableEnvironmentCategories")
    def writable_environment_categories(self) -> Sequence[str]:
        """
        What types of environments to apply Write permissions to.
        Even if Write access is restricted to some environment types, the permission set will have Read access to all environments.
        The values allowed are `all`, `development`, `staging`, `production` and `other`.
        Not setting a value is the same as selecting `all`.
        Not all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.
        """
        return pulumi.get(self, "writable_environment_categories")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: int):
        """
        :param str email: Email for the user
        :param int id: ID of the user
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        Email for the user
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID of the user
        """
        return pulumi.get(self, "id")


