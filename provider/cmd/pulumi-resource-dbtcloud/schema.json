{
    "name": "dbtcloud",
    "displayName": "dbt Cloud",
    "description": "A Pulumi package for creating and managing dbt Cloud resources.",
    "keywords": [
        "pulumi",
        "dbtcloud",
        "dbt",
        "cloud",
        "category/cloud"
    ],
    "homepage": "https://pulumi.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`dbtcloud` Terraform Provider](https://github.com/dbt-labs/terraform-provider-dbtcloud).",
    "repository": "https://github.com/pulumi/pulumi-dbtcloud",
    "logoUrl": "https://raw.githubusercontent.com/pulumi/pulumi-dbtcloud/main/res/dbt-bit_tm.png",
    "pluginDownloadURL": "github://api.github.com/pulumi/pulumi-dbtcloud",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "dbtcloud": "DbtCloud"
            },
            "compatibility": "tfbridge20",
            "rootNamespace": "Pulumi",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageName": "@pulumi/dbtcloud",
            "packageDescription": "A Pulumi package for creating and managing dbt Cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/dbt-labs/terraform-provider-dbtcloud)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-dbtcloud` repo](https://github.com/pulumi/pulumi-dbtcloud/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-dbtcloud` repo](https://github.com/dbt-labs/terraform-provider-dbtcloud/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "packageName": "pulumi_dbtcloud",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/dbt-labs/terraform-provider-dbtcloud)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-dbtcloud` repo](https://github.com/pulumi/pulumi-dbtcloud/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-dbtcloud` repo](https://github.com/dbt-labs/terraform-provider-dbtcloud/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "accountId": {
                "type": "integer",
                "description": "Account identifier for your dbt Cloud implementation. Instead of setting the parameter, you can set the environment\nvariable `DBT_CLOUD_ACCOUNT_ID`\n",
                "defaultInfo": {
                    "environment": [
                        "DBT_CLOUD_ACCOUNT_ID"
                    ]
                }
            },
            "hostUrl": {
                "type": "string",
                "description": "URL for your dbt Cloud deployment. Instead of setting the parameter, you can set the environment variable\n`DBT_CLOUD_HOST_URL` - Defaults to https://cloud.getdbt.com/api\n",
                "default": "https://cloud.getdbt.com/api",
                "defaultInfo": {
                    "environment": [
                        "DBT_CLOUD_HOST_URL"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "API token for your dbt Cloud. Instead of setting the parameter, you can set the environment variable `DBT_CLOUD_TOKEN`\n",
                "defaultInfo": {
                    "environment": [
                        "DBT_CLOUD_TOKEN"
                    ]
                },
                "secret": true
            }
        }
    },
    "types": {
        "dbtcloud:index/GroupGroupPermission:GroupGroupPermission": {
            "properties": {
                "allProjects": {
                    "type": "boolean",
                    "description": "Whether access should be provided for all projects or not.\n"
                },
                "permissionSet": {
                    "type": "string",
                    "description": "Set of permissions to apply. The permissions allowed are the same as the ones for the `dbtcloud.Group` resource.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to apply this permission to for this group.\n"
                },
                "writableEnvironmentCategories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "What types of environments to apply Write permissions to.\nEven if Write access is restricted to some environment types, the permission set will have Read access to all environments.\nThe values allowed are `all`, `development`, `staging`, `production` and `other`.\nNot setting a value is the same as selecting `all`.\nNot all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.\n"
                }
            },
            "type": "object",
            "required": [
                "allProjects",
                "permissionSet"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allProjects",
                        "permissionSet",
                        "writableEnvironmentCategories"
                    ]
                }
            }
        },
        "dbtcloud:index/GroupPartialPermissionsGroupPermission:GroupPartialPermissionsGroupPermission": {
            "properties": {
                "allProjects": {
                    "type": "boolean",
                    "description": "Whether access should be provided for all projects or not.\n"
                },
                "permissionSet": {
                    "type": "string",
                    "description": "Set of permissions to apply. The permissions allowed are the same as the ones for the `dbtcloud.Group` resource.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to apply this permission to for this group.\n"
                },
                "writableEnvironmentCategories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "What types of environments to apply Write permissions to.\nEven if Write access is restricted to some environment types, the permission set will have Read access to all environments.\nThe values allowed are `all`, `development`, `staging`, `production` and `other`.\nNot setting a value is the same as selecting `all`.\nNot all permission sets support environment level write settings, only `analyst`, `database_admin`, `developer`, `git_admin` and `team_admin`.\n"
                }
            },
            "type": "object",
            "required": [
                "allProjects",
                "permissionSet"
            ]
        },
        "dbtcloud:index/JobJobCompletionTriggerCondition:JobJobCompletionTriggerCondition": {
            "properties": {
                "jobId": {
                    "type": "integer",
                    "description": "The ID of the job that would trigger this job after completion.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project where the trigger job is running in.\n"
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of statuses to trigger the job on. Possible values are `success`, `error` and `canceled`.\n"
                }
            },
            "type": "object",
            "required": [
                "jobId",
                "projectId",
                "statuses"
            ]
        },
        "dbtcloud:index/ServiceTokenServiceTokenPermission:ServiceTokenServiceTokenPermission": {
            "properties": {
                "allProjects": {
                    "type": "boolean",
                    "description": "Whether or not to apply this permission to all projects for this service token\n"
                },
                "permissionSet": {
                    "type": "string",
                    "description": "Set of permissions to apply\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to apply this permission to for this service token\n"
                }
            },
            "type": "object",
            "required": [
                "allProjects",
                "permissionSet"
            ]
        },
        "dbtcloud:index/getEnvironmentsEnvironment:getEnvironmentsEnvironment": {
            "properties": {
                "credentialsId": {
                    "type": "integer",
                    "description": "Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments\n"
                },
                "customBranch": {
                    "type": "string",
                    "description": "The custom branch name to use\n"
                },
                "dbtVersion": {
                    "type": "string",
                    "description": "Version number of dbt to use in this environment.\n"
                },
                "deploymentType": {
                    "type": "string",
                    "description": "The type of deployment environment (currently 'production', 'staging' or empty)\n"
                },
                "environmentId": {
                    "type": "integer",
                    "description": "The ID of the environment\n"
                },
                "extendedAttributesId": {
                    "type": "integer",
                    "description": "The ID of the extended attributes applied\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the environment\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The project ID to which the environment belong\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of environment (must be either development or deployment)\n"
                },
                "useCustomBranch": {
                    "type": "boolean",
                    "description": "Whether to use a custom git branch in this environment\n"
                }
            },
            "type": "object",
            "required": [
                "credentialsId",
                "customBranch",
                "dbtVersion",
                "deploymentType",
                "environmentId",
                "extendedAttributesId",
                "name",
                "projectId",
                "type",
                "useCustomBranch"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "dbtcloud:index/getGroupGroupPermission:getGroupGroupPermission": {
            "properties": {
                "allProjects": {
                    "type": "boolean",
                    "description": "Whether access should be provided for all projects or not.\n"
                },
                "permissionSet": {
                    "type": "string",
                    "description": "Set of permissions to apply. The permissions allowed are the same as the ones for the `dbtcloud.Group` resource.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to apply this permission to for this group.\n"
                },
                "writableEnvironmentCategories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "What types of environments to apply Write permissions to.\n"
                }
            },
            "type": "object",
            "required": [
                "allProjects",
                "permissionSet",
                "projectId",
                "writableEnvironmentCategories"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "dbtcloud:index/getGroupUsersUser:getGroupUsersUser": {
            "properties": {
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "email",
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "dbtcloud:index/getJobJobCompletionTriggerCondition:getJobJobCompletionTriggerCondition": {
            "properties": {
                "jobId": {
                    "type": "integer",
                    "description": "The ID of the job that would trigger this job after completion.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project where the trigger job is running in.\n"
                },
                "statuses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of statuses to trigger the job on.\n"
                }
            },
            "type": "object",
            "required": [
                "jobId",
                "projectId",
                "statuses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "dbtcloud:index/getServiceTokenServiceTokenPermission:getServiceTokenServiceTokenPermission": {
            "properties": {
                "allProjects": {
                    "type": "boolean",
                    "description": "Whether or not to apply this permission to all projects for this service token\n"
                },
                "permissionSet": {
                    "type": "string",
                    "description": "Set of permissions to apply\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to apply this permission to for this service token\n"
                }
            },
            "type": "object",
            "required": [
                "allProjects",
                "permissionSet",
                "projectId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the dbtcloud package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "accountId": {
                "type": "integer",
                "description": "Account identifier for your dbt Cloud implementation. Instead of setting the parameter, you can set the environment\nvariable `DBT_CLOUD_ACCOUNT_ID`\n"
            },
            "hostUrl": {
                "type": "string",
                "description": "URL for your dbt Cloud deployment. Instead of setting the parameter, you can set the environment variable\n`DBT_CLOUD_HOST_URL` - Defaults to https://cloud.getdbt.com/api\n"
            },
            "token": {
                "type": "string",
                "description": "API token for your dbt Cloud. Instead of setting the parameter, you can set the environment variable `DBT_CLOUD_TOKEN`\n",
                "secret": true
            }
        },
        "inputProperties": {
            "accountId": {
                "type": "integer",
                "description": "Account identifier for your dbt Cloud implementation. Instead of setting the parameter, you can set the environment\nvariable `DBT_CLOUD_ACCOUNT_ID`\n",
                "defaultInfo": {
                    "environment": [
                        "DBT_CLOUD_ACCOUNT_ID"
                    ]
                }
            },
            "hostUrl": {
                "type": "string",
                "description": "URL for your dbt Cloud deployment. Instead of setting the parameter, you can set the environment variable\n`DBT_CLOUD_HOST_URL` - Defaults to https://cloud.getdbt.com/api\n",
                "default": "https://cloud.getdbt.com/api",
                "defaultInfo": {
                    "environment": [
                        "DBT_CLOUD_HOST_URL"
                    ]
                }
            },
            "token": {
                "type": "string",
                "description": "API token for your dbt Cloud. Instead of setting the parameter, you can set the environment variable `DBT_CLOUD_TOKEN`\n",
                "defaultInfo": {
                    "environment": [
                        "DBT_CLOUD_TOKEN"
                    ]
                },
                "secret": true
            }
        }
    },
    "resources": {
        "dbtcloud:index/bigQueryConnection:BigQueryConnection": {
            "description": "Resource to create BigQuery connections in dbt Cloud. Can be set to use OAuth for developers.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myConnection = new dbtcloud.BigQueryConnection(\"my_connection\", {\n    projectId: dbtProject.id,\n    name: \"Project Name\",\n    type: \"bigquery\",\n    isActive: true,\n    gcpProjectId: \"my-gcp-project-id\",\n    timeoutSeconds: 100,\n    privateKeyId: \"my-private-key-id\",\n    privateKey: \"ABCDEFGHIJKL\",\n    clientEmail: \"my_client_email\",\n    clientId: \"my_client_di\",\n    authUri: \"my_auth_uri\",\n    tokenUri: \"my_token_uri\",\n    authProviderX509CertUrl: \"my_auth_provider_x509_cert_url\",\n    clientX509CertUrl: \"my_client_x509_cert_url\",\n    retries: 3,\n});\n// it is also possible to set the connection to use OAuth by filling in `application_id` and `application_secret`\nconst myConnectionWithOauth = new dbtcloud.BigQueryConnection(\"my_connection_with_oauth\", {\n    projectId: dbtProject.id,\n    name: \"Project Name\",\n    type: \"bigquery\",\n    isActive: true,\n    gcpProjectId: \"my-gcp-project-id\",\n    timeoutSeconds: 100,\n    privateKeyId: \"my-private-key-id\",\n    privateKey: \"ABCDEFGHIJKL\",\n    clientEmail: \"my_client_email\",\n    clientId: \"my_client_di\",\n    authUri: \"my_auth_uri\",\n    tokenUri: \"my_token_uri\",\n    authProviderX509CertUrl: \"my_auth_provider_x509_cert_url\",\n    clientX509CertUrl: \"my_client_x509_cert_url\",\n    retries: 3,\n    applicationId: \"oauth_application_id\",\n    applicationSecret: \"oauth_secret_id\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_connection = dbtcloud.BigQueryConnection(\"my_connection\",\n    project_id=dbt_project[\"id\"],\n    name=\"Project Name\",\n    type=\"bigquery\",\n    is_active=True,\n    gcp_project_id=\"my-gcp-project-id\",\n    timeout_seconds=100,\n    private_key_id=\"my-private-key-id\",\n    private_key=\"ABCDEFGHIJKL\",\n    client_email=\"my_client_email\",\n    client_id=\"my_client_di\",\n    auth_uri=\"my_auth_uri\",\n    token_uri=\"my_token_uri\",\n    auth_provider_x509_cert_url=\"my_auth_provider_x509_cert_url\",\n    client_x509_cert_url=\"my_client_x509_cert_url\",\n    retries=3)\n# it is also possible to set the connection to use OAuth by filling in `application_id` and `application_secret`\nmy_connection_with_oauth = dbtcloud.BigQueryConnection(\"my_connection_with_oauth\",\n    project_id=dbt_project[\"id\"],\n    name=\"Project Name\",\n    type=\"bigquery\",\n    is_active=True,\n    gcp_project_id=\"my-gcp-project-id\",\n    timeout_seconds=100,\n    private_key_id=\"my-private-key-id\",\n    private_key=\"ABCDEFGHIJKL\",\n    client_email=\"my_client_email\",\n    client_id=\"my_client_di\",\n    auth_uri=\"my_auth_uri\",\n    token_uri=\"my_token_uri\",\n    auth_provider_x509_cert_url=\"my_auth_provider_x509_cert_url\",\n    client_x509_cert_url=\"my_client_x509_cert_url\",\n    retries=3,\n    application_id=\"oauth_application_id\",\n    application_secret=\"oauth_secret_id\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myConnection = new DbtCloud.BigQueryConnection(\"my_connection\", new()\n    {\n        ProjectId = dbtProject.Id,\n        Name = \"Project Name\",\n        Type = \"bigquery\",\n        IsActive = true,\n        GcpProjectId = \"my-gcp-project-id\",\n        TimeoutSeconds = 100,\n        PrivateKeyId = \"my-private-key-id\",\n        PrivateKey = \"ABCDEFGHIJKL\",\n        ClientEmail = \"my_client_email\",\n        ClientId = \"my_client_di\",\n        AuthUri = \"my_auth_uri\",\n        TokenUri = \"my_token_uri\",\n        AuthProviderX509CertUrl = \"my_auth_provider_x509_cert_url\",\n        ClientX509CertUrl = \"my_client_x509_cert_url\",\n        Retries = 3,\n    });\n\n    // it is also possible to set the connection to use OAuth by filling in `application_id` and `application_secret`\n    var myConnectionWithOauth = new DbtCloud.BigQueryConnection(\"my_connection_with_oauth\", new()\n    {\n        ProjectId = dbtProject.Id,\n        Name = \"Project Name\",\n        Type = \"bigquery\",\n        IsActive = true,\n        GcpProjectId = \"my-gcp-project-id\",\n        TimeoutSeconds = 100,\n        PrivateKeyId = \"my-private-key-id\",\n        PrivateKey = \"ABCDEFGHIJKL\",\n        ClientEmail = \"my_client_email\",\n        ClientId = \"my_client_di\",\n        AuthUri = \"my_auth_uri\",\n        TokenUri = \"my_token_uri\",\n        AuthProviderX509CertUrl = \"my_auth_provider_x509_cert_url\",\n        ClientX509CertUrl = \"my_client_x509_cert_url\",\n        Retries = 3,\n        ApplicationId = \"oauth_application_id\",\n        ApplicationSecret = \"oauth_secret_id\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewBigQueryConnection(ctx, \"my_connection\", \u0026dbtcloud.BigQueryConnectionArgs{\n\t\t\tProjectId:               pulumi.Any(dbtProject.Id),\n\t\t\tName:                    pulumi.String(\"Project Name\"),\n\t\t\tType:                    pulumi.String(\"bigquery\"),\n\t\t\tIsActive:                pulumi.Bool(true),\n\t\t\tGcpProjectId:            pulumi.String(\"my-gcp-project-id\"),\n\t\t\tTimeoutSeconds:          pulumi.Int(100),\n\t\t\tPrivateKeyId:            pulumi.String(\"my-private-key-id\"),\n\t\t\tPrivateKey:              pulumi.String(\"ABCDEFGHIJKL\"),\n\t\t\tClientEmail:             pulumi.String(\"my_client_email\"),\n\t\t\tClientId:                pulumi.String(\"my_client_di\"),\n\t\t\tAuthUri:                 pulumi.String(\"my_auth_uri\"),\n\t\t\tTokenUri:                pulumi.String(\"my_token_uri\"),\n\t\t\tAuthProviderX509CertUrl: pulumi.String(\"my_auth_provider_x509_cert_url\"),\n\t\t\tClientX509CertUrl:       pulumi.String(\"my_client_x509_cert_url\"),\n\t\t\tRetries:                 pulumi.Int(3),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// it is also possible to set the connection to use OAuth by filling in `application_id` and `application_secret`\n\t\t_, err = dbtcloud.NewBigQueryConnection(ctx, \"my_connection_with_oauth\", \u0026dbtcloud.BigQueryConnectionArgs{\n\t\t\tProjectId:               pulumi.Any(dbtProject.Id),\n\t\t\tName:                    pulumi.String(\"Project Name\"),\n\t\t\tType:                    pulumi.String(\"bigquery\"),\n\t\t\tIsActive:                pulumi.Bool(true),\n\t\t\tGcpProjectId:            pulumi.String(\"my-gcp-project-id\"),\n\t\t\tTimeoutSeconds:          pulumi.Int(100),\n\t\t\tPrivateKeyId:            pulumi.String(\"my-private-key-id\"),\n\t\t\tPrivateKey:              pulumi.String(\"ABCDEFGHIJKL\"),\n\t\t\tClientEmail:             pulumi.String(\"my_client_email\"),\n\t\t\tClientId:                pulumi.String(\"my_client_di\"),\n\t\t\tAuthUri:                 pulumi.String(\"my_auth_uri\"),\n\t\t\tTokenUri:                pulumi.String(\"my_token_uri\"),\n\t\t\tAuthProviderX509CertUrl: pulumi.String(\"my_auth_provider_x509_cert_url\"),\n\t\t\tClientX509CertUrl:       pulumi.String(\"my_client_x509_cert_url\"),\n\t\t\tRetries:                 pulumi.Int(3),\n\t\t\tApplicationId:           pulumi.String(\"oauth_application_id\"),\n\t\t\tApplicationSecret:       pulumi.String(\"oauth_secret_id\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.BigQueryConnection;\nimport com.pulumi.dbtcloud.BigQueryConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myConnection = new BigQueryConnection(\"myConnection\", BigQueryConnectionArgs.builder()\n            .projectId(dbtProject.id())\n            .name(\"Project Name\")\n            .type(\"bigquery\")\n            .isActive(true)\n            .gcpProjectId(\"my-gcp-project-id\")\n            .timeoutSeconds(100)\n            .privateKeyId(\"my-private-key-id\")\n            .privateKey(\"ABCDEFGHIJKL\")\n            .clientEmail(\"my_client_email\")\n            .clientId(\"my_client_di\")\n            .authUri(\"my_auth_uri\")\n            .tokenUri(\"my_token_uri\")\n            .authProviderX509CertUrl(\"my_auth_provider_x509_cert_url\")\n            .clientX509CertUrl(\"my_client_x509_cert_url\")\n            .retries(3)\n            .build());\n\n        // it is also possible to set the connection to use OAuth by filling in `application_id` and `application_secret`\n        var myConnectionWithOauth = new BigQueryConnection(\"myConnectionWithOauth\", BigQueryConnectionArgs.builder()\n            .projectId(dbtProject.id())\n            .name(\"Project Name\")\n            .type(\"bigquery\")\n            .isActive(true)\n            .gcpProjectId(\"my-gcp-project-id\")\n            .timeoutSeconds(100)\n            .privateKeyId(\"my-private-key-id\")\n            .privateKey(\"ABCDEFGHIJKL\")\n            .clientEmail(\"my_client_email\")\n            .clientId(\"my_client_di\")\n            .authUri(\"my_auth_uri\")\n            .tokenUri(\"my_token_uri\")\n            .authProviderX509CertUrl(\"my_auth_provider_x509_cert_url\")\n            .clientX509CertUrl(\"my_client_x509_cert_url\")\n            .retries(3)\n            .applicationId(\"oauth_application_id\")\n            .applicationSecret(\"oauth_secret_id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myConnection:\n    type: dbtcloud:BigQueryConnection\n    name: my_connection\n    properties:\n      projectId: ${dbtProject.id}\n      name: Project Name\n      type: bigquery\n      isActive: true\n      gcpProjectId: my-gcp-project-id\n      timeoutSeconds: 100\n      privateKeyId: my-private-key-id\n      privateKey: ABCDEFGHIJKL\n      clientEmail: my_client_email\n      clientId: my_client_di\n      authUri: my_auth_uri\n      tokenUri: my_token_uri\n      authProviderX509CertUrl: my_auth_provider_x509_cert_url\n      clientX509CertUrl: my_client_x509_cert_url\n      retries: 3\n  # it is also possible to set the connection to use OAuth by filling in `application_id` and `application_secret`\n  myConnectionWithOauth:\n    type: dbtcloud:BigQueryConnection\n    name: my_connection_with_oauth\n    properties:\n      projectId: ${dbtProject.id}\n      name: Project Name\n      type: bigquery\n      isActive: true\n      gcpProjectId: my-gcp-project-id\n      timeoutSeconds: 100\n      privateKeyId: my-private-key-id\n      privateKey: ABCDEFGHIJKL\n      clientEmail: my_client_email\n      clientId: my_client_di\n      authUri: my_auth_uri\n      tokenUri: my_token_uri\n      authProviderX509CertUrl: my_auth_provider_x509_cert_url\n      clientX509CertUrl: my_client_x509_cert_url\n      retries: 3\n      applicationId: oauth_application_id\n      applicationSecret: oauth_secret_id\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_bigquery_connection.my_connection\n\n  id = \"project_id:connection_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_bigquery_connection.my_connection\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/bigQueryConnection:BigQueryConnection my_connection \"project_id:connection_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/bigQueryConnection:BigQueryConnection my_connection 12345:6789\n```\n\n",
            "properties": {
                "applicationId": {
                    "type": "string",
                    "description": "The Application ID for BQ OAuth\n",
                    "secret": true
                },
                "applicationSecret": {
                    "type": "string",
                    "description": "The Application Secret for BQ OAuth\n",
                    "secret": true
                },
                "authProviderX509CertUrl": {
                    "type": "string",
                    "description": "Auth Provider X509 Cert URL for the Service Account\n"
                },
                "authUri": {
                    "type": "string",
                    "description": "Auth URI for the Service Account\n"
                },
                "clientEmail": {
                    "type": "string",
                    "description": "Service Account email\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID of the Service Account\n"
                },
                "clientX509CertUrl": {
                    "type": "string",
                    "description": "Client X509 Cert URL for the Service Account\n"
                },
                "connectionId": {
                    "type": "integer",
                    "description": "Connection Identifier\n"
                },
                "dataprocClusterName": {
                    "type": "string",
                    "description": "Dataproc cluster name for PySpark workloads\n"
                },
                "dataprocRegion": {
                    "type": "string",
                    "description": "Google Cloud region for PySpark workloads on Dataproc\n"
                },
                "executionProject": {
                    "type": "string",
                    "description": "Project to bill for query execution\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID\n"
                },
                "gcsBucket": {
                    "type": "string",
                    "description": "URI for a Google Cloud Storage bucket to host Python code executed via Datapro\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the connection is active\n"
                },
                "isConfiguredForOauth": {
                    "type": "boolean",
                    "description": "Whether the connection is configured for OAuth or not\n"
                },
                "location": {
                    "type": "string",
                    "description": "Location to create new Datasets in\n"
                },
                "maximumBytesBilled": {
                    "type": "integer",
                    "description": "Max number of bytes that can be billed for a given BigQuery query\n"
                },
                "name": {
                    "type": "string",
                    "description": "Connection name\n"
                },
                "priority": {
                    "type": "string",
                    "description": "The priority with which to execute BigQuery queries (batch or interactive)\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private key of the Service Account\n",
                    "secret": true
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "Private key ID of the Service Account\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the connection in\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Number of retries for queries\n"
                },
                "timeoutSeconds": {
                    "type": "integer",
                    "description": "Timeout in seconds for queries\n"
                },
                "tokenUri": {
                    "type": "string",
                    "description": "Token URI for the Service Account\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of connection\n"
                }
            },
            "required": [
                "authProviderX509CertUrl",
                "authUri",
                "clientEmail",
                "clientId",
                "clientX509CertUrl",
                "connectionId",
                "gcpProjectId",
                "isConfiguredForOauth",
                "name",
                "privateKey",
                "privateKeyId",
                "projectId",
                "timeoutSeconds",
                "tokenUri",
                "type"
            ],
            "inputProperties": {
                "applicationId": {
                    "type": "string",
                    "description": "The Application ID for BQ OAuth\n",
                    "secret": true
                },
                "applicationSecret": {
                    "type": "string",
                    "description": "The Application Secret for BQ OAuth\n",
                    "secret": true
                },
                "authProviderX509CertUrl": {
                    "type": "string",
                    "description": "Auth Provider X509 Cert URL for the Service Account\n"
                },
                "authUri": {
                    "type": "string",
                    "description": "Auth URI for the Service Account\n"
                },
                "clientEmail": {
                    "type": "string",
                    "description": "Service Account email\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client ID of the Service Account\n"
                },
                "clientX509CertUrl": {
                    "type": "string",
                    "description": "Client X509 Cert URL for the Service Account\n"
                },
                "dataprocClusterName": {
                    "type": "string",
                    "description": "Dataproc cluster name for PySpark workloads\n"
                },
                "dataprocRegion": {
                    "type": "string",
                    "description": "Google Cloud region for PySpark workloads on Dataproc\n"
                },
                "executionProject": {
                    "type": "string",
                    "description": "Project to bill for query execution\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID\n"
                },
                "gcsBucket": {
                    "type": "string",
                    "description": "URI for a Google Cloud Storage bucket to host Python code executed via Datapro\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the connection is active\n"
                },
                "location": {
                    "type": "string",
                    "description": "Location to create new Datasets in\n"
                },
                "maximumBytesBilled": {
                    "type": "integer",
                    "description": "Max number of bytes that can be billed for a given BigQuery query\n"
                },
                "name": {
                    "type": "string",
                    "description": "Connection name\n"
                },
                "priority": {
                    "type": "string",
                    "description": "The priority with which to execute BigQuery queries (batch or interactive)\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private key of the Service Account\n",
                    "secret": true
                },
                "privateKeyId": {
                    "type": "string",
                    "description": "Private key ID of the Service Account\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the connection in\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Number of retries for queries\n"
                },
                "timeoutSeconds": {
                    "type": "integer",
                    "description": "Timeout in seconds for queries\n"
                },
                "tokenUri": {
                    "type": "string",
                    "description": "Token URI for the Service Account\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of connection\n"
                }
            },
            "requiredInputs": [
                "authProviderX509CertUrl",
                "authUri",
                "clientEmail",
                "clientId",
                "clientX509CertUrl",
                "gcpProjectId",
                "privateKey",
                "privateKeyId",
                "projectId",
                "timeoutSeconds",
                "tokenUri",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BigQueryConnection resources.\n",
                "properties": {
                    "applicationId": {
                        "type": "string",
                        "description": "The Application ID for BQ OAuth\n",
                        "secret": true
                    },
                    "applicationSecret": {
                        "type": "string",
                        "description": "The Application Secret for BQ OAuth\n",
                        "secret": true
                    },
                    "authProviderX509CertUrl": {
                        "type": "string",
                        "description": "Auth Provider X509 Cert URL for the Service Account\n"
                    },
                    "authUri": {
                        "type": "string",
                        "description": "Auth URI for the Service Account\n"
                    },
                    "clientEmail": {
                        "type": "string",
                        "description": "Service Account email\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "Client ID of the Service Account\n"
                    },
                    "clientX509CertUrl": {
                        "type": "string",
                        "description": "Client X509 Cert URL for the Service Account\n"
                    },
                    "connectionId": {
                        "type": "integer",
                        "description": "Connection Identifier\n"
                    },
                    "dataprocClusterName": {
                        "type": "string",
                        "description": "Dataproc cluster name for PySpark workloads\n"
                    },
                    "dataprocRegion": {
                        "type": "string",
                        "description": "Google Cloud region for PySpark workloads on Dataproc\n"
                    },
                    "executionProject": {
                        "type": "string",
                        "description": "Project to bill for query execution\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "GCP project ID\n"
                    },
                    "gcsBucket": {
                        "type": "string",
                        "description": "URI for a Google Cloud Storage bucket to host Python code executed via Datapro\n"
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Whether the connection is active\n"
                    },
                    "isConfiguredForOauth": {
                        "type": "boolean",
                        "description": "Whether the connection is configured for OAuth or not\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Location to create new Datasets in\n"
                    },
                    "maximumBytesBilled": {
                        "type": "integer",
                        "description": "Max number of bytes that can be billed for a given BigQuery query\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Connection name\n"
                    },
                    "priority": {
                        "type": "string",
                        "description": "The priority with which to execute BigQuery queries (batch or interactive)\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Private key of the Service Account\n",
                        "secret": true
                    },
                    "privateKeyId": {
                        "type": "string",
                        "description": "Private key ID of the Service Account\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the connection in\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "Number of retries for queries\n"
                    },
                    "timeoutSeconds": {
                        "type": "integer",
                        "description": "Timeout in seconds for queries\n"
                    },
                    "tokenUri": {
                        "type": "string",
                        "description": "Token URI for the Service Account\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of connection\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/bigQueryCredential:BigQueryCredential": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myCredential = new dbtcloud.BigQueryCredential(\"my_credential\", {\n    projectId: dbtProject.id,\n    dataset: \"my_bq_dataset\",\n    numThreads: 16,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_credential = dbtcloud.BigQueryCredential(\"my_credential\",\n    project_id=dbt_project[\"id\"],\n    dataset=\"my_bq_dataset\",\n    num_threads=16)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCredential = new DbtCloud.BigQueryCredential(\"my_credential\", new()\n    {\n        ProjectId = dbtProject.Id,\n        Dataset = \"my_bq_dataset\",\n        NumThreads = 16,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewBigQueryCredential(ctx, \"my_credential\", \u0026dbtcloud.BigQueryCredentialArgs{\n\t\t\tProjectId:  pulumi.Any(dbtProject.Id),\n\t\t\tDataset:    pulumi.String(\"my_bq_dataset\"),\n\t\t\tNumThreads: pulumi.Int(16),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.BigQueryCredential;\nimport com.pulumi.dbtcloud.BigQueryCredentialArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCredential = new BigQueryCredential(\"myCredential\", BigQueryCredentialArgs.builder()\n            .projectId(dbtProject.id())\n            .dataset(\"my_bq_dataset\")\n            .numThreads(16)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCredential:\n    type: dbtcloud:BigQueryCredential\n    name: my_credential\n    properties:\n      projectId: ${dbtProject.id}\n      dataset: my_bq_dataset\n      numThreads: 16\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_bigquery_credential.my_credential\n\n  id = \"project_id:credential_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_bigquery_credential.my_credential\n\n  id = \"12345:5678\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/bigQueryCredential:BigQueryCredential my_credential \"project_id:credential_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/bigQueryCredential:BigQueryCredential my_credential 12345:5678\n```\n\n",
            "properties": {
                "credentialId": {
                    "type": "integer",
                    "description": "The system BigQuery credential ID\n"
                },
                "dataset": {
                    "type": "string",
                    "description": "Default dataset name\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the BigQuery credential is active\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the BigQuery credential in\n"
                }
            },
            "required": [
                "credentialId",
                "dataset",
                "numThreads",
                "projectId"
            ],
            "inputProperties": {
                "dataset": {
                    "type": "string",
                    "description": "Default dataset name\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the BigQuery credential is active\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the BigQuery credential in\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "dataset",
                "numThreads",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BigQueryCredential resources.\n",
                "properties": {
                    "credentialId": {
                        "type": "integer",
                        "description": "The system BigQuery credential ID\n"
                    },
                    "dataset": {
                        "type": "string",
                        "description": "Default dataset name\n"
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Whether the BigQuery credential is active\n"
                    },
                    "numThreads": {
                        "type": "integer",
                        "description": "Number of threads to use\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the BigQuery credential in\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/connection:Connection": {
            "description": "Create a Data Warehouse connection for your project in dbt Cloud. The connection will need to be linked to the dbt Cloud project via a `dbtcloud.ProjectConnection` resource.\n\t\t\nThis resource can be used for Databricks, Postgres, Redshift, Snowflake and AlloyDB connections.\nFor BigQuery, due to the list of fields being very different, you can use the `dbtcloud.BigQueryConnection` resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst databricks = new dbtcloud.Connection(\"databricks\", {\n    projectId: dbtProject.id,\n    type: \"adapter\",\n    name: \"Databricks\",\n    database: \"\",\n    hostName: \"my-databricks-host.cloud.databricks.com\",\n    httpPath: \"/my/path\",\n    catalog: \"moo\",\n    oauthClientId: \"yourclientid\",\n    oauthClientSecret: \"yourclientsecret\",\n});\nconst redshift = new dbtcloud.Connection(\"redshift\", {\n    projectId: dbtProject.id,\n    type: \"redshift\",\n    name: \"My Redshift Warehouse\",\n    database: \"my-database\",\n    port: 5439,\n    hostName: \"my-redshift-hostname\",\n});\nconst snowflake = new dbtcloud.Connection(\"snowflake\", {\n    projectId: dbtProject.id,\n    type: \"snowflake\",\n    name: \"My Snowflake warehouse\",\n    account: \"my-snowflake-account\",\n    database: \"MY_DATABASE\",\n    role: \"MY_ROLE\",\n    warehouse: \"MY_WAREHOUSE\",\n    oauthClientId: \"yourclientid\",\n    oauthClientSecret: \"yourclientsecret\",\n    allowSso: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ndatabricks = dbtcloud.Connection(\"databricks\",\n    project_id=dbt_project[\"id\"],\n    type=\"adapter\",\n    name=\"Databricks\",\n    database=\"\",\n    host_name=\"my-databricks-host.cloud.databricks.com\",\n    http_path=\"/my/path\",\n    catalog=\"moo\",\n    oauth_client_id=\"yourclientid\",\n    oauth_client_secret=\"yourclientsecret\")\nredshift = dbtcloud.Connection(\"redshift\",\n    project_id=dbt_project[\"id\"],\n    type=\"redshift\",\n    name=\"My Redshift Warehouse\",\n    database=\"my-database\",\n    port=5439,\n    host_name=\"my-redshift-hostname\")\nsnowflake = dbtcloud.Connection(\"snowflake\",\n    project_id=dbt_project[\"id\"],\n    type=\"snowflake\",\n    name=\"My Snowflake warehouse\",\n    account=\"my-snowflake-account\",\n    database=\"MY_DATABASE\",\n    role=\"MY_ROLE\",\n    warehouse=\"MY_WAREHOUSE\",\n    oauth_client_id=\"yourclientid\",\n    oauth_client_secret=\"yourclientsecret\",\n    allow_sso=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var databricks = new DbtCloud.Connection(\"databricks\", new()\n    {\n        ProjectId = dbtProject.Id,\n        Type = \"adapter\",\n        Name = \"Databricks\",\n        Database = \"\",\n        HostName = \"my-databricks-host.cloud.databricks.com\",\n        HttpPath = \"/my/path\",\n        Catalog = \"moo\",\n        OauthClientId = \"yourclientid\",\n        OauthClientSecret = \"yourclientsecret\",\n    });\n\n    var redshift = new DbtCloud.Connection(\"redshift\", new()\n    {\n        ProjectId = dbtProject.Id,\n        Type = \"redshift\",\n        Name = \"My Redshift Warehouse\",\n        Database = \"my-database\",\n        Port = 5439,\n        HostName = \"my-redshift-hostname\",\n    });\n\n    var snowflake = new DbtCloud.Connection(\"snowflake\", new()\n    {\n        ProjectId = dbtProject.Id,\n        Type = \"snowflake\",\n        Name = \"My Snowflake warehouse\",\n        Account = \"my-snowflake-account\",\n        Database = \"MY_DATABASE\",\n        Role = \"MY_ROLE\",\n        Warehouse = \"MY_WAREHOUSE\",\n        OauthClientId = \"yourclientid\",\n        OauthClientSecret = \"yourclientsecret\",\n        AllowSso = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewConnection(ctx, \"databricks\", \u0026dbtcloud.ConnectionArgs{\n\t\t\tProjectId:         pulumi.Any(dbtProject.Id),\n\t\t\tType:              pulumi.String(\"adapter\"),\n\t\t\tName:              pulumi.String(\"Databricks\"),\n\t\t\tDatabase:          pulumi.String(\"\"),\n\t\t\tHostName:          pulumi.String(\"my-databricks-host.cloud.databricks.com\"),\n\t\t\tHttpPath:          pulumi.String(\"/my/path\"),\n\t\t\tCatalog:           pulumi.String(\"moo\"),\n\t\t\tOauthClientId:     pulumi.String(\"yourclientid\"),\n\t\t\tOauthClientSecret: pulumi.String(\"yourclientsecret\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbtcloud.NewConnection(ctx, \"redshift\", \u0026dbtcloud.ConnectionArgs{\n\t\t\tProjectId: pulumi.Any(dbtProject.Id),\n\t\t\tType:      pulumi.String(\"redshift\"),\n\t\t\tName:      pulumi.String(\"My Redshift Warehouse\"),\n\t\t\tDatabase:  pulumi.String(\"my-database\"),\n\t\t\tPort:      pulumi.Int(5439),\n\t\t\tHostName:  pulumi.String(\"my-redshift-hostname\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbtcloud.NewConnection(ctx, \"snowflake\", \u0026dbtcloud.ConnectionArgs{\n\t\t\tProjectId:         pulumi.Any(dbtProject.Id),\n\t\t\tType:              pulumi.String(\"snowflake\"),\n\t\t\tName:              pulumi.String(\"My Snowflake warehouse\"),\n\t\t\tAccount:           pulumi.String(\"my-snowflake-account\"),\n\t\t\tDatabase:          pulumi.String(\"MY_DATABASE\"),\n\t\t\tRole:              pulumi.String(\"MY_ROLE\"),\n\t\t\tWarehouse:         pulumi.String(\"MY_WAREHOUSE\"),\n\t\t\tOauthClientId:     pulumi.String(\"yourclientid\"),\n\t\t\tOauthClientSecret: pulumi.String(\"yourclientsecret\"),\n\t\t\tAllowSso:          pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.Connection;\nimport com.pulumi.dbtcloud.ConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var databricks = new Connection(\"databricks\", ConnectionArgs.builder()\n            .projectId(dbtProject.id())\n            .type(\"adapter\")\n            .name(\"Databricks\")\n            .database(\"\")\n            .hostName(\"my-databricks-host.cloud.databricks.com\")\n            .httpPath(\"/my/path\")\n            .catalog(\"moo\")\n            .oauthClientId(\"yourclientid\")\n            .oauthClientSecret(\"yourclientsecret\")\n            .build());\n\n        var redshift = new Connection(\"redshift\", ConnectionArgs.builder()\n            .projectId(dbtProject.id())\n            .type(\"redshift\")\n            .name(\"My Redshift Warehouse\")\n            .database(\"my-database\")\n            .port(5439)\n            .hostName(\"my-redshift-hostname\")\n            .build());\n\n        var snowflake = new Connection(\"snowflake\", ConnectionArgs.builder()\n            .projectId(dbtProject.id())\n            .type(\"snowflake\")\n            .name(\"My Snowflake warehouse\")\n            .account(\"my-snowflake-account\")\n            .database(\"MY_DATABASE\")\n            .role(\"MY_ROLE\")\n            .warehouse(\"MY_WAREHOUSE\")\n            .oauthClientId(\"yourclientid\")\n            .oauthClientSecret(\"yourclientsecret\")\n            .allowSso(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  databricks:\n    type: dbtcloud:Connection\n    properties:\n      projectId: ${dbtProject.id}\n      type: adapter\n      name: Databricks\n      database:\n      hostName: my-databricks-host.cloud.databricks.com\n      httpPath: /my/path\n      catalog: moo\n      oauthClientId: yourclientid\n      oauthClientSecret: yourclientsecret\n  redshift:\n    type: dbtcloud:Connection\n    properties:\n      projectId: ${dbtProject.id}\n      type: redshift\n      name: My Redshift Warehouse\n      database: my-database\n      port: 5439\n      hostName: my-redshift-hostname\n  snowflake:\n    type: dbtcloud:Connection\n    properties:\n      projectId: ${dbtProject.id}\n      type: snowflake\n      name: My Snowflake warehouse\n      account: my-snowflake-account\n      database: MY_DATABASE\n      role: MY_ROLE\n      warehouse: MY_WAREHOUSE\n      oauthClientId: yourclientid\n      oauthClientSecret: yourclientsecret\n      allowSso: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_connection.test_connection\n\n  id = \"project_id:connection_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_connection.test_connection\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/connection:Connection test_connection \"project_id:connection_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/connection:Connection test_connection 12345:6789\n```\n\n",
            "properties": {
                "account": {
                    "type": "string",
                    "description": "Account name for the connection (for Snowflake)\n"
                },
                "adapterId": {
                    "type": "integer",
                    "description": "Adapter id created for the Databricks connection (for Databricks)\n"
                },
                "allowKeepAlive": {
                    "type": "boolean",
                    "description": "Whether or not the connection should allow client session keep alive (for Snowflake)\n"
                },
                "allowSso": {
                    "type": "boolean",
                    "description": "Whether or not the connection should allow SSO (for Snowflake)\n"
                },
                "catalog": {
                    "type": "string",
                    "description": "Catalog name if Unity Catalog is enabled in your Databricks workspace (for Databricks)\n"
                },
                "connectionId": {
                    "type": "integer",
                    "description": "Connection Identifier\n"
                },
                "database": {
                    "type": "string",
                    "description": "Database name for the connection\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "Host name for the connection, including Databricks cluster\n"
                },
                "httpPath": {
                    "type": "string",
                    "description": "The HTTP path of the Databricks cluster or SQL warehouse (for Databricks)\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the connection is active\n"
                },
                "name": {
                    "type": "string",
                    "description": "Connection name\n"
                },
                "oauthClientId": {
                    "type": "string",
                    "description": "OAuth client identifier (for Snowflake and Databricks)\n"
                },
                "oauthClientSecret": {
                    "type": "string",
                    "description": "OAuth client secret (for Snowflake and Databricks)\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect via\n"
                },
                "privateLinkEndpointId": {
                    "type": "string",
                    "description": "The ID of the PrivateLink connection. This ID can be found using the `privatelink_endpoint` data source\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the connection in\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role name for the connection (for Snowflake)\n"
                },
                "tunnelEnabled": {
                    "type": "boolean",
                    "description": "Whether or not tunneling should be enabled on your database connection\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of connection\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "Warehouse name for the connection (for Snowflake)\n"
                }
            },
            "required": [
                "adapterId",
                "connectionId",
                "database",
                "name",
                "projectId",
                "type"
            ],
            "inputProperties": {
                "account": {
                    "type": "string",
                    "description": "Account name for the connection (for Snowflake)\n"
                },
                "allowKeepAlive": {
                    "type": "boolean",
                    "description": "Whether or not the connection should allow client session keep alive (for Snowflake)\n"
                },
                "allowSso": {
                    "type": "boolean",
                    "description": "Whether or not the connection should allow SSO (for Snowflake)\n"
                },
                "catalog": {
                    "type": "string",
                    "description": "Catalog name if Unity Catalog is enabled in your Databricks workspace (for Databricks)\n"
                },
                "database": {
                    "type": "string",
                    "description": "Database name for the connection\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "Host name for the connection, including Databricks cluster\n"
                },
                "httpPath": {
                    "type": "string",
                    "description": "The HTTP path of the Databricks cluster or SQL warehouse (for Databricks)\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the connection is active\n"
                },
                "name": {
                    "type": "string",
                    "description": "Connection name\n"
                },
                "oauthClientId": {
                    "type": "string",
                    "description": "OAuth client identifier (for Snowflake and Databricks)\n"
                },
                "oauthClientSecret": {
                    "type": "string",
                    "description": "OAuth client secret (for Snowflake and Databricks)\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number to connect via\n"
                },
                "privateLinkEndpointId": {
                    "type": "string",
                    "description": "The ID of the PrivateLink connection. This ID can be found using the `privatelink_endpoint` data source\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the connection in\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role name for the connection (for Snowflake)\n"
                },
                "tunnelEnabled": {
                    "type": "boolean",
                    "description": "Whether or not tunneling should be enabled on your database connection\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of connection\n",
                    "willReplaceOnChanges": true
                },
                "warehouse": {
                    "type": "string",
                    "description": "Warehouse name for the connection (for Snowflake)\n"
                }
            },
            "requiredInputs": [
                "database",
                "projectId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Connection resources.\n",
                "properties": {
                    "account": {
                        "type": "string",
                        "description": "Account name for the connection (for Snowflake)\n"
                    },
                    "adapterId": {
                        "type": "integer",
                        "description": "Adapter id created for the Databricks connection (for Databricks)\n"
                    },
                    "allowKeepAlive": {
                        "type": "boolean",
                        "description": "Whether or not the connection should allow client session keep alive (for Snowflake)\n"
                    },
                    "allowSso": {
                        "type": "boolean",
                        "description": "Whether or not the connection should allow SSO (for Snowflake)\n"
                    },
                    "catalog": {
                        "type": "string",
                        "description": "Catalog name if Unity Catalog is enabled in your Databricks workspace (for Databricks)\n"
                    },
                    "connectionId": {
                        "type": "integer",
                        "description": "Connection Identifier\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Database name for the connection\n"
                    },
                    "hostName": {
                        "type": "string",
                        "description": "Host name for the connection, including Databricks cluster\n"
                    },
                    "httpPath": {
                        "type": "string",
                        "description": "The HTTP path of the Databricks cluster or SQL warehouse (for Databricks)\n"
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Whether the connection is active\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Connection name\n"
                    },
                    "oauthClientId": {
                        "type": "string",
                        "description": "OAuth client identifier (for Snowflake and Databricks)\n"
                    },
                    "oauthClientSecret": {
                        "type": "string",
                        "description": "OAuth client secret (for Snowflake and Databricks)\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port number to connect via\n"
                    },
                    "privateLinkEndpointId": {
                        "type": "string",
                        "description": "The ID of the PrivateLink connection. This ID can be found using the `privatelink_endpoint` data source\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the connection in\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role name for the connection (for Snowflake)\n"
                    },
                    "tunnelEnabled": {
                        "type": "boolean",
                        "description": "Whether or not tunneling should be enabled on your database connection\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of connection\n",
                        "willReplaceOnChanges": true
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "Warehouse name for the connection (for Snowflake)\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/databricksCredential:DatabricksCredential": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// when using the Databricks adapter\nconst myDatabricksCred = new dbtcloud.DatabricksCredential(\"my_databricks_cred\", {\n    projectId: dbtProject.id,\n    adapterId: myDatabricksConnection.adapterId,\n    targetName: \"prod\",\n    token: \"abcdefgh\",\n    schema: \"my_schema\",\n    adapterType: \"databricks\",\n});\n// when using the Spark adapter\nconst mySparkCred = new dbtcloud.DatabricksCredential(\"my_spark_cred\", {\n    projectId: dbtProject.id,\n    adapterId: myDatabricksConnection.adapterId,\n    targetName: \"prod\",\n    token: \"abcdefgh\",\n    schema: \"my_schema\",\n    adapterType: \"spark\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# when using the Databricks adapter\nmy_databricks_cred = dbtcloud.DatabricksCredential(\"my_databricks_cred\",\n    project_id=dbt_project[\"id\"],\n    adapter_id=my_databricks_connection[\"adapterId\"],\n    target_name=\"prod\",\n    token=\"abcdefgh\",\n    schema=\"my_schema\",\n    adapter_type=\"databricks\")\n# when using the Spark adapter\nmy_spark_cred = dbtcloud.DatabricksCredential(\"my_spark_cred\",\n    project_id=dbt_project[\"id\"],\n    adapter_id=my_databricks_connection[\"adapterId\"],\n    target_name=\"prod\",\n    token=\"abcdefgh\",\n    schema=\"my_schema\",\n    adapter_type=\"spark\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // when using the Databricks adapter\n    var myDatabricksCred = new DbtCloud.DatabricksCredential(\"my_databricks_cred\", new()\n    {\n        ProjectId = dbtProject.Id,\n        AdapterId = myDatabricksConnection.AdapterId,\n        TargetName = \"prod\",\n        Token = \"abcdefgh\",\n        Schema = \"my_schema\",\n        AdapterType = \"databricks\",\n    });\n\n    // when using the Spark adapter\n    var mySparkCred = new DbtCloud.DatabricksCredential(\"my_spark_cred\", new()\n    {\n        ProjectId = dbtProject.Id,\n        AdapterId = myDatabricksConnection.AdapterId,\n        TargetName = \"prod\",\n        Token = \"abcdefgh\",\n        Schema = \"my_schema\",\n        AdapterType = \"spark\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// when using the Databricks adapter\n\t\t_, err := dbtcloud.NewDatabricksCredential(ctx, \"my_databricks_cred\", \u0026dbtcloud.DatabricksCredentialArgs{\n\t\t\tProjectId:   pulumi.Any(dbtProject.Id),\n\t\t\tAdapterId:   pulumi.Any(myDatabricksConnection.AdapterId),\n\t\t\tTargetName:  pulumi.String(\"prod\"),\n\t\t\tToken:       pulumi.String(\"abcdefgh\"),\n\t\t\tSchema:      pulumi.String(\"my_schema\"),\n\t\t\tAdapterType: pulumi.String(\"databricks\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// when using the Spark adapter\n\t\t_, err = dbtcloud.NewDatabricksCredential(ctx, \"my_spark_cred\", \u0026dbtcloud.DatabricksCredentialArgs{\n\t\t\tProjectId:   pulumi.Any(dbtProject.Id),\n\t\t\tAdapterId:   pulumi.Any(myDatabricksConnection.AdapterId),\n\t\t\tTargetName:  pulumi.String(\"prod\"),\n\t\t\tToken:       pulumi.String(\"abcdefgh\"),\n\t\t\tSchema:      pulumi.String(\"my_schema\"),\n\t\t\tAdapterType: pulumi.String(\"spark\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DatabricksCredential;\nimport com.pulumi.dbtcloud.DatabricksCredentialArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // when using the Databricks adapter\n        var myDatabricksCred = new DatabricksCredential(\"myDatabricksCred\", DatabricksCredentialArgs.builder()\n            .projectId(dbtProject.id())\n            .adapterId(myDatabricksConnection.adapterId())\n            .targetName(\"prod\")\n            .token(\"abcdefgh\")\n            .schema(\"my_schema\")\n            .adapterType(\"databricks\")\n            .build());\n\n        // when using the Spark adapter\n        var mySparkCred = new DatabricksCredential(\"mySparkCred\", DatabricksCredentialArgs.builder()\n            .projectId(dbtProject.id())\n            .adapterId(myDatabricksConnection.adapterId())\n            .targetName(\"prod\")\n            .token(\"abcdefgh\")\n            .schema(\"my_schema\")\n            .adapterType(\"spark\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # when using the Databricks adapter\n  myDatabricksCred:\n    type: dbtcloud:DatabricksCredential\n    name: my_databricks_cred\n    properties:\n      projectId: ${dbtProject.id}\n      adapterId: ${myDatabricksConnection.adapterId}\n      targetName: prod\n      token: abcdefgh\n      schema: my_schema\n      adapterType: databricks\n  # when using the Spark adapter\n  mySparkCred:\n    type: dbtcloud:DatabricksCredential\n    name: my_spark_cred\n    properties:\n      projectId: ${dbtProject.id}\n      adapterId: ${myDatabricksConnection.adapterId}\n      targetName: prod\n      token: abcdefgh\n      schema: my_schema\n      adapterType: spark\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_databricks_credential.my_databricks_credential\n\n  id = \"project_id:credential_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_databricks_credential.my_databricks_credential\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/databricksCredential:DatabricksCredential my_databricks_credential \"project_id:credential_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/databricksCredential:DatabricksCredential my_databricks_credential 12345:6789\n```\n\n",
            "properties": {
                "adapterId": {
                    "type": "integer",
                    "description": "Databricks adapter ID for the credential\n"
                },
                "adapterType": {
                    "type": "string",
                    "description": "The type of the adapter (databricks or spark)\n"
                },
                "catalog": {
                    "type": "string",
                    "description": "The catalog where to create models (only for the databricks adapter)\n"
                },
                "credentialId": {
                    "type": "integer",
                    "description": "The system Databricks credential ID\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Databricks credential in\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema where to create models\n"
                },
                "targetName": {
                    "type": "string",
                    "description": "Target name\n"
                },
                "token": {
                    "type": "string",
                    "description": "Token for Databricks user\n",
                    "secret": true
                }
            },
            "required": [
                "adapterId",
                "adapterType",
                "credentialId",
                "projectId",
                "schema",
                "token"
            ],
            "inputProperties": {
                "adapterId": {
                    "type": "integer",
                    "description": "Databricks adapter ID for the credential\n"
                },
                "adapterType": {
                    "type": "string",
                    "description": "The type of the adapter (databricks or spark)\n"
                },
                "catalog": {
                    "type": "string",
                    "description": "The catalog where to create models (only for the databricks adapter)\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Databricks credential in\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema where to create models\n"
                },
                "targetName": {
                    "type": "string",
                    "description": "Target name\n"
                },
                "token": {
                    "type": "string",
                    "description": "Token for Databricks user\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "adapterId",
                "adapterType",
                "projectId",
                "schema",
                "token"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatabricksCredential resources.\n",
                "properties": {
                    "adapterId": {
                        "type": "integer",
                        "description": "Databricks adapter ID for the credential\n"
                    },
                    "adapterType": {
                        "type": "string",
                        "description": "The type of the adapter (databricks or spark)\n"
                    },
                    "catalog": {
                        "type": "string",
                        "description": "The catalog where to create models (only for the databricks adapter)\n"
                    },
                    "credentialId": {
                        "type": "integer",
                        "description": "The system Databricks credential ID\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the Databricks credential in\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema where to create models\n"
                    },
                    "targetName": {
                        "type": "string",
                        "description": "Target name\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "Token for Databricks user\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/environment:Environment": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst ciEnvironment = new dbtcloud.Environment(\"ci_environment\", {\n    dbtVersion: \"versionless\",\n    name: \"CI\",\n    projectId: dbtProject.id,\n    type: \"deployment\",\n    credentialId: ciCredential.credentialId,\n});\n// we can also set a deployment environment as being the production one\nconst prodEnvironment = new dbtcloud.Environment(\"prod_environment\", {\n    dbtVersion: \"1.7.0-latest\",\n    name: \"Prod\",\n    projectId: dbtProject.id,\n    type: \"deployment\",\n    credentialId: prodCredential.credentialId,\n    deploymentType: \"production\",\n});\n// Creating a development environment\nconst devEnvironment = new dbtcloud.Environment(\"dev_environment\", {\n    dbtVersion: \"versionless\",\n    name: \"Dev\",\n    projectId: dbtProject.id,\n    type: \"development\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nci_environment = dbtcloud.Environment(\"ci_environment\",\n    dbt_version=\"versionless\",\n    name=\"CI\",\n    project_id=dbt_project[\"id\"],\n    type=\"deployment\",\n    credential_id=ci_credential[\"credentialId\"])\n# we can also set a deployment environment as being the production one\nprod_environment = dbtcloud.Environment(\"prod_environment\",\n    dbt_version=\"1.7.0-latest\",\n    name=\"Prod\",\n    project_id=dbt_project[\"id\"],\n    type=\"deployment\",\n    credential_id=prod_credential[\"credentialId\"],\n    deployment_type=\"production\")\n# Creating a development environment\ndev_environment = dbtcloud.Environment(\"dev_environment\",\n    dbt_version=\"versionless\",\n    name=\"Dev\",\n    project_id=dbt_project[\"id\"],\n    type=\"development\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ciEnvironment = new DbtCloud.Environment(\"ci_environment\", new()\n    {\n        DbtVersion = \"versionless\",\n        Name = \"CI\",\n        ProjectId = dbtProject.Id,\n        Type = \"deployment\",\n        CredentialId = ciCredential.CredentialId,\n    });\n\n    // we can also set a deployment environment as being the production one\n    var prodEnvironment = new DbtCloud.Environment(\"prod_environment\", new()\n    {\n        DbtVersion = \"1.7.0-latest\",\n        Name = \"Prod\",\n        ProjectId = dbtProject.Id,\n        Type = \"deployment\",\n        CredentialId = prodCredential.CredentialId,\n        DeploymentType = \"production\",\n    });\n\n    // Creating a development environment\n    var devEnvironment = new DbtCloud.Environment(\"dev_environment\", new()\n    {\n        DbtVersion = \"versionless\",\n        Name = \"Dev\",\n        ProjectId = dbtProject.Id,\n        Type = \"development\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewEnvironment(ctx, \"ci_environment\", \u0026dbtcloud.EnvironmentArgs{\n\t\t\tDbtVersion:   pulumi.String(\"versionless\"),\n\t\t\tName:         pulumi.String(\"CI\"),\n\t\t\tProjectId:    pulumi.Any(dbtProject.Id),\n\t\t\tType:         pulumi.String(\"deployment\"),\n\t\t\tCredentialId: pulumi.Any(ciCredential.CredentialId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// we can also set a deployment environment as being the production one\n\t\t_, err = dbtcloud.NewEnvironment(ctx, \"prod_environment\", \u0026dbtcloud.EnvironmentArgs{\n\t\t\tDbtVersion:     pulumi.String(\"1.7.0-latest\"),\n\t\t\tName:           pulumi.String(\"Prod\"),\n\t\t\tProjectId:      pulumi.Any(dbtProject.Id),\n\t\t\tType:           pulumi.String(\"deployment\"),\n\t\t\tCredentialId:   pulumi.Any(prodCredential.CredentialId),\n\t\t\tDeploymentType: pulumi.String(\"production\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Creating a development environment\n\t\t_, err = dbtcloud.NewEnvironment(ctx, \"dev_environment\", \u0026dbtcloud.EnvironmentArgs{\n\t\t\tDbtVersion: pulumi.String(\"versionless\"),\n\t\t\tName:       pulumi.String(\"Dev\"),\n\t\t\tProjectId:  pulumi.Any(dbtProject.Id),\n\t\t\tType:       pulumi.String(\"development\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.Environment;\nimport com.pulumi.dbtcloud.EnvironmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ciEnvironment = new Environment(\"ciEnvironment\", EnvironmentArgs.builder()\n            .dbtVersion(\"versionless\")\n            .name(\"CI\")\n            .projectId(dbtProject.id())\n            .type(\"deployment\")\n            .credentialId(ciCredential.credentialId())\n            .build());\n\n        // we can also set a deployment environment as being the production one\n        var prodEnvironment = new Environment(\"prodEnvironment\", EnvironmentArgs.builder()\n            .dbtVersion(\"1.7.0-latest\")\n            .name(\"Prod\")\n            .projectId(dbtProject.id())\n            .type(\"deployment\")\n            .credentialId(prodCredential.credentialId())\n            .deploymentType(\"production\")\n            .build());\n\n        // Creating a development environment\n        var devEnvironment = new Environment(\"devEnvironment\", EnvironmentArgs.builder()\n            .dbtVersion(\"versionless\")\n            .name(\"Dev\")\n            .projectId(dbtProject.id())\n            .type(\"development\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ciEnvironment:\n    type: dbtcloud:Environment\n    name: ci_environment\n    properties:\n      dbtVersion: versionless\n      name: CI\n      projectId: ${dbtProject.id}\n      type: deployment\n      credentialId: ${ciCredential.credentialId}\n  # we can also set a deployment environment as being the production one\n  prodEnvironment:\n    type: dbtcloud:Environment\n    name: prod_environment\n    properties:\n      dbtVersion: 1.7.0-latest\n      name: Prod\n      projectId: ${dbtProject.id}\n      type: deployment\n      credentialId: ${prodCredential.credentialId}\n      deploymentType: production\n  # Creating a development environment\n  devEnvironment:\n    type: dbtcloud:Environment\n    name: dev_environment\n    properties:\n      dbtVersion: versionless\n      name: Dev\n      projectId: ${dbtProject.id}\n      type: development\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_environment.prod_environment\n\n  id = \"project_id:environment_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_environment.prod_environment\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/environment:Environment prod_environment \"project_id:environment_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/environment:Environment prod_environment 12345:6789\n```\n\n",
            "properties": {
                "credentialId": {
                    "type": "integer",
                    "description": "Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments\n"
                },
                "customBranch": {
                    "type": "string",
                    "description": "Which custom branch to use in this environment\n"
                },
                "dbtVersion": {
                    "type": "string",
                    "description": "Version number of dbt to use in this environment. It needs to be in the format `major.minor.0-latest` (e.g. `1.5.0-latest`), `major.minor.0-pre` or `versionless`. In a future version of the provider `versionless` will be the default if no version is provided\n"
                },
                "deploymentType": {
                    "type": "string",
                    "description": "The type of environment. Only valid for environments of type 'deployment' and for now can only be empty or set to 'production'\n"
                },
                "environmentId": {
                    "type": "integer",
                    "description": "Environment ID within the project\n"
                },
                "extendedAttributesId": {
                    "type": "integer",
                    "description": "ID of the extended attributes for the environment\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the environment is active\n"
                },
                "name": {
                    "type": "string",
                    "description": "Environment name\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the environment in\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of environment (must be either development or deployment)\n"
                },
                "useCustomBranch": {
                    "type": "boolean",
                    "description": "Whether to use a custom git branch in this environment\n"
                }
            },
            "required": [
                "dbtVersion",
                "environmentId",
                "name",
                "projectId",
                "type"
            ],
            "inputProperties": {
                "credentialId": {
                    "type": "integer",
                    "description": "Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments\n"
                },
                "customBranch": {
                    "type": "string",
                    "description": "Which custom branch to use in this environment\n"
                },
                "dbtVersion": {
                    "type": "string",
                    "description": "Version number of dbt to use in this environment. It needs to be in the format `major.minor.0-latest` (e.g. `1.5.0-latest`), `major.minor.0-pre` or `versionless`. In a future version of the provider `versionless` will be the default if no version is provided\n"
                },
                "deploymentType": {
                    "type": "string",
                    "description": "The type of environment. Only valid for environments of type 'deployment' and for now can only be empty or set to 'production'\n"
                },
                "extendedAttributesId": {
                    "type": "integer",
                    "description": "ID of the extended attributes for the environment\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the environment is active\n"
                },
                "name": {
                    "type": "string",
                    "description": "Environment name\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the environment in\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of environment (must be either development or deployment)\n",
                    "willReplaceOnChanges": true
                },
                "useCustomBranch": {
                    "type": "boolean",
                    "description": "Whether to use a custom git branch in this environment\n"
                }
            },
            "requiredInputs": [
                "dbtVersion",
                "projectId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Environment resources.\n",
                "properties": {
                    "credentialId": {
                        "type": "integer",
                        "description": "Credential ID to create the environment with. A credential is not required for development environments but is required for deployment environments\n"
                    },
                    "customBranch": {
                        "type": "string",
                        "description": "Which custom branch to use in this environment\n"
                    },
                    "dbtVersion": {
                        "type": "string",
                        "description": "Version number of dbt to use in this environment. It needs to be in the format `major.minor.0-latest` (e.g. `1.5.0-latest`), `major.minor.0-pre` or `versionless`. In a future version of the provider `versionless` will be the default if no version is provided\n"
                    },
                    "deploymentType": {
                        "type": "string",
                        "description": "The type of environment. Only valid for environments of type 'deployment' and for now can only be empty or set to 'production'\n"
                    },
                    "environmentId": {
                        "type": "integer",
                        "description": "Environment ID within the project\n"
                    },
                    "extendedAttributesId": {
                        "type": "integer",
                        "description": "ID of the extended attributes for the environment\n"
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Whether the environment is active\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Environment name\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the environment in\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of environment (must be either development or deployment)\n",
                        "willReplaceOnChanges": true
                    },
                    "useCustomBranch": {
                        "type": "boolean",
                        "description": "Whether to use a custom git branch in this environment\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/environmentVariable:EnvironmentVariable": {
            "description": "*Note*: Some upstream resources can be slow to create, so if creating a project or environment at\nthe same time as the environment variables, it's recommended to use the `depends_on` meta argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst dbtMyEnvVar = new dbtcloud.EnvironmentVariable(\"dbt_my_env_var\", {\n    name: \"DBT_MY_ENV_VAR\",\n    projectId: dbtProject.id,\n    environmentValues: {\n        project: \"my_project_level_value\",\n        Dev: \"my_env_level_value\",\n        CI: \"my_ci_override_value\",\n        Prod: \"my_prod_override_value\",\n    },\n}, {\n    dependsOn: [\n        dbtProject,\n        devEnv,\n        ciEnv,\n        prodEnv,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ndbt_my_env_var = dbtcloud.EnvironmentVariable(\"dbt_my_env_var\",\n    name=\"DBT_MY_ENV_VAR\",\n    project_id=dbt_project[\"id\"],\n    environment_values={\n        \"project\": \"my_project_level_value\",\n        \"Dev\": \"my_env_level_value\",\n        \"CI\": \"my_ci_override_value\",\n        \"Prod\": \"my_prod_override_value\",\n    },\n    opts=pulumi.ResourceOptions(depends_on=[\n            dbt_project,\n            dev_env,\n            ci_env,\n            prod_env,\n        ]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dbtMyEnvVar = new DbtCloud.EnvironmentVariable(\"dbt_my_env_var\", new()\n    {\n        Name = \"DBT_MY_ENV_VAR\",\n        ProjectId = dbtProject.Id,\n        EnvironmentValues = \n        {\n            { \"project\", \"my_project_level_value\" },\n            { \"Dev\", \"my_env_level_value\" },\n            { \"CI\", \"my_ci_override_value\" },\n            { \"Prod\", \"my_prod_override_value\" },\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            dbtProject,\n            devEnv,\n            ciEnv,\n            prodEnv,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewEnvironmentVariable(ctx, \"dbt_my_env_var\", \u0026dbtcloud.EnvironmentVariableArgs{\n\t\t\tName:      pulumi.String(\"DBT_MY_ENV_VAR\"),\n\t\t\tProjectId: pulumi.Any(dbtProject.Id),\n\t\t\tEnvironmentValues: pulumi.Map{\n\t\t\t\t\"project\": pulumi.Any(\"my_project_level_value\"),\n\t\t\t\t\"Dev\":     pulumi.Any(\"my_env_level_value\"),\n\t\t\t\t\"CI\":      pulumi.Any(\"my_ci_override_value\"),\n\t\t\t\t\"Prod\":    pulumi.Any(\"my_prod_override_value\"),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tdbtProject,\n\t\t\tdevEnv,\n\t\t\tciEnv,\n\t\t\tprodEnv,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.EnvironmentVariable;\nimport com.pulumi.dbtcloud.EnvironmentVariableArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dbtMyEnvVar = new EnvironmentVariable(\"dbtMyEnvVar\", EnvironmentVariableArgs.builder()\n            .name(\"DBT_MY_ENV_VAR\")\n            .projectId(dbtProject.id())\n            .environmentValues(Map.ofEntries(\n                Map.entry(\"project\", \"my_project_level_value\"),\n                Map.entry(\"Dev\", \"my_env_level_value\"),\n                Map.entry(\"CI\", \"my_ci_override_value\"),\n                Map.entry(\"Prod\", \"my_prod_override_value\")\n            ))\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(                \n                    dbtProject,\n                    devEnv,\n                    ciEnv,\n                    prodEnv)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dbtMyEnvVar:\n    type: dbtcloud:EnvironmentVariable\n    name: dbt_my_env_var\n    properties:\n      name: DBT_MY_ENV_VAR\n      projectId: ${dbtProject.id}\n      environmentValues:\n        project: my_project_level_value\n        Dev: my_env_level_value\n        CI: my_ci_override_value\n        Prod: my_prod_override_value\n    options:\n      dependson:\n        - ${dbtProject}\n        - ${devEnv}\n        - ${ciEnv}\n        - ${prodEnv}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_environment_variable.test_environment_variable\n\n  id = \"project_id:environment_variable_name\"\n\n}\n\nimport {\n\n  to = dbtcloud_environment_variable.test_environment_variable\n\n  id = \"12345:DBT_ENV_VAR\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/environmentVariable:EnvironmentVariable test_environment_variable \"project_id:environment_variable_name\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/environmentVariable:EnvironmentVariable test_environment_variable 12345:DBT_ENV_VAR\n```\n\n",
            "properties": {
                "environmentValues": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Map from environment names to respective variable value, a special key `project` should be set for the project default variable value. This field is not set as sensitive so take precautions when using secret environment variables.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for the variable, must be unique within a project, must be prefixed with 'DBT_'\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project for the variable to be created in\n"
                }
            },
            "required": [
                "environmentValues",
                "name",
                "projectId"
            ],
            "inputProperties": {
                "environmentValues": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Map from environment names to respective variable value, a special key `project` should be set for the project default variable value. This field is not set as sensitive so take precautions when using secret environment variables.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name for the variable, must be unique within a project, must be prefixed with 'DBT_'\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project for the variable to be created in\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "environmentValues",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EnvironmentVariable resources.\n",
                "properties": {
                    "environmentValues": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Map from environment names to respective variable value, a special key `project` should be set for the project default variable value. This field is not set as sensitive so take precautions when using secret environment variables.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name for the variable, must be unique within a project, must be prefixed with 'DBT_'\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project for the variable to be created in\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/environmentVariableJobOverride:EnvironmentVariableJobOverride": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myEnvVarJobOverride = new dbtcloud.EnvironmentVariableJobOverride(\"my_env_var_job_override\", {\n    name: dbtMyEnvVar.name,\n    projectId: dbtProject.id,\n    jobDefinitionId: dailyJob.id,\n    rawValue: \"my_override_value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_env_var_job_override = dbtcloud.EnvironmentVariableJobOverride(\"my_env_var_job_override\",\n    name=dbt_my_env_var[\"name\"],\n    project_id=dbt_project[\"id\"],\n    job_definition_id=daily_job[\"id\"],\n    raw_value=\"my_override_value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myEnvVarJobOverride = new DbtCloud.EnvironmentVariableJobOverride(\"my_env_var_job_override\", new()\n    {\n        Name = dbtMyEnvVar.Name,\n        ProjectId = dbtProject.Id,\n        JobDefinitionId = dailyJob.Id,\n        RawValue = \"my_override_value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewEnvironmentVariableJobOverride(ctx, \"my_env_var_job_override\", \u0026dbtcloud.EnvironmentVariableJobOverrideArgs{\n\t\t\tName:            pulumi.Any(dbtMyEnvVar.Name),\n\t\t\tProjectId:       pulumi.Any(dbtProject.Id),\n\t\t\tJobDefinitionId: pulumi.Any(dailyJob.Id),\n\t\t\tRawValue:        pulumi.String(\"my_override_value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.EnvironmentVariableJobOverride;\nimport com.pulumi.dbtcloud.EnvironmentVariableJobOverrideArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myEnvVarJobOverride = new EnvironmentVariableJobOverride(\"myEnvVarJobOverride\", EnvironmentVariableJobOverrideArgs.builder()\n            .name(dbtMyEnvVar.name())\n            .projectId(dbtProject.id())\n            .jobDefinitionId(dailyJob.id())\n            .rawValue(\"my_override_value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myEnvVarJobOverride:\n    type: dbtcloud:EnvironmentVariableJobOverride\n    name: my_env_var_job_override\n    properties:\n      name: ${dbtMyEnvVar.name}\n      projectId: ${dbtProject.id}\n      jobDefinitionId: ${dailyJob.id}\n      rawValue: my_override_value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_environment_variable_job_override.test_environment_variable_job_override\n\n  id = \"project_id:job_id:environment_variable_override_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_environment_variable_job_override.test_environment_variable_job_override\n\n  id = \"12345:678:123456\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/environmentVariableJobOverride:EnvironmentVariableJobOverride test_environment_variable_job_override \"project_id:job_id:environment_variable_override_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/environmentVariableJobOverride:EnvironmentVariableJobOverride test_environment_variable_job_override 12345:678:123456\n```\n\n",
            "properties": {
                "environmentVariableJobOverrideId": {
                    "type": "integer",
                    "description": "The ID of the environment variable job override\n"
                },
                "jobDefinitionId": {
                    "type": "integer",
                    "description": "The job ID for which the environment variable is being overridden\n"
                },
                "name": {
                    "type": "string",
                    "description": "The environment variable name to override\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The project ID for which the environment variable is being overridden\n"
                },
                "rawValue": {
                    "type": "string",
                    "description": "The value for the override of the environment variable\n"
                }
            },
            "required": [
                "environmentVariableJobOverrideId",
                "jobDefinitionId",
                "name",
                "projectId",
                "rawValue"
            ],
            "inputProperties": {
                "jobDefinitionId": {
                    "type": "integer",
                    "description": "The job ID for which the environment variable is being overridden\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The environment variable name to override\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "The project ID for which the environment variable is being overridden\n",
                    "willReplaceOnChanges": true
                },
                "rawValue": {
                    "type": "string",
                    "description": "The value for the override of the environment variable\n"
                }
            },
            "requiredInputs": [
                "jobDefinitionId",
                "projectId",
                "rawValue"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EnvironmentVariableJobOverride resources.\n",
                "properties": {
                    "environmentVariableJobOverrideId": {
                        "type": "integer",
                        "description": "The ID of the environment variable job override\n"
                    },
                    "jobDefinitionId": {
                        "type": "integer",
                        "description": "The job ID for which the environment variable is being overridden\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The environment variable name to override\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The project ID for which the environment variable is being overridden\n",
                        "willReplaceOnChanges": true
                    },
                    "rawValue": {
                        "type": "string",
                        "description": "The value for the override of the environment variable\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/extendedAttributes:ExtendedAttributes": {
            "description": "This resource allows setting extended attributes which can be assigned to a given environment ([see docs](https://docs.getdbt.com/docs/dbt-cloud-environments#extended-attributes)).\u003cbr/\u003e\u003cbr/\u003eIn dbt Cloud those values are provided as YML but in the provider they need to be provided as JSON (see example below).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// extended_attributes can be set as a raw JSON string or encoded with Terraform's `jsonencode()` function\n// we recommend using `jsonencode()` to avoid Terraform reporting changes due to whitespaces or keys ordering\nconst myAttributes = new dbtcloud.ExtendedAttributes(\"my_attributes\", {\n    extendedAttributes: JSON.stringify({\n        type: \"databricks\",\n        catalog: \"dbt_catalog\",\n        http_path: \"/sql/your/http/path\",\n        my_nested_field: {\n            subfield: \"my_value\",\n        },\n    }),\n    projectId: dbtProject.id,\n});\nconst issueDepl = new dbtcloud.Environment(\"issue_depl\", {\n    dbtVersion: \"versionless\",\n    name: \"My environment\",\n    projectId: dbtProject.id,\n    type: \"deployment\",\n    useCustomBranch: false,\n    credentialId: dbtCredentialId,\n    deploymentType: \"production\",\n    extendedAttributesId: myAttributes.extendedAttributesId,\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_dbtcloud as dbtcloud\n\n# extended_attributes can be set as a raw JSON string or encoded with Terraform's `jsonencode()` function\n# we recommend using `jsonencode()` to avoid Terraform reporting changes due to whitespaces or keys ordering\nmy_attributes = dbtcloud.ExtendedAttributes(\"my_attributes\",\n    extended_attributes=json.dumps({\n        \"type\": \"databricks\",\n        \"catalog\": \"dbt_catalog\",\n        \"http_path\": \"/sql/your/http/path\",\n        \"my_nested_field\": {\n            \"subfield\": \"my_value\",\n        },\n    }),\n    project_id=dbt_project[\"id\"])\nissue_depl = dbtcloud.Environment(\"issue_depl\",\n    dbt_version=\"versionless\",\n    name=\"My environment\",\n    project_id=dbt_project[\"id\"],\n    type=\"deployment\",\n    use_custom_branch=False,\n    credential_id=dbt_credential_id,\n    deployment_type=\"production\",\n    extended_attributes_id=my_attributes.extended_attributes_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // extended_attributes can be set as a raw JSON string or encoded with Terraform's `jsonencode()` function\n    // we recommend using `jsonencode()` to avoid Terraform reporting changes due to whitespaces or keys ordering\n    var myAttributes = new DbtCloud.ExtendedAttributesDetails(\"my_attributes\", new()\n    {\n        ExtendedAttributes = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"type\"] = \"databricks\",\n            [\"catalog\"] = \"dbt_catalog\",\n            [\"http_path\"] = \"/sql/your/http/path\",\n            [\"my_nested_field\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"subfield\"] = \"my_value\",\n            },\n        }),\n        ProjectId = dbtProject.Id,\n    });\n\n    var issueDepl = new DbtCloud.Environment(\"issue_depl\", new()\n    {\n        DbtVersion = \"versionless\",\n        Name = \"My environment\",\n        ProjectId = dbtProject.Id,\n        Type = \"deployment\",\n        UseCustomBranch = false,\n        CredentialId = dbtCredentialId,\n        DeploymentType = \"production\",\n        ExtendedAttributesId = myAttributes.ExtendedAttributesId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"type\":      \"databricks\",\n\t\t\t\"catalog\":   \"dbt_catalog\",\n\t\t\t\"http_path\": \"/sql/your/http/path\",\n\t\t\t\"my_nested_field\": map[string]interface{}{\n\t\t\t\t\"subfield\": \"my_value\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t// extended_attributes can be set as a raw JSON string or encoded with Terraform's `jsonencode()` function\n\t\t// we recommend using `jsonencode()` to avoid Terraform reporting changes due to whitespaces or keys ordering\n\t\tmyAttributes, err := dbtcloud.NewExtendedAttributes(ctx, \"my_attributes\", \u0026dbtcloud.ExtendedAttributesArgs{\n\t\t\tExtendedAttributes: pulumi.String(json0),\n\t\t\tProjectId:          pulumi.Any(dbtProject.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbtcloud.NewEnvironment(ctx, \"issue_depl\", \u0026dbtcloud.EnvironmentArgs{\n\t\t\tDbtVersion:           pulumi.String(\"versionless\"),\n\t\t\tName:                 pulumi.String(\"My environment\"),\n\t\t\tProjectId:            pulumi.Any(dbtProject.Id),\n\t\t\tType:                 pulumi.String(\"deployment\"),\n\t\t\tUseCustomBranch:      pulumi.Bool(false),\n\t\t\tCredentialId:         pulumi.Any(dbtCredentialId),\n\t\t\tDeploymentType:       pulumi.String(\"production\"),\n\t\t\tExtendedAttributesId: myAttributes.ExtendedAttributesId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.ExtendedAttributes;\nimport com.pulumi.dbtcloud.ExtendedAttributesArgs;\nimport com.pulumi.dbtcloud.Environment;\nimport com.pulumi.dbtcloud.EnvironmentArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // extended_attributes can be set as a raw JSON string or encoded with Terraform's `jsonencode()` function\n        // we recommend using `jsonencode()` to avoid Terraform reporting changes due to whitespaces or keys ordering\n        var myAttributes = new ExtendedAttributes(\"myAttributes\", ExtendedAttributesArgs.builder()\n            .extendedAttributes(serializeJson(\n                jsonObject(\n                    jsonProperty(\"type\", \"databricks\"),\n                    jsonProperty(\"catalog\", \"dbt_catalog\"),\n                    jsonProperty(\"http_path\", \"/sql/your/http/path\"),\n                    jsonProperty(\"my_nested_field\", jsonObject(\n                        jsonProperty(\"subfield\", \"my_value\")\n                    ))\n                )))\n            .projectId(dbtProject.id())\n            .build());\n\n        var issueDepl = new Environment(\"issueDepl\", EnvironmentArgs.builder()\n            .dbtVersion(\"versionless\")\n            .name(\"My environment\")\n            .projectId(dbtProject.id())\n            .type(\"deployment\")\n            .useCustomBranch(false)\n            .credentialId(dbtCredentialId)\n            .deploymentType(\"production\")\n            .extendedAttributesId(myAttributes.extendedAttributesId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # extended_attributes can be set as a raw JSON string or encoded with Terraform's `jsonencode()` function\n  # we recommend using `jsonencode()` to avoid Terraform reporting changes due to whitespaces or keys ordering\n  myAttributes:\n    type: dbtcloud:ExtendedAttributes\n    name: my_attributes\n    properties:\n      extendedAttributes:\n        fn::toJSON:\n          type: databricks\n          catalog: dbt_catalog\n          http_path: /sql/your/http/path\n          my_nested_field:\n            subfield: my_value\n      projectId: ${dbtProject.id}\n  issueDepl:\n    type: dbtcloud:Environment\n    name: issue_depl\n    properties:\n      dbtVersion: versionless\n      name: My environment\n      projectId: ${dbtProject.id}\n      type: deployment\n      useCustomBranch: false\n      credentialId: ${dbtCredentialId}\n      deploymentType: production\n      extendedAttributesId: ${myAttributes.extendedAttributesId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_extended_attributes.test_extended_attributes\n\n  id = \"project_id_id:extended_attributes_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_extended_attributes.test_extended_attributes\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/extendedAttributes:ExtendedAttributes test_extended_attributes \"project_id_id:extended_attributes_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/extendedAttributes:ExtendedAttributes test_extended_attributes 12345:6789\n```\n\n",
            "properties": {
                "extendedAttributes": {
                    "type": "string"
                },
                "extendedAttributesId": {
                    "type": "integer",
                    "description": "Extended Attributes ID\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the extended attributes in\n"
                },
                "state": {
                    "type": "integer",
                    "description": "Extended Attributes state (1 is active, 2 is inactive)\n"
                }
            },
            "required": [
                "extendedAttributes",
                "extendedAttributesId",
                "projectId"
            ],
            "language": {
                "csharp": {
                    "name": "ExtendedAttributesDetails"
                }
            },
            "inputProperties": {
                "extendedAttributes": {
                    "type": "string"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the extended attributes in\n"
                },
                "state": {
                    "type": "integer",
                    "description": "Extended Attributes state (1 is active, 2 is inactive)\n"
                }
            },
            "requiredInputs": [
                "extendedAttributes",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExtendedAttributes resources.\n",
                "properties": {
                    "extendedAttributes": {
                        "type": "string"
                    },
                    "extendedAttributesId": {
                        "type": "integer",
                        "description": "Extended Attributes ID\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the extended attributes in\n"
                    },
                    "state": {
                        "type": "integer",
                        "description": "Extended Attributes state (1 is active, 2 is inactive)\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/fabricConnection:FabricConnection": {
            "description": "Resource to create Microsoft Fabric connections in dbt Cloud\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myFabricConnection = new dbtcloud.FabricConnection(\"my_fabric_connection\", {\n    projectId: dbtProject.id,\n    name: \"Connection Name\",\n    server: \"my-server\",\n    database: \"my-database\",\n    port: 1234,\n    loginTimeout: 30,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_fabric_connection = dbtcloud.FabricConnection(\"my_fabric_connection\",\n    project_id=dbt_project[\"id\"],\n    name=\"Connection Name\",\n    server=\"my-server\",\n    database=\"my-database\",\n    port=1234,\n    login_timeout=30)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myFabricConnection = new DbtCloud.FabricConnection(\"my_fabric_connection\", new()\n    {\n        ProjectId = dbtProject.Id,\n        Name = \"Connection Name\",\n        Server = \"my-server\",\n        Database = \"my-database\",\n        Port = 1234,\n        LoginTimeout = 30,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewFabricConnection(ctx, \"my_fabric_connection\", \u0026dbtcloud.FabricConnectionArgs{\n\t\t\tProjectId:    pulumi.Any(dbtProject.Id),\n\t\t\tName:         pulumi.String(\"Connection Name\"),\n\t\t\tServer:       pulumi.String(\"my-server\"),\n\t\t\tDatabase:     pulumi.String(\"my-database\"),\n\t\t\tPort:         pulumi.Int(1234),\n\t\t\tLoginTimeout: pulumi.Int(30),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.FabricConnection;\nimport com.pulumi.dbtcloud.FabricConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myFabricConnection = new FabricConnection(\"myFabricConnection\", FabricConnectionArgs.builder()\n            .projectId(dbtProject.id())\n            .name(\"Connection Name\")\n            .server(\"my-server\")\n            .database(\"my-database\")\n            .port(1234)\n            .loginTimeout(30)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myFabricConnection:\n    type: dbtcloud:FabricConnection\n    name: my_fabric_connection\n    properties:\n      projectId: ${dbtProject.id}\n      name: Connection Name\n      server: my-server\n      database: my-database\n      port: 1234\n      loginTimeout: 30\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_fabric_connection.my_connection\n\n  id = \"project_id:connection_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_fabric_connection.my_connection\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/fabricConnection:FabricConnection my_connection \"project_id:connection_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/fabricConnection:FabricConnection my_connection 12345:6789\n```\n\n",
            "properties": {
                "adapterId": {
                    "type": "integer",
                    "description": "Adapter id created for the Fabric connection\n"
                },
                "connectionId": {
                    "type": "integer",
                    "description": "Connection Identifier\n"
                },
                "database": {
                    "type": "string",
                    "description": "The database to connect to for this connection.\n"
                },
                "loginTimeout": {
                    "type": "integer",
                    "description": "The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Connection name\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to connect to for this connection.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the connection in\n"
                },
                "queryTimeout": {
                    "type": "integer",
                    "description": "The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.\n"
                },
                "server": {
                    "type": "string",
                    "description": "The server hostname.\n"
                }
            },
            "required": [
                "adapterId",
                "connectionId",
                "database",
                "name",
                "port",
                "projectId",
                "server"
            ],
            "inputProperties": {
                "database": {
                    "type": "string",
                    "description": "The database to connect to for this connection.\n"
                },
                "loginTimeout": {
                    "type": "integer",
                    "description": "The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Connection name\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to connect to for this connection.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the connection in\n",
                    "willReplaceOnChanges": true
                },
                "queryTimeout": {
                    "type": "integer",
                    "description": "The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.\n"
                },
                "server": {
                    "type": "string",
                    "description": "The server hostname.\n"
                }
            },
            "requiredInputs": [
                "database",
                "port",
                "projectId",
                "server"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FabricConnection resources.\n",
                "properties": {
                    "adapterId": {
                        "type": "integer",
                        "description": "Adapter id created for the Fabric connection\n"
                    },
                    "connectionId": {
                        "type": "integer",
                        "description": "Connection Identifier\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "The database to connect to for this connection.\n"
                    },
                    "loginTimeout": {
                        "type": "integer",
                        "description": "The number of seconds used to establish a connection before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Connection name\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port to connect to for this connection.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the connection in\n",
                        "willReplaceOnChanges": true
                    },
                    "queryTimeout": {
                        "type": "integer",
                        "description": "The number of seconds used to wait for a query before failing. Defaults to 0, which means that the timeout is disabled or uses the default system settings.\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "The number of automatic times to retry a query before failing. Defaults to 1. Queries with syntax errors will not be retried. This setting can be used to overcome intermittent network issues.\n"
                    },
                    "server": {
                        "type": "string",
                        "description": "The server hostname.\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/fabricCredential:FabricCredential": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// when using AD authentication\nconst myFabricCredAd = new dbtcloud.FabricCredential(\"my_fabric_cred_ad\", {\n    projectId: dbtProject.id,\n    adapterId: myFabricConnection.adapterId,\n    schema: \"my_schema\",\n    user: \"my_user\",\n    password: \"my_password\",\n    schemaAuthorization: \"abcd\",\n});\n// when using service principal authentication\nconst myFabricCredServPrinc = new dbtcloud.FabricCredential(\"my_fabric_cred_serv_princ\", {\n    projectId: dbtProject.id,\n    adapterId: myFabricConnection.adapterId,\n    schema: \"my_schema\",\n    clientId: \"my_client_id\",\n    tenantId: \"my_tenant_id\",\n    clientSecret: \"my_secret\",\n    schemaAuthorization: \"abcd\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# when using AD authentication\nmy_fabric_cred_ad = dbtcloud.FabricCredential(\"my_fabric_cred_ad\",\n    project_id=dbt_project[\"id\"],\n    adapter_id=my_fabric_connection[\"adapterId\"],\n    schema=\"my_schema\",\n    user=\"my_user\",\n    password=\"my_password\",\n    schema_authorization=\"abcd\")\n# when using service principal authentication\nmy_fabric_cred_serv_princ = dbtcloud.FabricCredential(\"my_fabric_cred_serv_princ\",\n    project_id=dbt_project[\"id\"],\n    adapter_id=my_fabric_connection[\"adapterId\"],\n    schema=\"my_schema\",\n    client_id=\"my_client_id\",\n    tenant_id=\"my_tenant_id\",\n    client_secret=\"my_secret\",\n    schema_authorization=\"abcd\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // when using AD authentication\n    var myFabricCredAd = new DbtCloud.FabricCredential(\"my_fabric_cred_ad\", new()\n    {\n        ProjectId = dbtProject.Id,\n        AdapterId = myFabricConnection.AdapterId,\n        Schema = \"my_schema\",\n        User = \"my_user\",\n        Password = \"my_password\",\n        SchemaAuthorization = \"abcd\",\n    });\n\n    // when using service principal authentication\n    var myFabricCredServPrinc = new DbtCloud.FabricCredential(\"my_fabric_cred_serv_princ\", new()\n    {\n        ProjectId = dbtProject.Id,\n        AdapterId = myFabricConnection.AdapterId,\n        Schema = \"my_schema\",\n        ClientId = \"my_client_id\",\n        TenantId = \"my_tenant_id\",\n        ClientSecret = \"my_secret\",\n        SchemaAuthorization = \"abcd\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// when using AD authentication\n\t\t_, err := dbtcloud.NewFabricCredential(ctx, \"my_fabric_cred_ad\", \u0026dbtcloud.FabricCredentialArgs{\n\t\t\tProjectId:           pulumi.Any(dbtProject.Id),\n\t\t\tAdapterId:           pulumi.Any(myFabricConnection.AdapterId),\n\t\t\tSchema:              pulumi.String(\"my_schema\"),\n\t\t\tUser:                pulumi.String(\"my_user\"),\n\t\t\tPassword:            pulumi.String(\"my_password\"),\n\t\t\tSchemaAuthorization: pulumi.String(\"abcd\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// when using service principal authentication\n\t\t_, err = dbtcloud.NewFabricCredential(ctx, \"my_fabric_cred_serv_princ\", \u0026dbtcloud.FabricCredentialArgs{\n\t\t\tProjectId:           pulumi.Any(dbtProject.Id),\n\t\t\tAdapterId:           pulumi.Any(myFabricConnection.AdapterId),\n\t\t\tSchema:              pulumi.String(\"my_schema\"),\n\t\t\tClientId:            pulumi.String(\"my_client_id\"),\n\t\t\tTenantId:            pulumi.String(\"my_tenant_id\"),\n\t\t\tClientSecret:        pulumi.String(\"my_secret\"),\n\t\t\tSchemaAuthorization: pulumi.String(\"abcd\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.FabricCredential;\nimport com.pulumi.dbtcloud.FabricCredentialArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // when using AD authentication\n        var myFabricCredAd = new FabricCredential(\"myFabricCredAd\", FabricCredentialArgs.builder()\n            .projectId(dbtProject.id())\n            .adapterId(myFabricConnection.adapterId())\n            .schema(\"my_schema\")\n            .user(\"my_user\")\n            .password(\"my_password\")\n            .schemaAuthorization(\"abcd\")\n            .build());\n\n        // when using service principal authentication\n        var myFabricCredServPrinc = new FabricCredential(\"myFabricCredServPrinc\", FabricCredentialArgs.builder()\n            .projectId(dbtProject.id())\n            .adapterId(myFabricConnection.adapterId())\n            .schema(\"my_schema\")\n            .clientId(\"my_client_id\")\n            .tenantId(\"my_tenant_id\")\n            .clientSecret(\"my_secret\")\n            .schemaAuthorization(\"abcd\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # when using AD authentication\n  myFabricCredAd:\n    type: dbtcloud:FabricCredential\n    name: my_fabric_cred_ad\n    properties:\n      projectId: ${dbtProject.id}\n      adapterId: ${myFabricConnection.adapterId}\n      schema: my_schema\n      user: my_user\n      password: my_password\n      schemaAuthorization: abcd\n  # when using service principal authentication\n  myFabricCredServPrinc:\n    type: dbtcloud:FabricCredential\n    name: my_fabric_cred_serv_princ\n    properties:\n      projectId: ${dbtProject.id}\n      adapterId: ${myFabricConnection.adapterId}\n      schema: my_schema\n      clientId: my_client_id\n      tenantId: my_tenant_id\n      clientSecret: my_secret\n      schemaAuthorization: abcd\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_fabric_credential.my_fabric_credential\n\n  id = \"project_id:credential_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_fabric_credential.my_fabric_credential\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/fabricCredential:FabricCredential my_fabric_credential \"project_id:credential_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/fabricCredential:FabricCredential my_fabric_credential 12345:6789\n```\n\n",
            "properties": {
                "adapterId": {
                    "type": "integer",
                    "description": "Fabric adapter ID for the credential\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client ID of the Azure Active Directory service principal. This is only used when connecting to Azure SQL with an AAD service principal.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret of the Azure Active Directory service principal. This is only used when connecting to Azure SQL with an AAD service principal.\n",
                    "secret": true
                },
                "credentialId": {
                    "type": "integer",
                    "description": "The system Fabric credential ID\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password for the account to connect to. Only used when connection with AD user/pass\n",
                    "secret": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Fabric credential in\n"
                },
                "schema": {
                    "type": "string",
                    "description": "The schema where to create the dbt models\n"
                },
                "schemaAuthorization": {
                    "type": "string",
                    "description": "Optionally set this to the principal who should own the schemas created by dbt\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant ID of the Azure Active Directory instance. This is only used when connecting to Azure SQL with a service principal.\n"
                },
                "user": {
                    "type": "string",
                    "description": "The username of the Fabric account to connect to. Only used when connection with AD user/pass\n"
                }
            },
            "required": [
                "adapterId",
                "credentialId",
                "projectId",
                "schema"
            ],
            "inputProperties": {
                "adapterId": {
                    "type": "integer",
                    "description": "Fabric adapter ID for the credential\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client ID of the Azure Active Directory service principal. This is only used when connecting to Azure SQL with an AAD service principal.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret of the Azure Active Directory service principal. This is only used when connecting to Azure SQL with an AAD service principal.\n",
                    "secret": true
                },
                "password": {
                    "type": "string",
                    "description": "The password for the account to connect to. Only used when connection with AD user/pass\n",
                    "secret": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Fabric credential in\n",
                    "willReplaceOnChanges": true
                },
                "schema": {
                    "type": "string",
                    "description": "The schema where to create the dbt models\n"
                },
                "schemaAuthorization": {
                    "type": "string",
                    "description": "Optionally set this to the principal who should own the schemas created by dbt\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "The tenant ID of the Azure Active Directory instance. This is only used when connecting to Azure SQL with a service principal.\n"
                },
                "user": {
                    "type": "string",
                    "description": "The username of the Fabric account to connect to. Only used when connection with AD user/pass\n"
                }
            },
            "requiredInputs": [
                "adapterId",
                "projectId",
                "schema"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FabricCredential resources.\n",
                "properties": {
                    "adapterId": {
                        "type": "integer",
                        "description": "Fabric adapter ID for the credential\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client ID of the Azure Active Directory service principal. This is only used when connecting to Azure SQL with an AAD service principal.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client secret of the Azure Active Directory service principal. This is only used when connecting to Azure SQL with an AAD service principal.\n",
                        "secret": true
                    },
                    "credentialId": {
                        "type": "integer",
                        "description": "The system Fabric credential ID\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The password for the account to connect to. Only used when connection with AD user/pass\n",
                        "secret": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the Fabric credential in\n",
                        "willReplaceOnChanges": true
                    },
                    "schema": {
                        "type": "string",
                        "description": "The schema where to create the dbt models\n"
                    },
                    "schemaAuthorization": {
                        "type": "string",
                        "description": "Optionally set this to the principal who should own the schemas created by dbt\n"
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "The tenant ID of the Azure Active Directory instance. This is only used when connecting to Azure SQL with a service principal.\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "The username of the Fabric account to connect to. Only used when connection with AD user/pass\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/group:Group": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst tfGroup1 = new dbtcloud.Group(\"tf_group_1\", {\n    name: \"TF Group 1\",\n    groupPermissions: [\n        {\n            permissionSet: \"member\",\n            allProjects: true,\n        },\n        {\n            permissionSet: \"developer\",\n            allProjects: false,\n            projectId: dbtProject.id,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ntf_group1 = dbtcloud.Group(\"tf_group_1\",\n    name=\"TF Group 1\",\n    group_permissions=[\n        dbtcloud.GroupGroupPermissionArgs(\n            permission_set=\"member\",\n            all_projects=True,\n        ),\n        dbtcloud.GroupGroupPermissionArgs(\n            permission_set=\"developer\",\n            all_projects=False,\n            project_id=dbt_project[\"id\"],\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tfGroup1 = new DbtCloud.Group(\"tf_group_1\", new()\n    {\n        Name = \"TF Group 1\",\n        GroupPermissions = new[]\n        {\n            new DbtCloud.Inputs.GroupGroupPermissionArgs\n            {\n                PermissionSet = \"member\",\n                AllProjects = true,\n            },\n            new DbtCloud.Inputs.GroupGroupPermissionArgs\n            {\n                PermissionSet = \"developer\",\n                AllProjects = false,\n                ProjectId = dbtProject.Id,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewGroup(ctx, \"tf_group_1\", \u0026dbtcloud.GroupArgs{\n\t\t\tName: pulumi.String(\"TF Group 1\"),\n\t\t\tGroupPermissions: dbtcloud.GroupGroupPermissionArray{\n\t\t\t\t\u0026dbtcloud.GroupGroupPermissionArgs{\n\t\t\t\t\tPermissionSet: pulumi.String(\"member\"),\n\t\t\t\t\tAllProjects:   pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026dbtcloud.GroupGroupPermissionArgs{\n\t\t\t\t\tPermissionSet: pulumi.String(\"developer\"),\n\t\t\t\t\tAllProjects:   pulumi.Bool(false),\n\t\t\t\t\tProjectId:     pulumi.Any(dbtProject.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.Group;\nimport com.pulumi.dbtcloud.GroupArgs;\nimport com.pulumi.dbtcloud.inputs.GroupGroupPermissionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tfGroup1 = new Group(\"tfGroup1\", GroupArgs.builder()\n            .name(\"TF Group 1\")\n            .groupPermissions(            \n                GroupGroupPermissionArgs.builder()\n                    .permissionSet(\"member\")\n                    .allProjects(true)\n                    .build(),\n                GroupGroupPermissionArgs.builder()\n                    .permissionSet(\"developer\")\n                    .allProjects(false)\n                    .projectId(dbtProject.id())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tfGroup1:\n    type: dbtcloud:Group\n    name: tf_group_1\n    properties:\n      name: TF Group 1\n      groupPermissions:\n        - permissionSet: member\n          allProjects: true\n        - permissionSet: developer\n          allProjects: false\n          projectId: ${dbtProject.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_group.my_group\n\n  id = \"group_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_group.my_group\n\n  id = \"12345\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/group:Group my_group \"group_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/group:Group my_group 12345\n```\n\n",
            "properties": {
                "assignByDefault": {
                    "type": "boolean",
                    "description": "Whether the group will be assigned by default to users. The value needs to be the same for all partial permissions for the same group.\n"
                },
                "groupPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/dbtcloud:index/GroupGroupPermission:GroupGroupPermission"
                    },
                    "description": "Partial permissions for the group. Those permissions will be added/removed when config is added/removed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group. This is used to identify an existing group\n"
                },
                "ssoMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Mapping groups from the IdP. At the moment the complete list needs to be provided in each partial permission for the same group.\n"
                }
            },
            "required": [
                "assignByDefault",
                "name",
                "ssoMappingGroups"
            ],
            "inputProperties": {
                "assignByDefault": {
                    "type": "boolean",
                    "description": "Whether the group will be assigned by default to users. The value needs to be the same for all partial permissions for the same group.\n"
                },
                "groupPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/dbtcloud:index/GroupGroupPermission:GroupGroupPermission"
                    },
                    "description": "Partial permissions for the group. Those permissions will be added/removed when config is added/removed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group. This is used to identify an existing group\n"
                },
                "ssoMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Mapping groups from the IdP. At the moment the complete list needs to be provided in each partial permission for the same group.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "assignByDefault": {
                        "type": "boolean",
                        "description": "Whether the group will be assigned by default to users. The value needs to be the same for all partial permissions for the same group.\n"
                    },
                    "groupPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/GroupGroupPermission:GroupGroupPermission"
                        },
                        "description": "Partial permissions for the group. Those permissions will be added/removed when config is added/removed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the group. This is used to identify an existing group\n"
                    },
                    "ssoMappingGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Mapping groups from the IdP. At the moment the complete list needs to be provided in each partial permission for the same group.\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/groupPartialPermissions:GroupPartialPermissions": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.GroupPartialPermissions;\nimport com.pulumi.dbtcloud.GroupPartialPermissionsArgs;\nimport com.pulumi.dbtcloud.inputs.GroupPartialPermissionsGroupPermissionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // we add some permissions to the group \"TF Group 1\" (existing or not) to  a new project \n        var tfGroup1 = new GroupPartialPermissions(\"tfGroup1\", GroupPartialPermissionsArgs.builder()\n            .name(\"TF Group 1\")\n            .groupPermissions(            \n                GroupPartialPermissionsGroupPermissionArgs.builder()\n                    .permission_set(\"developer\")\n                    .project_id(dbtProject.id())\n                    .all_projects(false)\n                    .build(),\n                GroupPartialPermissionsGroupPermissionArgs.builder()\n                    .permission_set(\"git_admin\")\n                    .project_id(dbtProject.id())\n                    .all_projects(false)\n                    .build())\n            .build());\n\n        // we add Admin permissions to the group \"TF Group 2\" (existing or not) to  a new project \n        // it is possible to add more permissions to the same group name in other Terraform projects/workspaces, using another `dbtcloud_group_partial_permissions` resource\n        var tfGroup2 = new GroupPartialPermissions(\"tfGroup2\", GroupPartialPermissionsArgs.builder()\n            .name(\"TF Group 2\")\n            .ssoMappingGroups(\"group2\")\n            .groupPermissions(GroupPartialPermissionsGroupPermissionArgs.builder()\n                .permission_set(\"admin\")\n                .project_id(dbtProject.id())\n                .all_projects(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # we add some permissions to the group \"TF Group 1\" (existing or not) to  a new project\n  tfGroup1:\n    type: dbtcloud:GroupPartialPermissions\n    name: tf_group_1\n    properties:\n      name: TF Group 1\n      groupPermissions:\n        - permission_set: developer\n          project_id: ${dbtProject.id}\n          all_projects: false\n        - permission_set: git_admin\n          project_id: ${dbtProject.id}\n          all_projects: false\n  # we add Admin permissions to the group \"TF Group 2\" (existing or not) to  a new project \n  # // it is possible to add more permissions to the same group name in other Terraform projects/workspaces, using another `dbtcloud_group_partial_permissions` resource\n  tfGroup2:\n    type: dbtcloud:GroupPartialPermissions\n    name: tf_group_2\n    properties:\n      name: TF Group 2\n      ssoMappingGroups:\n        - group2\n      groupPermissions:\n        - permission_set: admin\n          project_id: ${dbtProject.id}\n          all_projects: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "assignByDefault": {
                    "type": "boolean",
                    "description": "Whether the group will be assigned by default to users. The value needs to be the same for all partial permissions for the same group.\n"
                },
                "groupPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/dbtcloud:index/GroupPartialPermissionsGroupPermission:GroupPartialPermissionsGroupPermission"
                    },
                    "description": "Partial permissions for the group. Those permissions will be added/removed when config is added/removed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group. This is used to identify an existing group\n"
                },
                "ssoMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Mapping groups from the IdP. At the moment the complete list needs to be provided in each partial permission for the same group.\n"
                }
            },
            "required": [
                "assignByDefault",
                "name",
                "ssoMappingGroups"
            ],
            "inputProperties": {
                "assignByDefault": {
                    "type": "boolean",
                    "description": "Whether the group will be assigned by default to users. The value needs to be the same for all partial permissions for the same group.\n"
                },
                "groupPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/dbtcloud:index/GroupPartialPermissionsGroupPermission:GroupPartialPermissionsGroupPermission"
                    },
                    "description": "Partial permissions for the group. Those permissions will be added/removed when config is added/removed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group. This is used to identify an existing group\n"
                },
                "ssoMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Mapping groups from the IdP. At the moment the complete list needs to be provided in each partial permission for the same group.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupPartialPermissions resources.\n",
                "properties": {
                    "assignByDefault": {
                        "type": "boolean",
                        "description": "Whether the group will be assigned by default to users. The value needs to be the same for all partial permissions for the same group.\n"
                    },
                    "groupPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/GroupPartialPermissionsGroupPermission:GroupPartialPermissionsGroupPermission"
                        },
                        "description": "Partial permissions for the group. Those permissions will be added/removed when config is added/removed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the group. This is used to identify an existing group\n"
                    },
                    "ssoMappingGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Mapping groups from the IdP. At the moment the complete list needs to be provided in each partial permission for the same group.\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/job:Job": {
            "description": "\u003e In October 2023, CI improvements have been rolled out to dbt Cloud with minor impacts to some jobs:  [more info](https://docs.getdbt.com/docs/dbt-versions/release-notes/june-2023/ci-updates-phase1-rn). \n\u003cbr/\u003e\n\u003cbr/\u003e\nThose improvements include modifications to deferral which was historically set at the job level and will now be set at the environment level. \nDeferral can still be set to \"self\" by setting `self_deferring` to `true` but with the new approach, deferral to other runs need to be done with `deferring_environment_id` instead of `deferring_job_id`.\n\n\u003e New with 0.3.1, `triggers` now accepts a `on_merge` value to trigger jobs when code is merged in git. If `on_merge` is `true` all other triggers need to be `false`.\n\u003cbr/\u003e\n\u003cbr/\u003e\nFor now, it is not a mandatory field, but it will be in a future version. Please add `on_merge` in your config or modules. \n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// a job that has github_webhook and git_provider_webhook \n// set to false will be categorized as a \"Deploy Job\"\nconst dailyJob = new dbtcloud.Job(\"daily_job\", {\n    environmentId: prodEnvironment.environmentId,\n    executeSteps: [\"dbt build\"],\n    generateDocs: true,\n    isActive: true,\n    name: \"Daily job\",\n    numThreads: 64,\n    projectId: dbtProject.id,\n    runGenerateSources: true,\n    targetName: \"default\",\n    triggers: {\n        github_webhook: false,\n        git_provider_webhook: false,\n        schedule: true,\n        on_merge: false,\n    },\n    scheduleDays: [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n    ],\n    scheduleType: \"days_of_week\",\n    scheduleHours: [0],\n});\n// a job that has github_webhook and git_provider_webhook set \n// to true will be categorized as a \"Continuous Integration Job\"\nconst ciJob = new dbtcloud.Job(\"ci_job\", {\n    environmentId: ciEnvironment.environmentId,\n    executeSteps: [\"dbt build -s state:modified+ --fail-fast\"],\n    generateDocs: false,\n    deferringEnvironmentId: prodEnvironment.environmentId,\n    name: \"CI Job\",\n    numThreads: 32,\n    projectId: dbtProject.id,\n    runGenerateSources: false,\n    triggers: {\n        github_webhook: true,\n        git_provider_webhook: true,\n        schedule: false,\n        on_merge: false,\n    },\n    scheduleDays: [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n    ],\n    scheduleType: \"days_of_week\",\n});\n// a job that is set to be triggered after another job finishes\n// this is sometimes referred as 'job chaining'\nconst downstreamJob = new dbtcloud.Job(\"downstream_job\", {\n    environmentId: project2ProdEnvironment.environmentId,\n    executeSteps: [\"dbt build -s +my_model\"],\n    generateDocs: true,\n    name: \"Downstream job in project 2\",\n    numThreads: 32,\n    projectId: dbtProject2.id,\n    runGenerateSources: true,\n    triggers: {\n        github_webhook: false,\n        git_provider_webhook: false,\n        schedule: false,\n        on_merge: false,\n    },\n    scheduleDays: [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n    ],\n    scheduleType: \"days_of_week\",\n    jobCompletionTriggerCondition: {\n        jobId: dailyJob.id,\n        projectId: dbtProject.id,\n        statuses: [\"success\"],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# a job that has github_webhook and git_provider_webhook \n# set to false will be categorized as a \"Deploy Job\"\ndaily_job = dbtcloud.Job(\"daily_job\",\n    environment_id=prod_environment[\"environmentId\"],\n    execute_steps=[\"dbt build\"],\n    generate_docs=True,\n    is_active=True,\n    name=\"Daily job\",\n    num_threads=64,\n    project_id=dbt_project[\"id\"],\n    run_generate_sources=True,\n    target_name=\"default\",\n    triggers={\n        \"github_webhook\": False,\n        \"git_provider_webhook\": False,\n        \"schedule\": True,\n        \"on_merge\": False,\n    },\n    schedule_days=[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n    ],\n    schedule_type=\"days_of_week\",\n    schedule_hours=[0])\n# a job that has github_webhook and git_provider_webhook set \n# to true will be categorized as a \"Continuous Integration Job\"\nci_job = dbtcloud.Job(\"ci_job\",\n    environment_id=ci_environment[\"environmentId\"],\n    execute_steps=[\"dbt build -s state:modified+ --fail-fast\"],\n    generate_docs=False,\n    deferring_environment_id=prod_environment[\"environmentId\"],\n    name=\"CI Job\",\n    num_threads=32,\n    project_id=dbt_project[\"id\"],\n    run_generate_sources=False,\n    triggers={\n        \"github_webhook\": True,\n        \"git_provider_webhook\": True,\n        \"schedule\": False,\n        \"on_merge\": False,\n    },\n    schedule_days=[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n    ],\n    schedule_type=\"days_of_week\")\n# a job that is set to be triggered after another job finishes\n# this is sometimes referred as 'job chaining'\ndownstream_job = dbtcloud.Job(\"downstream_job\",\n    environment_id=project2_prod_environment[\"environmentId\"],\n    execute_steps=[\"dbt build -s +my_model\"],\n    generate_docs=True,\n    name=\"Downstream job in project 2\",\n    num_threads=32,\n    project_id=dbt_project2[\"id\"],\n    run_generate_sources=True,\n    triggers={\n        \"github_webhook\": False,\n        \"git_provider_webhook\": False,\n        \"schedule\": False,\n        \"on_merge\": False,\n    },\n    schedule_days=[\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n    ],\n    schedule_type=\"days_of_week\",\n    job_completion_trigger_condition=dbtcloud.JobJobCompletionTriggerConditionArgs(\n        job_id=daily_job.id,\n        project_id=dbt_project[\"id\"],\n        statuses=[\"success\"],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // a job that has github_webhook and git_provider_webhook \n    // set to false will be categorized as a \"Deploy Job\"\n    var dailyJob = new DbtCloud.Job(\"daily_job\", new()\n    {\n        EnvironmentId = prodEnvironment.EnvironmentId,\n        ExecuteSteps = new[]\n        {\n            \"dbt build\",\n        },\n        GenerateDocs = true,\n        IsActive = true,\n        Name = \"Daily job\",\n        NumThreads = 64,\n        ProjectId = dbtProject.Id,\n        RunGenerateSources = true,\n        TargetName = \"default\",\n        Triggers = \n        {\n            { \"github_webhook\", false },\n            { \"git_provider_webhook\", false },\n            { \"schedule\", true },\n            { \"on_merge\", false },\n        },\n        ScheduleDays = new[]\n        {\n            0,\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n        },\n        ScheduleType = \"days_of_week\",\n        ScheduleHours = new[]\n        {\n            0,\n        },\n    });\n\n    // a job that has github_webhook and git_provider_webhook set \n    // to true will be categorized as a \"Continuous Integration Job\"\n    var ciJob = new DbtCloud.Job(\"ci_job\", new()\n    {\n        EnvironmentId = ciEnvironment.EnvironmentId,\n        ExecuteSteps = new[]\n        {\n            \"dbt build -s state:modified+ --fail-fast\",\n        },\n        GenerateDocs = false,\n        DeferringEnvironmentId = prodEnvironment.EnvironmentId,\n        Name = \"CI Job\",\n        NumThreads = 32,\n        ProjectId = dbtProject.Id,\n        RunGenerateSources = false,\n        Triggers = \n        {\n            { \"github_webhook\", true },\n            { \"git_provider_webhook\", true },\n            { \"schedule\", false },\n            { \"on_merge\", false },\n        },\n        ScheduleDays = new[]\n        {\n            0,\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n        },\n        ScheduleType = \"days_of_week\",\n    });\n\n    // a job that is set to be triggered after another job finishes\n    // this is sometimes referred as 'job chaining'\n    var downstreamJob = new DbtCloud.Job(\"downstream_job\", new()\n    {\n        EnvironmentId = project2ProdEnvironment.EnvironmentId,\n        ExecuteSteps = new[]\n        {\n            \"dbt build -s +my_model\",\n        },\n        GenerateDocs = true,\n        Name = \"Downstream job in project 2\",\n        NumThreads = 32,\n        ProjectId = dbtProject2.Id,\n        RunGenerateSources = true,\n        Triggers = \n        {\n            { \"github_webhook\", false },\n            { \"git_provider_webhook\", false },\n            { \"schedule\", false },\n            { \"on_merge\", false },\n        },\n        ScheduleDays = new[]\n        {\n            0,\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n        },\n        ScheduleType = \"days_of_week\",\n        CompletionTriggerCondition = new DbtCloud.Inputs.JobJobCompletionTriggerConditionArgs\n        {\n            JobId = dailyJob.Id,\n            ProjectId = dbtProject.Id,\n            Statuses = new[]\n            {\n                \"success\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// a job that has github_webhook and git_provider_webhook\n\t\t// set to false will be categorized as a \"Deploy Job\"\n\t\tdailyJob, err := dbtcloud.NewJob(ctx, \"daily_job\", \u0026dbtcloud.JobArgs{\n\t\t\tEnvironmentId: pulumi.Any(prodEnvironment.EnvironmentId),\n\t\t\tExecuteSteps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dbt build\"),\n\t\t\t},\n\t\t\tGenerateDocs:       pulumi.Bool(true),\n\t\t\tIsActive:           pulumi.Bool(true),\n\t\t\tName:               pulumi.String(\"Daily job\"),\n\t\t\tNumThreads:         pulumi.Int(64),\n\t\t\tProjectId:          pulumi.Any(dbtProject.Id),\n\t\t\tRunGenerateSources: pulumi.Bool(true),\n\t\t\tTargetName:         pulumi.String(\"default\"),\n\t\t\tTriggers: pulumi.BoolMap{\n\t\t\t\t\"github_webhook\":       pulumi.Bool(false),\n\t\t\t\t\"git_provider_webhook\": pulumi.Bool(false),\n\t\t\t\t\"schedule\":             pulumi.Bool(true),\n\t\t\t\t\"on_merge\":             pulumi.Bool(false),\n\t\t\t},\n\t\t\tScheduleDays: pulumi.IntArray{\n\t\t\t\tpulumi.Int(0),\n\t\t\t\tpulumi.Int(1),\n\t\t\t\tpulumi.Int(2),\n\t\t\t\tpulumi.Int(3),\n\t\t\t\tpulumi.Int(4),\n\t\t\t\tpulumi.Int(5),\n\t\t\t\tpulumi.Int(6),\n\t\t\t},\n\t\t\tScheduleType: pulumi.String(\"days_of_week\"),\n\t\t\tScheduleHours: pulumi.IntArray{\n\t\t\t\tpulumi.Int(0),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// a job that has github_webhook and git_provider_webhook set\n\t\t// to true will be categorized as a \"Continuous Integration Job\"\n\t\t_, err = dbtcloud.NewJob(ctx, \"ci_job\", \u0026dbtcloud.JobArgs{\n\t\t\tEnvironmentId: pulumi.Any(ciEnvironment.EnvironmentId),\n\t\t\tExecuteSteps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dbt build -s state:modified+ --fail-fast\"),\n\t\t\t},\n\t\t\tGenerateDocs:           pulumi.Bool(false),\n\t\t\tDeferringEnvironmentId: pulumi.Any(prodEnvironment.EnvironmentId),\n\t\t\tName:                   pulumi.String(\"CI Job\"),\n\t\t\tNumThreads:             pulumi.Int(32),\n\t\t\tProjectId:              pulumi.Any(dbtProject.Id),\n\t\t\tRunGenerateSources:     pulumi.Bool(false),\n\t\t\tTriggers: pulumi.BoolMap{\n\t\t\t\t\"github_webhook\":       pulumi.Bool(true),\n\t\t\t\t\"git_provider_webhook\": pulumi.Bool(true),\n\t\t\t\t\"schedule\":             pulumi.Bool(false),\n\t\t\t\t\"on_merge\":             pulumi.Bool(false),\n\t\t\t},\n\t\t\tScheduleDays: pulumi.IntArray{\n\t\t\t\tpulumi.Int(0),\n\t\t\t\tpulumi.Int(1),\n\t\t\t\tpulumi.Int(2),\n\t\t\t\tpulumi.Int(3),\n\t\t\t\tpulumi.Int(4),\n\t\t\t\tpulumi.Int(5),\n\t\t\t\tpulumi.Int(6),\n\t\t\t},\n\t\t\tScheduleType: pulumi.String(\"days_of_week\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// a job that is set to be triggered after another job finishes\n\t\t// this is sometimes referred as 'job chaining'\n\t\t_, err = dbtcloud.NewJob(ctx, \"downstream_job\", \u0026dbtcloud.JobArgs{\n\t\t\tEnvironmentId: pulumi.Any(project2ProdEnvironment.EnvironmentId),\n\t\t\tExecuteSteps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dbt build -s +my_model\"),\n\t\t\t},\n\t\t\tGenerateDocs:       pulumi.Bool(true),\n\t\t\tName:               pulumi.String(\"Downstream job in project 2\"),\n\t\t\tNumThreads:         pulumi.Int(32),\n\t\t\tProjectId:          pulumi.Any(dbtProject2.Id),\n\t\t\tRunGenerateSources: pulumi.Bool(true),\n\t\t\tTriggers: pulumi.BoolMap{\n\t\t\t\t\"github_webhook\":       pulumi.Bool(false),\n\t\t\t\t\"git_provider_webhook\": pulumi.Bool(false),\n\t\t\t\t\"schedule\":             pulumi.Bool(false),\n\t\t\t\t\"on_merge\":             pulumi.Bool(false),\n\t\t\t},\n\t\t\tScheduleDays: pulumi.IntArray{\n\t\t\t\tpulumi.Int(0),\n\t\t\t\tpulumi.Int(1),\n\t\t\t\tpulumi.Int(2),\n\t\t\t\tpulumi.Int(3),\n\t\t\t\tpulumi.Int(4),\n\t\t\t\tpulumi.Int(5),\n\t\t\t\tpulumi.Int(6),\n\t\t\t},\n\t\t\tScheduleType: pulumi.String(\"days_of_week\"),\n\t\t\tJobCompletionTriggerCondition: \u0026dbtcloud.JobJobCompletionTriggerConditionArgs{\n\t\t\t\tJobId:     dailyJob.ID(),\n\t\t\t\tProjectId: pulumi.Any(dbtProject.Id),\n\t\t\t\tStatuses: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"success\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.Job;\nimport com.pulumi.dbtcloud.JobArgs;\nimport com.pulumi.dbtcloud.inputs.JobJobCompletionTriggerConditionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // a job that has github_webhook and git_provider_webhook \n        // set to false will be categorized as a \"Deploy Job\"\n        var dailyJob = new Job(\"dailyJob\", JobArgs.builder()\n            .environmentId(prodEnvironment.environmentId())\n            .executeSteps(\"dbt build\")\n            .generateDocs(true)\n            .isActive(true)\n            .name(\"Daily job\")\n            .numThreads(64)\n            .projectId(dbtProject.id())\n            .runGenerateSources(true)\n            .targetName(\"default\")\n            .triggers(Map.ofEntries(\n                Map.entry(\"github_webhook\", false),\n                Map.entry(\"git_provider_webhook\", false),\n                Map.entry(\"schedule\", true),\n                Map.entry(\"on_merge\", false)\n            ))\n            .scheduleDays(            \n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6)\n            .scheduleType(\"days_of_week\")\n            .scheduleHours(0)\n            .build());\n\n        // a job that has github_webhook and git_provider_webhook set \n        // to true will be categorized as a \"Continuous Integration Job\"\n        var ciJob = new Job(\"ciJob\", JobArgs.builder()\n            .environmentId(ciEnvironment.environmentId())\n            .executeSteps(\"dbt build -s state:modified+ --fail-fast\")\n            .generateDocs(false)\n            .deferringEnvironmentId(prodEnvironment.environmentId())\n            .name(\"CI Job\")\n            .numThreads(32)\n            .projectId(dbtProject.id())\n            .runGenerateSources(false)\n            .triggers(Map.ofEntries(\n                Map.entry(\"github_webhook\", true),\n                Map.entry(\"git_provider_webhook\", true),\n                Map.entry(\"schedule\", false),\n                Map.entry(\"on_merge\", false)\n            ))\n            .scheduleDays(            \n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6)\n            .scheduleType(\"days_of_week\")\n            .build());\n\n        // a job that is set to be triggered after another job finishes\n        // this is sometimes referred as 'job chaining'\n        var downstreamJob = new Job(\"downstreamJob\", JobArgs.builder()\n            .environmentId(project2ProdEnvironment.environmentId())\n            .executeSteps(\"dbt build -s +my_model\")\n            .generateDocs(true)\n            .name(\"Downstream job in project 2\")\n            .numThreads(32)\n            .projectId(dbtProject2.id())\n            .runGenerateSources(true)\n            .triggers(Map.ofEntries(\n                Map.entry(\"github_webhook\", false),\n                Map.entry(\"git_provider_webhook\", false),\n                Map.entry(\"schedule\", false),\n                Map.entry(\"on_merge\", false)\n            ))\n            .scheduleDays(            \n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6)\n            .scheduleType(\"days_of_week\")\n            .jobCompletionTriggerCondition(JobJobCompletionTriggerConditionArgs.builder()\n                .jobId(dailyJob.id())\n                .projectId(dbtProject.id())\n                .statuses(\"success\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # a job that has github_webhook and git_provider_webhook \n  # set to false will be categorized as a \"Deploy Job\"\n  dailyJob:\n    type: dbtcloud:Job\n    name: daily_job\n    properties:\n      environmentId: ${prodEnvironment.environmentId}\n      executeSteps:\n        - dbt build\n      generateDocs: true\n      isActive: true\n      name: Daily job\n      numThreads: 64\n      projectId: ${dbtProject.id}\n      runGenerateSources: true\n      targetName: default\n      triggers:\n        github_webhook: false\n        git_provider_webhook: false\n        schedule: true\n        on_merge: false\n      scheduleDays:\n        - 0\n        - 1\n        - 2\n        - 3\n        - 4\n        - 5\n        - 6\n      scheduleType: days_of_week\n      scheduleHours:\n        - 0\n  # a job that has github_webhook and git_provider_webhook set \n  # to true will be categorized as a \"Continuous Integration Job\"\n  ciJob:\n    type: dbtcloud:Job\n    name: ci_job\n    properties:\n      environmentId: ${ciEnvironment.environmentId}\n      executeSteps:\n        - dbt build -s state:modified+ --fail-fast\n      generateDocs: false\n      deferringEnvironmentId: ${prodEnvironment.environmentId}\n      name: CI Job\n      numThreads: 32\n      projectId: ${dbtProject.id}\n      runGenerateSources: false\n      triggers:\n        github_webhook: true\n        git_provider_webhook: true\n        schedule: false\n        on_merge: false\n      scheduleDays:\n        - 0\n        - 1\n        - 2\n        - 3\n        - 4\n        - 5\n        - 6\n      scheduleType: days_of_week\n  # a job that is set to be triggered after another job finishes\n  # this is sometimes referred as 'job chaining'\n  downstreamJob:\n    type: dbtcloud:Job\n    name: downstream_job\n    properties:\n      environmentId: ${project2ProdEnvironment.environmentId}\n      executeSteps:\n        - dbt build -s +my_model\n      generateDocs: true\n      name: Downstream job in project 2\n      numThreads: 32\n      projectId: ${dbtProject2.id}\n      runGenerateSources: true\n      triggers:\n        github_webhook: false\n        git_provider_webhook: false\n        schedule: false\n        on_merge: false\n      scheduleDays:\n        - 0\n        - 1\n        - 2\n        - 3\n        - 4\n        - 5\n        - 6\n      scheduleType: days_of_week\n      jobCompletionTriggerCondition:\n        jobId: ${dailyJob.id}\n        projectId: ${dbtProject.id}\n        statuses:\n          - success\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_job.my_job\n\n  id = \"job_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_job.my_job\n\n  id = \"12345\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/job:Job my_job \"job_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/job:Job my_job 12345\n```\n\n",
            "properties": {
                "dbtVersion": {
                    "type": "string",
                    "description": "Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions\n"
                },
                "deferringEnvironmentId": {
                    "type": "integer",
                    "description": "Environment identifier that this job defers to (new deferring approach)\n"
                },
                "deferringJobId": {
                    "type": "integer",
                    "description": "Job identifier that this job defers to (legacy deferring approach)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the job\n"
                },
                "environmentId": {
                    "type": "integer",
                    "description": "Environment ID to create the job in\n"
                },
                "executeSteps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of commands to execute for the job\n"
                },
                "generateDocs": {
                    "type": "boolean",
                    "description": "Flag for whether the job should generate documentation\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Should always be set to true as setting it to false is the same as creating a job in a deleted state. To create/keep a job in a 'deactivated' state, check  the `triggers` config.\n"
                },
                "jobCompletionTriggerCondition": {
                    "$ref": "#/types/dbtcloud:index/JobJobCompletionTriggerCondition:JobJobCompletionTriggerCondition",
                    "description": "Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job chaining').\n",
                    "language": {
                        "csharp": {
                            "name": "CompletionTriggerCondition"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Job name\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use in the job\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the job in\n"
                },
                "runGenerateSources": {
                    "type": "boolean",
                    "description": "Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will still allow the following steps to run.\n"
                },
                "scheduleCron": {
                    "type": "string",
                    "description": "Custom cron expression for schedule\n"
                },
                "scheduleDays": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule\n"
                },
                "scheduleHours": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of hours to execute the job at if running on a schedule\n"
                },
                "scheduleInterval": {
                    "type": "integer",
                    "description": "Number of hours between job executions if running on a schedule\n"
                },
                "scheduleType": {
                    "type": "string",
                    "description": "Type of schedule to use, one of every*day/ days*of*week/ custom*cron\n"
                },
                "selfDeferring": {
                    "type": "boolean",
                    "description": "Whether this job defers on a previous run of itself\n"
                },
                "targetName": {
                    "type": "string",
                    "description": "Target name for the dbt profile\n"
                },
                "timeoutSeconds": {
                    "type": "integer",
                    "description": "Number of seconds to allow the job to run before timing out\n"
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "boolean"
                    },
                    "description": "Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and `on_merge`. All flags should be listed and set with `true` or `false`. When `on_merge` is `true`, all the other values must be false.\\n\\n`custom_branch_only` used to be allowed but has been deprecated from the API. The jobs will use the custom branch of the environment. Please remove the `custom_branch_only` from your config. \\n\\nTo create a job in a 'deactivated' state, set all to `false`.\n"
                },
                "triggersOnDraftPr": {
                    "type": "boolean",
                    "description": "Whether the CI job should be automatically triggered on draft PRs\n"
                }
            },
            "required": [
                "environmentId",
                "executeSteps",
                "name",
                "projectId",
                "triggers"
            ],
            "inputProperties": {
                "dbtVersion": {
                    "type": "string",
                    "description": "Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions\n"
                },
                "deferringEnvironmentId": {
                    "type": "integer",
                    "description": "Environment identifier that this job defers to (new deferring approach)\n"
                },
                "deferringJobId": {
                    "type": "integer",
                    "description": "Job identifier that this job defers to (legacy deferring approach)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the job\n"
                },
                "environmentId": {
                    "type": "integer",
                    "description": "Environment ID to create the job in\n"
                },
                "executeSteps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of commands to execute for the job\n"
                },
                "generateDocs": {
                    "type": "boolean",
                    "description": "Flag for whether the job should generate documentation\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Should always be set to true as setting it to false is the same as creating a job in a deleted state. To create/keep a job in a 'deactivated' state, check  the `triggers` config.\n"
                },
                "jobCompletionTriggerCondition": {
                    "$ref": "#/types/dbtcloud:index/JobJobCompletionTriggerCondition:JobJobCompletionTriggerCondition",
                    "description": "Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job chaining').\n",
                    "language": {
                        "csharp": {
                            "name": "CompletionTriggerCondition"
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Job name\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use in the job\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the job in\n",
                    "willReplaceOnChanges": true
                },
                "runGenerateSources": {
                    "type": "boolean",
                    "description": "Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will still allow the following steps to run.\n"
                },
                "scheduleCron": {
                    "type": "string",
                    "description": "Custom cron expression for schedule\n"
                },
                "scheduleDays": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule\n"
                },
                "scheduleHours": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of hours to execute the job at if running on a schedule\n"
                },
                "scheduleInterval": {
                    "type": "integer",
                    "description": "Number of hours between job executions if running on a schedule\n"
                },
                "scheduleType": {
                    "type": "string",
                    "description": "Type of schedule to use, one of every*day/ days*of*week/ custom*cron\n"
                },
                "selfDeferring": {
                    "type": "boolean",
                    "description": "Whether this job defers on a previous run of itself\n"
                },
                "targetName": {
                    "type": "string",
                    "description": "Target name for the dbt profile\n"
                },
                "timeoutSeconds": {
                    "type": "integer",
                    "description": "Number of seconds to allow the job to run before timing out\n"
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "boolean"
                    },
                    "description": "Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and `on_merge`. All flags should be listed and set with `true` or `false`. When `on_merge` is `true`, all the other values must be false.\\n\\n`custom_branch_only` used to be allowed but has been deprecated from the API. The jobs will use the custom branch of the environment. Please remove the `custom_branch_only` from your config. \\n\\nTo create a job in a 'deactivated' state, set all to `false`.\n"
                },
                "triggersOnDraftPr": {
                    "type": "boolean",
                    "description": "Whether the CI job should be automatically triggered on draft PRs\n"
                }
            },
            "requiredInputs": [
                "environmentId",
                "executeSteps",
                "projectId",
                "triggers"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Job resources.\n",
                "properties": {
                    "dbtVersion": {
                        "type": "string",
                        "description": "Version number of dbt to use in this job, usually in the format 1.2.0-latest rather than core versions\n"
                    },
                    "deferringEnvironmentId": {
                        "type": "integer",
                        "description": "Environment identifier that this job defers to (new deferring approach)\n"
                    },
                    "deferringJobId": {
                        "type": "integer",
                        "description": "Job identifier that this job defers to (legacy deferring approach)\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the job\n"
                    },
                    "environmentId": {
                        "type": "integer",
                        "description": "Environment ID to create the job in\n"
                    },
                    "executeSteps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of commands to execute for the job\n"
                    },
                    "generateDocs": {
                        "type": "boolean",
                        "description": "Flag for whether the job should generate documentation\n"
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Should always be set to true as setting it to false is the same as creating a job in a deleted state. To create/keep a job in a 'deactivated' state, check  the `triggers` config.\n"
                    },
                    "jobCompletionTriggerCondition": {
                        "$ref": "#/types/dbtcloud:index/JobJobCompletionTriggerCondition:JobJobCompletionTriggerCondition",
                        "description": "Which other job should trigger this job when it finishes, and on which conditions (sometimes referred as 'job chaining').\n",
                        "language": {
                            "csharp": {
                                "name": "CompletionTriggerCondition"
                            }
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "Job name\n"
                    },
                    "numThreads": {
                        "type": "integer",
                        "description": "Number of threads to use in the job\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the job in\n",
                        "willReplaceOnChanges": true
                    },
                    "runGenerateSources": {
                        "type": "boolean",
                        "description": "Flag for whether the job should add a `dbt source freshness` step to the job. The difference between manually adding a step with `dbt source freshness` in the job steps or using this flag is that with this flag, a failed freshness will still allow the following steps to run.\n"
                    },
                    "scheduleCron": {
                        "type": "string",
                        "description": "Custom cron expression for schedule\n"
                    },
                    "scheduleDays": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of days of week as numbers (0 = Sunday, 7 = Saturday) to execute the job at if running on a schedule\n"
                    },
                    "scheduleHours": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of hours to execute the job at if running on a schedule\n"
                    },
                    "scheduleInterval": {
                        "type": "integer",
                        "description": "Number of hours between job executions if running on a schedule\n"
                    },
                    "scheduleType": {
                        "type": "string",
                        "description": "Type of schedule to use, one of every*day/ days*of*week/ custom*cron\n"
                    },
                    "selfDeferring": {
                        "type": "boolean",
                        "description": "Whether this job defers on a previous run of itself\n"
                    },
                    "targetName": {
                        "type": "string",
                        "description": "Target name for the dbt profile\n"
                    },
                    "timeoutSeconds": {
                        "type": "integer",
                        "description": "Number of seconds to allow the job to run before timing out\n"
                    },
                    "triggers": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "boolean"
                        },
                        "description": "Flags for which types of triggers to use, the values are `github_webhook`, `git_provider_webhook`, `schedule` and `on_merge`. All flags should be listed and set with `true` or `false`. When `on_merge` is `true`, all the other values must be false.\\n\\n`custom_branch_only` used to be allowed but has been deprecated from the API. The jobs will use the custom branch of the environment. Please remove the `custom_branch_only` from your config. \\n\\nTo create a job in a 'deactivated' state, set all to `false`.\n"
                    },
                    "triggersOnDraftPr": {
                        "type": "boolean",
                        "description": "Whether the CI job should be automatically triggered on draft PRs\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/licenseMap:LicenseMap": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// Developer license group mapping\nconst devLicenseMap = new dbtcloud.LicenseMap(\"dev_license_map\", {\n    licenseType: \"developer\",\n    ssoLicenseMappingGroups: [\"DEV-SSO-GROUP\"],\n});\n// Read-only license mapping\nconst readOnlyLicenseMap = new dbtcloud.LicenseMap(\"read_only_license_map\", {\n    licenseType: \"read_only\",\n    ssoLicenseMappingGroups: [\"READ-ONLY-SSO-GROUP\"],\n});\n// IT license mapping\nconst itLicenseMap = new dbtcloud.LicenseMap(\"it_license_map\", {\n    licenseType: \"it\",\n    ssoLicenseMappingGroups: [\"IT-SSO-GROUP\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# Developer license group mapping\ndev_license_map = dbtcloud.LicenseMap(\"dev_license_map\",\n    license_type=\"developer\",\n    sso_license_mapping_groups=[\"DEV-SSO-GROUP\"])\n# Read-only license mapping\nread_only_license_map = dbtcloud.LicenseMap(\"read_only_license_map\",\n    license_type=\"read_only\",\n    sso_license_mapping_groups=[\"READ-ONLY-SSO-GROUP\"])\n# IT license mapping\nit_license_map = dbtcloud.LicenseMap(\"it_license_map\",\n    license_type=\"it\",\n    sso_license_mapping_groups=[\"IT-SSO-GROUP\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Developer license group mapping\n    var devLicenseMap = new DbtCloud.LicenseMap(\"dev_license_map\", new()\n    {\n        LicenseType = \"developer\",\n        SsoLicenseMappingGroups = new[]\n        {\n            \"DEV-SSO-GROUP\",\n        },\n    });\n\n    // Read-only license mapping\n    var readOnlyLicenseMap = new DbtCloud.LicenseMap(\"read_only_license_map\", new()\n    {\n        LicenseType = \"read_only\",\n        SsoLicenseMappingGroups = new[]\n        {\n            \"READ-ONLY-SSO-GROUP\",\n        },\n    });\n\n    // IT license mapping\n    var itLicenseMap = new DbtCloud.LicenseMap(\"it_license_map\", new()\n    {\n        LicenseType = \"it\",\n        SsoLicenseMappingGroups = new[]\n        {\n            \"IT-SSO-GROUP\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Developer license group mapping\n\t\t_, err := dbtcloud.NewLicenseMap(ctx, \"dev_license_map\", \u0026dbtcloud.LicenseMapArgs{\n\t\t\tLicenseType: pulumi.String(\"developer\"),\n\t\t\tSsoLicenseMappingGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DEV-SSO-GROUP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read-only license mapping\n\t\t_, err = dbtcloud.NewLicenseMap(ctx, \"read_only_license_map\", \u0026dbtcloud.LicenseMapArgs{\n\t\t\tLicenseType: pulumi.String(\"read_only\"),\n\t\t\tSsoLicenseMappingGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"READ-ONLY-SSO-GROUP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// IT license mapping\n\t\t_, err = dbtcloud.NewLicenseMap(ctx, \"it_license_map\", \u0026dbtcloud.LicenseMapArgs{\n\t\t\tLicenseType: pulumi.String(\"it\"),\n\t\t\tSsoLicenseMappingGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"IT-SSO-GROUP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.LicenseMap;\nimport com.pulumi.dbtcloud.LicenseMapArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Developer license group mapping\n        var devLicenseMap = new LicenseMap(\"devLicenseMap\", LicenseMapArgs.builder()\n            .licenseType(\"developer\")\n            .ssoLicenseMappingGroups(\"DEV-SSO-GROUP\")\n            .build());\n\n        // Read-only license mapping\n        var readOnlyLicenseMap = new LicenseMap(\"readOnlyLicenseMap\", LicenseMapArgs.builder()\n            .licenseType(\"read_only\")\n            .ssoLicenseMappingGroups(\"READ-ONLY-SSO-GROUP\")\n            .build());\n\n        // IT license mapping\n        var itLicenseMap = new LicenseMap(\"itLicenseMap\", LicenseMapArgs.builder()\n            .licenseType(\"it\")\n            .ssoLicenseMappingGroups(\"IT-SSO-GROUP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Developer license group mapping\n  devLicenseMap:\n    type: dbtcloud:LicenseMap\n    name: dev_license_map\n    properties:\n      licenseType: developer\n      ssoLicenseMappingGroups:\n        - DEV-SSO-GROUP\n  # Read-only license mapping\n  readOnlyLicenseMap:\n    type: dbtcloud:LicenseMap\n    name: read_only_license_map\n    properties:\n      licenseType: read_only\n      ssoLicenseMappingGroups:\n        - READ-ONLY-SSO-GROUP\n  # IT license mapping\n  itLicenseMap:\n    type: dbtcloud:LicenseMap\n    name: it_license_map\n    properties:\n      licenseType: it\n      ssoLicenseMappingGroups:\n        - IT-SSO-GROUP\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_license_map.my_license_map\n\n  id = \"license_map_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_license_map.my_license_map\n\n  id = \"12345\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/licenseMap:LicenseMap my_license_map \"license_map_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/licenseMap:LicenseMap my_license_map 12345\n```\n\n",
            "properties": {
                "licenseType": {
                    "type": "string",
                    "description": "License type\n"
                },
                "ssoLicenseMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "SSO license mapping group names for this group\n"
                }
            },
            "required": [
                "licenseType"
            ],
            "inputProperties": {
                "licenseType": {
                    "type": "string",
                    "description": "License type\n"
                },
                "ssoLicenseMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "SSO license mapping group names for this group\n"
                }
            },
            "requiredInputs": [
                "licenseType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LicenseMap resources.\n",
                "properties": {
                    "licenseType": {
                        "type": "string",
                        "description": "License type\n"
                    },
                    "ssoLicenseMappingGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "SSO license mapping group names for this group\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/notification:Notification": {
            "description": "Setup notifications on jobs success/failure to internal users, external email addresses or Slack channels\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// dbt Cloud allows us to create internal and external notifications\n//\n// an internal notification will send emails to the user mentioned in `user_id`\n//\n// NOTE: If internal notification settings already exist for a user, currently you MUST import\n// those first into the state file before you can create a new internal notification for that user.\n// Failure to do so, will result in the user losing access to existing notifications and dbt\n// support will need to be contacted to restore access.\n// cmd: terraform import dbtcloud_notification.prod_job_internal_notification \u003cuser_id\u003e\nconst prodJobInternalNotification = new dbtcloud.Notification(\"prod_job_internal_notification\", {\n    userId: 100,\n    onSuccesses: [prodJob.id],\n    onFailures: [12345],\n    notificationType: 1,\n});\n// we can also send \"external\" email notifications to emails to related to dbt Cloud users\nconst prodJobExternalNotification = new dbtcloud.Notification(\"prod_job_external_notification\", {\n    userId: 100,\n    onFailures: [\n        23456,\n        56788,\n    ],\n    onCancels: [prodJob.id],\n    notificationType: 4,\n    externalEmail: \"my_email@mail.com\",\n});\n// and finally, we can set up Slack notifications\nconst prodJobSlackNotifications = new dbtcloud.Notification(\"prod_job_slack_notifications\", {\n    userId: 100,\n    onFailures: [\n        23456,\n        56788,\n    ],\n    onCancels: [prodJob.id],\n    notificationType: 2,\n    slackChannelId: \"C12345ABCDE\",\n    slackChannelName: \"#my-awesome-channel\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# dbt Cloud allows us to create internal and external notifications\n#\n# an internal notification will send emails to the user mentioned in `user_id`\n#\n# NOTE: If internal notification settings already exist for a user, currently you MUST import\n# those first into the state file before you can create a new internal notification for that user.\n# Failure to do so, will result in the user losing access to existing notifications and dbt\n# support will need to be contacted to restore access.\n# cmd: terraform import dbtcloud_notification.prod_job_internal_notification \u003cuser_id\u003e\nprod_job_internal_notification = dbtcloud.Notification(\"prod_job_internal_notification\",\n    user_id=100,\n    on_successes=[prod_job[\"id\"]],\n    on_failures=[12345],\n    notification_type=1)\n# we can also send \"external\" email notifications to emails to related to dbt Cloud users\nprod_job_external_notification = dbtcloud.Notification(\"prod_job_external_notification\",\n    user_id=100,\n    on_failures=[\n        23456,\n        56788,\n    ],\n    on_cancels=[prod_job[\"id\"]],\n    notification_type=4,\n    external_email=\"my_email@mail.com\")\n# and finally, we can set up Slack notifications\nprod_job_slack_notifications = dbtcloud.Notification(\"prod_job_slack_notifications\",\n    user_id=100,\n    on_failures=[\n        23456,\n        56788,\n    ],\n    on_cancels=[prod_job[\"id\"]],\n    notification_type=2,\n    slack_channel_id=\"C12345ABCDE\",\n    slack_channel_name=\"#my-awesome-channel\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // dbt Cloud allows us to create internal and external notifications\n    //\n    // an internal notification will send emails to the user mentioned in `user_id`\n    //\n    // NOTE: If internal notification settings already exist for a user, currently you MUST import\n    // those first into the state file before you can create a new internal notification for that user.\n    // Failure to do so, will result in the user losing access to existing notifications and dbt\n    // support will need to be contacted to restore access.\n    // cmd: terraform import dbtcloud_notification.prod_job_internal_notification \u003cuser_id\u003e\n    var prodJobInternalNotification = new DbtCloud.Notification(\"prod_job_internal_notification\", new()\n    {\n        UserId = 100,\n        OnSuccesses = new[]\n        {\n            prodJob.Id,\n        },\n        OnFailures = new[]\n        {\n            12345,\n        },\n        NotificationType = 1,\n    });\n\n    // we can also send \"external\" email notifications to emails to related to dbt Cloud users\n    var prodJobExternalNotification = new DbtCloud.Notification(\"prod_job_external_notification\", new()\n    {\n        UserId = 100,\n        OnFailures = new[]\n        {\n            23456,\n            56788,\n        },\n        OnCancels = new[]\n        {\n            prodJob.Id,\n        },\n        NotificationType = 4,\n        ExternalEmail = \"my_email@mail.com\",\n    });\n\n    // and finally, we can set up Slack notifications\n    var prodJobSlackNotifications = new DbtCloud.Notification(\"prod_job_slack_notifications\", new()\n    {\n        UserId = 100,\n        OnFailures = new[]\n        {\n            23456,\n            56788,\n        },\n        OnCancels = new[]\n        {\n            prodJob.Id,\n        },\n        NotificationType = 2,\n        SlackChannelId = \"C12345ABCDE\",\n        SlackChannelName = \"#my-awesome-channel\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// dbt Cloud allows us to create internal and external notifications\n\t\t//\n\t\t// an internal notification will send emails to the user mentioned in `user_id`\n\t\t//\n\t\t// NOTE: If internal notification settings already exist for a user, currently you MUST import\n\t\t// those first into the state file before you can create a new internal notification for that user.\n\t\t// Failure to do so, will result in the user losing access to existing notifications and dbt\n\t\t// support will need to be contacted to restore access.\n\t\t// cmd: terraform import dbtcloud_notification.prod_job_internal_notification \u003cuser_id\u003e\n\t\t_, err := dbtcloud.NewNotification(ctx, \"prod_job_internal_notification\", \u0026dbtcloud.NotificationArgs{\n\t\t\tUserId: pulumi.Int(100),\n\t\t\tOnSuccesses: pulumi.IntArray{\n\t\t\t\tprodJob.Id,\n\t\t\t},\n\t\t\tOnFailures: pulumi.IntArray{\n\t\t\t\tpulumi.Int(12345),\n\t\t\t},\n\t\t\tNotificationType: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// we can also send \"external\" email notifications to emails to related to dbt Cloud users\n\t\t_, err = dbtcloud.NewNotification(ctx, \"prod_job_external_notification\", \u0026dbtcloud.NotificationArgs{\n\t\t\tUserId: pulumi.Int(100),\n\t\t\tOnFailures: pulumi.IntArray{\n\t\t\t\tpulumi.Int(23456),\n\t\t\t\tpulumi.Int(56788),\n\t\t\t},\n\t\t\tOnCancels: pulumi.IntArray{\n\t\t\t\tprodJob.Id,\n\t\t\t},\n\t\t\tNotificationType: pulumi.Int(4),\n\t\t\tExternalEmail:    pulumi.String(\"my_email@mail.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// and finally, we can set up Slack notifications\n\t\t_, err = dbtcloud.NewNotification(ctx, \"prod_job_slack_notifications\", \u0026dbtcloud.NotificationArgs{\n\t\t\tUserId: pulumi.Int(100),\n\t\t\tOnFailures: pulumi.IntArray{\n\t\t\t\tpulumi.Int(23456),\n\t\t\t\tpulumi.Int(56788),\n\t\t\t},\n\t\t\tOnCancels: pulumi.IntArray{\n\t\t\t\tprodJob.Id,\n\t\t\t},\n\t\t\tNotificationType: pulumi.Int(2),\n\t\t\tSlackChannelId:   pulumi.String(\"C12345ABCDE\"),\n\t\t\tSlackChannelName: pulumi.String(\"#my-awesome-channel\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.Notification;\nimport com.pulumi.dbtcloud.NotificationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // dbt Cloud allows us to create internal and external notifications\n        //\n        // an internal notification will send emails to the user mentioned in `user_id`\n        //\n        // NOTE: If internal notification settings already exist for a user, currently you MUST import\n        // those first into the state file before you can create a new internal notification for that user.\n        // Failure to do so, will result in the user losing access to existing notifications and dbt\n        // support will need to be contacted to restore access.\n        // cmd: terraform import dbtcloud_notification.prod_job_internal_notification \u003cuser_id\u003e\n        var prodJobInternalNotification = new Notification(\"prodJobInternalNotification\", NotificationArgs.builder()\n            .userId(100)\n            .onSuccesses(prodJob.id())\n            .onFailures(12345)\n            .notificationType(1)\n            .build());\n\n        // we can also send \"external\" email notifications to emails to related to dbt Cloud users\n        var prodJobExternalNotification = new Notification(\"prodJobExternalNotification\", NotificationArgs.builder()\n            .userId(100)\n            .onFailures(            \n                23456,\n                56788)\n            .onCancels(prodJob.id())\n            .notificationType(4)\n            .externalEmail(\"my_email@mail.com\")\n            .build());\n\n        // and finally, we can set up Slack notifications\n        var prodJobSlackNotifications = new Notification(\"prodJobSlackNotifications\", NotificationArgs.builder()\n            .userId(100)\n            .onFailures(            \n                23456,\n                56788)\n            .onCancels(prodJob.id())\n            .notificationType(2)\n            .slackChannelId(\"C12345ABCDE\")\n            .slackChannelName(\"#my-awesome-channel\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # dbt Cloud allows us to create internal and external notifications\n  # //\n  # // an internal notification will send emails to the user mentioned in `user_id`\n  # //\n  # // NOTE: If internal notification settings already exist for a user, currently you MUST import\n  # // those first into the state file before you can create a new internal notification for that user.\n  # // Failure to do so, will result in the user losing access to existing notifications and dbt\n  # // support will need to be contacted to restore access.\n  # // cmd: terraform import dbtcloud_notification.prod_job_internal_notification \u003cuser_id\u003e\n  prodJobInternalNotification:\n    type: dbtcloud:Notification\n    name: prod_job_internal_notification\n    properties:\n      userId: 100\n      onSuccesses:\n        - ${prodJob.id}\n      onFailures:\n        - 12345\n      notificationType: 1\n  # we can also send \"external\" email notifications to emails to related to dbt Cloud users\n  prodJobExternalNotification:\n    type: dbtcloud:Notification\n    name: prod_job_external_notification\n    properties:\n      userId: 100\n      onFailures:\n        - 23456\n        - 56788\n      onCancels:\n        - ${prodJob.id}\n      notificationType: 4 # the external_email is the email address that will receive the notification\n      externalEmail: my_email@mail.com\n  # and finally, we can set up Slack notifications\n  prodJobSlackNotifications:\n    type: dbtcloud:Notification\n    name: prod_job_slack_notifications\n    properties:\n      userId: 100\n      onFailures:\n        - 23456\n        - 56788\n      onCancels:\n        - ${prodJob.id}\n      notificationType: 2\n      slackChannelId: C12345ABCDE\n      slackChannelName: '#my-awesome-channel'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_notification.my_notification\n\n  id = \"notification_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_notification.my_notification\n\n  id = \"12345\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/notification:Notification my_notification \"notification_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/notification:Notification my_notification 12345\n```\n\n",
            "properties": {
                "externalEmail": {
                    "type": "string",
                    "description": "The external email to receive the notification\n"
                },
                "notificationType": {
                    "type": "integer",
                    "description": "Type of notification (1 = dbt Cloud user email (default): does not require an external_email ; 2 = Slack channel: requires `slack_channel_id` and `slack_channel_name` ; 4 = external email: requires setting an `external_email`)\n"
                },
                "onCancels": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on cancel\n"
                },
                "onFailures": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on failure\n"
                },
                "onSuccesses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on success\n"
                },
                "slackChannelId": {
                    "type": "string",
                    "description": "The ID of the Slack channel to receive the notification. It can be found at the bottom of the Slack channel settings\n"
                },
                "slackChannelName": {
                    "type": "string",
                    "description": "The name of the slack channel\n"
                },
                "state": {
                    "type": "integer",
                    "description": "State of the notification (1 = active (default), 2 = inactive)\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "Internal dbt Cloud User ID. Must be the user_id for an existing user even if the notification is an external one\n"
                }
            },
            "required": [
                "notificationType",
                "onCancels",
                "onFailures",
                "onSuccesses",
                "state",
                "userId"
            ],
            "inputProperties": {
                "externalEmail": {
                    "type": "string",
                    "description": "The external email to receive the notification\n"
                },
                "notificationType": {
                    "type": "integer",
                    "description": "Type of notification (1 = dbt Cloud user email (default): does not require an external_email ; 2 = Slack channel: requires `slack_channel_id` and `slack_channel_name` ; 4 = external email: requires setting an `external_email`)\n"
                },
                "onCancels": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on cancel\n"
                },
                "onFailures": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on failure\n"
                },
                "onSuccesses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on success\n"
                },
                "slackChannelId": {
                    "type": "string",
                    "description": "The ID of the Slack channel to receive the notification. It can be found at the bottom of the Slack channel settings\n"
                },
                "slackChannelName": {
                    "type": "string",
                    "description": "The name of the slack channel\n"
                },
                "state": {
                    "type": "integer",
                    "description": "State of the notification (1 = active (default), 2 = inactive)\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "Internal dbt Cloud User ID. Must be the user_id for an existing user even if the notification is an external one\n"
                }
            },
            "requiredInputs": [
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Notification resources.\n",
                "properties": {
                    "externalEmail": {
                        "type": "string",
                        "description": "The external email to receive the notification\n"
                    },
                    "notificationType": {
                        "type": "integer",
                        "description": "Type of notification (1 = dbt Cloud user email (default): does not require an external_email ; 2 = Slack channel: requires `slack_channel_id` and `slack_channel_name` ; 4 = external email: requires setting an `external_email`)\n"
                    },
                    "onCancels": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of job IDs to trigger the webhook on cancel\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of job IDs to trigger the webhook on failure\n"
                    },
                    "onSuccesses": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of job IDs to trigger the webhook on success\n"
                    },
                    "slackChannelId": {
                        "type": "string",
                        "description": "The ID of the Slack channel to receive the notification. It can be found at the bottom of the Slack channel settings\n"
                    },
                    "slackChannelName": {
                        "type": "string",
                        "description": "The name of the slack channel\n"
                    },
                    "state": {
                        "type": "integer",
                        "description": "State of the notification (1 = active (default), 2 = inactive)\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "Internal dbt Cloud User ID. Must be the user_id for an existing user even if the notification is an external one\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/partialLicenseMap:PartialLicenseMap": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// Developer license group mapping\nconst devLicenseMap = new dbtcloud.PartialLicenseMap(\"dev_license_map\", {\n    licenseType: \"developer\",\n    ssoLicenseMappingGroups: [\"DEV-SSO-GROUP\"],\n});\n// Read-only license mapping\nconst readOnlyLicenseMap = new dbtcloud.PartialLicenseMap(\"read_only_license_map\", {\n    licenseType: \"read_only\",\n    ssoLicenseMappingGroups: [\"READ-ONLY-SSO-GROUP\"],\n});\n// IT license mapping\nconst itLicenseMap = new dbtcloud.PartialLicenseMap(\"it_license_map\", {\n    licenseType: \"it\",\n    ssoLicenseMappingGroups: [\"IT-SSO-GROUP\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# Developer license group mapping\ndev_license_map = dbtcloud.PartialLicenseMap(\"dev_license_map\",\n    license_type=\"developer\",\n    sso_license_mapping_groups=[\"DEV-SSO-GROUP\"])\n# Read-only license mapping\nread_only_license_map = dbtcloud.PartialLicenseMap(\"read_only_license_map\",\n    license_type=\"read_only\",\n    sso_license_mapping_groups=[\"READ-ONLY-SSO-GROUP\"])\n# IT license mapping\nit_license_map = dbtcloud.PartialLicenseMap(\"it_license_map\",\n    license_type=\"it\",\n    sso_license_mapping_groups=[\"IT-SSO-GROUP\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Developer license group mapping\n    var devLicenseMap = new DbtCloud.PartialLicenseMap(\"dev_license_map\", new()\n    {\n        LicenseType = \"developer\",\n        SsoLicenseMappingGroups = new[]\n        {\n            \"DEV-SSO-GROUP\",\n        },\n    });\n\n    // Read-only license mapping\n    var readOnlyLicenseMap = new DbtCloud.PartialLicenseMap(\"read_only_license_map\", new()\n    {\n        LicenseType = \"read_only\",\n        SsoLicenseMappingGroups = new[]\n        {\n            \"READ-ONLY-SSO-GROUP\",\n        },\n    });\n\n    // IT license mapping\n    var itLicenseMap = new DbtCloud.PartialLicenseMap(\"it_license_map\", new()\n    {\n        LicenseType = \"it\",\n        SsoLicenseMappingGroups = new[]\n        {\n            \"IT-SSO-GROUP\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Developer license group mapping\n\t\t_, err := dbtcloud.NewPartialLicenseMap(ctx, \"dev_license_map\", \u0026dbtcloud.PartialLicenseMapArgs{\n\t\t\tLicenseType: pulumi.String(\"developer\"),\n\t\t\tSsoLicenseMappingGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"DEV-SSO-GROUP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read-only license mapping\n\t\t_, err = dbtcloud.NewPartialLicenseMap(ctx, \"read_only_license_map\", \u0026dbtcloud.PartialLicenseMapArgs{\n\t\t\tLicenseType: pulumi.String(\"read_only\"),\n\t\t\tSsoLicenseMappingGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"READ-ONLY-SSO-GROUP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// IT license mapping\n\t\t_, err = dbtcloud.NewPartialLicenseMap(ctx, \"it_license_map\", \u0026dbtcloud.PartialLicenseMapArgs{\n\t\t\tLicenseType: pulumi.String(\"it\"),\n\t\t\tSsoLicenseMappingGroups: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"IT-SSO-GROUP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.PartialLicenseMap;\nimport com.pulumi.dbtcloud.PartialLicenseMapArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Developer license group mapping\n        var devLicenseMap = new PartialLicenseMap(\"devLicenseMap\", PartialLicenseMapArgs.builder()\n            .licenseType(\"developer\")\n            .ssoLicenseMappingGroups(\"DEV-SSO-GROUP\")\n            .build());\n\n        // Read-only license mapping\n        var readOnlyLicenseMap = new PartialLicenseMap(\"readOnlyLicenseMap\", PartialLicenseMapArgs.builder()\n            .licenseType(\"read_only\")\n            .ssoLicenseMappingGroups(\"READ-ONLY-SSO-GROUP\")\n            .build());\n\n        // IT license mapping\n        var itLicenseMap = new PartialLicenseMap(\"itLicenseMap\", PartialLicenseMapArgs.builder()\n            .licenseType(\"it\")\n            .ssoLicenseMappingGroups(\"IT-SSO-GROUP\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Developer license group mapping\n  devLicenseMap:\n    type: dbtcloud:PartialLicenseMap\n    name: dev_license_map\n    properties:\n      licenseType: developer\n      ssoLicenseMappingGroups:\n        - DEV-SSO-GROUP\n  # Read-only license mapping\n  readOnlyLicenseMap:\n    type: dbtcloud:PartialLicenseMap\n    name: read_only_license_map\n    properties:\n      licenseType: read_only\n      ssoLicenseMappingGroups:\n        - READ-ONLY-SSO-GROUP\n  # IT license mapping\n  itLicenseMap:\n    type: dbtcloud:PartialLicenseMap\n    name: it_license_map\n    properties:\n      licenseType: it\n      ssoLicenseMappingGroups:\n        - IT-SSO-GROUP\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "licenseType": {
                    "type": "string",
                    "description": "The license type to update\n"
                },
                "ssoLicenseMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of SSO groups to map to the license type.\n"
                }
            },
            "required": [
                "licenseType",
                "ssoLicenseMappingGroups"
            ],
            "inputProperties": {
                "licenseType": {
                    "type": "string",
                    "description": "The license type to update\n"
                },
                "ssoLicenseMappingGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of SSO groups to map to the license type.\n"
                }
            },
            "requiredInputs": [
                "licenseType",
                "ssoLicenseMappingGroups"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PartialLicenseMap resources.\n",
                "properties": {
                    "licenseType": {
                        "type": "string",
                        "description": "The license type to update\n"
                    },
                    "ssoLicenseMappingGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of SSO groups to map to the license type.\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/partialNotification:PartialNotification": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// the config is the same as for `dbtcloud_notification`\nconst prodJobInternalNotification = new dbtcloud.PartialNotification(\"prod_job_internal_notification\", {\n    userId: 100,\n    onSuccesses: [prodJob.id],\n    onFailures: [12345],\n    notificationType: 1,\n});\n// we can also send \"external\" email notifications to emails to related to dbt Cloud users\nconst prodJobExternalNotification = new dbtcloud.PartialNotification(\"prod_job_external_notification\", {\n    userId: 100,\n    onFailures: [\n        23456,\n        56788,\n    ],\n    onCancels: [prodJob.id],\n    notificationType: 4,\n    externalEmail: \"my_email@mail.com\",\n});\n// and finally, we can set up Slack notifications\nconst prodJobSlackNotifications = new dbtcloud.PartialNotification(\"prod_job_slack_notifications\", {\n    userId: 100,\n    onFailures: [\n        23456,\n        56788,\n    ],\n    onCancels: [prodJob.id],\n    notificationType: 2,\n    slackChannelId: \"C12345ABCDE\",\n    slackChannelName: \"#my-awesome-channel\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# the config is the same as for `dbtcloud_notification`\nprod_job_internal_notification = dbtcloud.PartialNotification(\"prod_job_internal_notification\",\n    user_id=100,\n    on_successes=[prod_job[\"id\"]],\n    on_failures=[12345],\n    notification_type=1)\n# we can also send \"external\" email notifications to emails to related to dbt Cloud users\nprod_job_external_notification = dbtcloud.PartialNotification(\"prod_job_external_notification\",\n    user_id=100,\n    on_failures=[\n        23456,\n        56788,\n    ],\n    on_cancels=[prod_job[\"id\"]],\n    notification_type=4,\n    external_email=\"my_email@mail.com\")\n# and finally, we can set up Slack notifications\nprod_job_slack_notifications = dbtcloud.PartialNotification(\"prod_job_slack_notifications\",\n    user_id=100,\n    on_failures=[\n        23456,\n        56788,\n    ],\n    on_cancels=[prod_job[\"id\"]],\n    notification_type=2,\n    slack_channel_id=\"C12345ABCDE\",\n    slack_channel_name=\"#my-awesome-channel\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // the config is the same as for `dbtcloud_notification`\n    var prodJobInternalNotification = new DbtCloud.PartialNotification(\"prod_job_internal_notification\", new()\n    {\n        UserId = 100,\n        OnSuccesses = new[]\n        {\n            prodJob.Id,\n        },\n        OnFailures = new[]\n        {\n            12345,\n        },\n        NotificationType = 1,\n    });\n\n    // we can also send \"external\" email notifications to emails to related to dbt Cloud users\n    var prodJobExternalNotification = new DbtCloud.PartialNotification(\"prod_job_external_notification\", new()\n    {\n        UserId = 100,\n        OnFailures = new[]\n        {\n            23456,\n            56788,\n        },\n        OnCancels = new[]\n        {\n            prodJob.Id,\n        },\n        NotificationType = 4,\n        ExternalEmail = \"my_email@mail.com\",\n    });\n\n    // and finally, we can set up Slack notifications\n    var prodJobSlackNotifications = new DbtCloud.PartialNotification(\"prod_job_slack_notifications\", new()\n    {\n        UserId = 100,\n        OnFailures = new[]\n        {\n            23456,\n            56788,\n        },\n        OnCancels = new[]\n        {\n            prodJob.Id,\n        },\n        NotificationType = 2,\n        SlackChannelId = \"C12345ABCDE\",\n        SlackChannelName = \"#my-awesome-channel\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// the config is the same as for `dbtcloud_notification`\n\t\t_, err := dbtcloud.NewPartialNotification(ctx, \"prod_job_internal_notification\", \u0026dbtcloud.PartialNotificationArgs{\n\t\t\tUserId: pulumi.Int(100),\n\t\t\tOnSuccesses: pulumi.IntArray{\n\t\t\t\tprodJob.Id,\n\t\t\t},\n\t\t\tOnFailures: pulumi.IntArray{\n\t\t\t\tpulumi.Int(12345),\n\t\t\t},\n\t\t\tNotificationType: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// we can also send \"external\" email notifications to emails to related to dbt Cloud users\n\t\t_, err = dbtcloud.NewPartialNotification(ctx, \"prod_job_external_notification\", \u0026dbtcloud.PartialNotificationArgs{\n\t\t\tUserId: pulumi.Int(100),\n\t\t\tOnFailures: pulumi.IntArray{\n\t\t\t\tpulumi.Int(23456),\n\t\t\t\tpulumi.Int(56788),\n\t\t\t},\n\t\t\tOnCancels: pulumi.IntArray{\n\t\t\t\tprodJob.Id,\n\t\t\t},\n\t\t\tNotificationType: pulumi.Int(4),\n\t\t\tExternalEmail:    pulumi.String(\"my_email@mail.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// and finally, we can set up Slack notifications\n\t\t_, err = dbtcloud.NewPartialNotification(ctx, \"prod_job_slack_notifications\", \u0026dbtcloud.PartialNotificationArgs{\n\t\t\tUserId: pulumi.Int(100),\n\t\t\tOnFailures: pulumi.IntArray{\n\t\t\t\tpulumi.Int(23456),\n\t\t\t\tpulumi.Int(56788),\n\t\t\t},\n\t\t\tOnCancels: pulumi.IntArray{\n\t\t\t\tprodJob.Id,\n\t\t\t},\n\t\t\tNotificationType: pulumi.Int(2),\n\t\t\tSlackChannelId:   pulumi.String(\"C12345ABCDE\"),\n\t\t\tSlackChannelName: pulumi.String(\"#my-awesome-channel\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.PartialNotification;\nimport com.pulumi.dbtcloud.PartialNotificationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // the config is the same as for `dbtcloud_notification`\n        var prodJobInternalNotification = new PartialNotification(\"prodJobInternalNotification\", PartialNotificationArgs.builder()\n            .userId(100)\n            .onSuccesses(prodJob.id())\n            .onFailures(12345)\n            .notificationType(1)\n            .build());\n\n        // we can also send \"external\" email notifications to emails to related to dbt Cloud users\n        var prodJobExternalNotification = new PartialNotification(\"prodJobExternalNotification\", PartialNotificationArgs.builder()\n            .userId(100)\n            .onFailures(            \n                23456,\n                56788)\n            .onCancels(prodJob.id())\n            .notificationType(4)\n            .externalEmail(\"my_email@mail.com\")\n            .build());\n\n        // and finally, we can set up Slack notifications\n        var prodJobSlackNotifications = new PartialNotification(\"prodJobSlackNotifications\", PartialNotificationArgs.builder()\n            .userId(100)\n            .onFailures(            \n                23456,\n                56788)\n            .onCancels(prodJob.id())\n            .notificationType(2)\n            .slackChannelId(\"C12345ABCDE\")\n            .slackChannelName(\"#my-awesome-channel\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # the config is the same as for `dbtcloud_notification`\n  prodJobInternalNotification:\n    type: dbtcloud:PartialNotification\n    name: prod_job_internal_notification\n    properties:\n      userId: 100\n      onSuccesses:\n        - ${prodJob.id}\n      onFailures:\n        - 12345\n      notificationType: 1\n  # we can also send \"external\" email notifications to emails to related to dbt Cloud users\n  prodJobExternalNotification:\n    type: dbtcloud:PartialNotification\n    name: prod_job_external_notification\n    properties:\n      userId: 100\n      onFailures:\n        - 23456\n        - 56788\n      onCancels:\n        - ${prodJob.id}\n      notificationType: 4 # the external_email is the email address that will receive the notification\n      externalEmail: my_email@mail.com\n  # and finally, we can set up Slack notifications\n  prodJobSlackNotifications:\n    type: dbtcloud:PartialNotification\n    name: prod_job_slack_notifications\n    properties:\n      userId: 100\n      onFailures:\n        - 23456\n        - 56788\n      onCancels:\n        - ${prodJob.id}\n      notificationType: 2\n      slackChannelId: C12345ABCDE\n      slackChannelName: '#my-awesome-channel'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "externalEmail": {
                    "type": "string",
                    "description": "The external email to receive the notification [global, used as identifier]\n"
                },
                "notificationType": {
                    "type": "integer",
                    "description": "Type of notification (1 = dbt Cloud user email (default): does not require an external_email ; 2 = Slack channel: requires `slack_channel_id` and `slack_channel_name` ; 4 = external email: requires setting an `external_email`) [global, used as identifier]\n"
                },
                "onCancels": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on cancel. Those will be added/removed when config is added/removed.\n"
                },
                "onFailures": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on failure Those will be added/removed when config is added/removed.\n"
                },
                "onSuccesses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on success Those will be added/removed when config is added/removed.\n"
                },
                "slackChannelId": {
                    "type": "string",
                    "description": "The ID of the Slack channel to receive the notification. It can be found at the bottom of the Slack channel settings [global, used as identifier]\n"
                },
                "slackChannelName": {
                    "type": "string",
                    "description": "The name of the slack channel [global, used as identifier]\n"
                },
                "state": {
                    "type": "integer",
                    "description": "State of the notification (1 = active (default), 2 = inactive) [global]\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "Internal dbt Cloud User ID. Must be the user_id for an existing user even if the notification is an external one [global]\n"
                }
            },
            "required": [
                "notificationType",
                "onCancels",
                "onFailures",
                "onSuccesses",
                "state",
                "userId"
            ],
            "inputProperties": {
                "externalEmail": {
                    "type": "string",
                    "description": "The external email to receive the notification [global, used as identifier]\n"
                },
                "notificationType": {
                    "type": "integer",
                    "description": "Type of notification (1 = dbt Cloud user email (default): does not require an external_email ; 2 = Slack channel: requires `slack_channel_id` and `slack_channel_name` ; 4 = external email: requires setting an `external_email`) [global, used as identifier]\n"
                },
                "onCancels": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on cancel. Those will be added/removed when config is added/removed.\n"
                },
                "onFailures": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on failure Those will be added/removed when config is added/removed.\n"
                },
                "onSuccesses": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook on success Those will be added/removed when config is added/removed.\n"
                },
                "slackChannelId": {
                    "type": "string",
                    "description": "The ID of the Slack channel to receive the notification. It can be found at the bottom of the Slack channel settings [global, used as identifier]\n"
                },
                "slackChannelName": {
                    "type": "string",
                    "description": "The name of the slack channel [global, used as identifier]\n"
                },
                "state": {
                    "type": "integer",
                    "description": "State of the notification (1 = active (default), 2 = inactive) [global]\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "Internal dbt Cloud User ID. Must be the user_id for an existing user even if the notification is an external one [global]\n"
                }
            },
            "requiredInputs": [
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PartialNotification resources.\n",
                "properties": {
                    "externalEmail": {
                        "type": "string",
                        "description": "The external email to receive the notification [global, used as identifier]\n"
                    },
                    "notificationType": {
                        "type": "integer",
                        "description": "Type of notification (1 = dbt Cloud user email (default): does not require an external_email ; 2 = Slack channel: requires `slack_channel_id` and `slack_channel_name` ; 4 = external email: requires setting an `external_email`) [global, used as identifier]\n"
                    },
                    "onCancels": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of job IDs to trigger the webhook on cancel. Those will be added/removed when config is added/removed.\n"
                    },
                    "onFailures": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of job IDs to trigger the webhook on failure Those will be added/removed when config is added/removed.\n"
                    },
                    "onSuccesses": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of job IDs to trigger the webhook on success Those will be added/removed when config is added/removed.\n"
                    },
                    "slackChannelId": {
                        "type": "string",
                        "description": "The ID of the Slack channel to receive the notification. It can be found at the bottom of the Slack channel settings [global, used as identifier]\n"
                    },
                    "slackChannelName": {
                        "type": "string",
                        "description": "The name of the slack channel [global, used as identifier]\n"
                    },
                    "state": {
                        "type": "integer",
                        "description": "State of the notification (1 = active (default), 2 = inactive) [global]\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "Internal dbt Cloud User ID. Must be the user_id for an existing user even if the notification is an external one [global]\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/postgresCredential:PostgresCredential": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst postgresProdCredential = new dbtcloud.PostgresCredential(\"postgres_prod_credential\", {\n    isActive: true,\n    projectId: dbtProject.id,\n    type: \"postgres\",\n    defaultSchema: \"my_schema\",\n    username: \"my_username\",\n    password: \"my_password\",\n    numThreads: 16,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\npostgres_prod_credential = dbtcloud.PostgresCredential(\"postgres_prod_credential\",\n    is_active=True,\n    project_id=dbt_project[\"id\"],\n    type=\"postgres\",\n    default_schema=\"my_schema\",\n    username=\"my_username\",\n    password=\"my_password\",\n    num_threads=16)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var postgresProdCredential = new DbtCloud.PostgresCredential(\"postgres_prod_credential\", new()\n    {\n        IsActive = true,\n        ProjectId = dbtProject.Id,\n        Type = \"postgres\",\n        DefaultSchema = \"my_schema\",\n        Username = \"my_username\",\n        Password = \"my_password\",\n        NumThreads = 16,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewPostgresCredential(ctx, \"postgres_prod_credential\", \u0026dbtcloud.PostgresCredentialArgs{\n\t\t\tIsActive:      pulumi.Bool(true),\n\t\t\tProjectId:     pulumi.Any(dbtProject.Id),\n\t\t\tType:          pulumi.String(\"postgres\"),\n\t\t\tDefaultSchema: pulumi.String(\"my_schema\"),\n\t\t\tUsername:      pulumi.String(\"my_username\"),\n\t\t\tPassword:      pulumi.String(\"my_password\"),\n\t\t\tNumThreads:    pulumi.Int(16),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.PostgresCredential;\nimport com.pulumi.dbtcloud.PostgresCredentialArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var postgresProdCredential = new PostgresCredential(\"postgresProdCredential\", PostgresCredentialArgs.builder()\n            .isActive(true)\n            .projectId(dbtProject.id())\n            .type(\"postgres\")\n            .defaultSchema(\"my_schema\")\n            .username(\"my_username\")\n            .password(\"my_password\")\n            .numThreads(16)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  postgresProdCredential:\n    type: dbtcloud:PostgresCredential\n    name: postgres_prod_credential\n    properties:\n      isActive: true\n      projectId: ${dbtProject.id}\n      type: postgres\n      defaultSchema: my_schema\n      username: my_username\n      password: my_password\n      numThreads: 16\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_postgres_credential.my_credential\n\n  id = \"project_id:credential_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_postgres_credential.my_credential\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/postgresCredential:PostgresCredential my_credential \"project_id:credential_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/postgresCredential:PostgresCredential my_credential 12345:6789\n```\n\n",
            "properties": {
                "credentialId": {
                    "type": "integer",
                    "description": "The system Postgres/Redshift/AlloyDB credential ID\n"
                },
                "defaultSchema": {
                    "type": "string",
                    "description": "Default schema name\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the Postgres/Redshift/AlloyDB credential is active\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for Postgres/Redshift/AlloyDB\n",
                    "secret": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Postgres/Redshift/AlloyDB credential in\n"
                },
                "targetName": {
                    "type": "string",
                    "description": "Default schema name\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of connection. One of (postgres/redshift). Use postgres for alloydb connections\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username for Postgres/Redshift/AlloyDB\n"
                }
            },
            "required": [
                "credentialId",
                "defaultSchema",
                "projectId",
                "type",
                "username"
            ],
            "inputProperties": {
                "defaultSchema": {
                    "type": "string",
                    "description": "Default schema name\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the Postgres/Redshift/AlloyDB credential is active\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for Postgres/Redshift/AlloyDB\n",
                    "secret": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Postgres/Redshift/AlloyDB credential in\n",
                    "willReplaceOnChanges": true
                },
                "targetName": {
                    "type": "string",
                    "description": "Default schema name\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of connection. One of (postgres/redshift). Use postgres for alloydb connections\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username for Postgres/Redshift/AlloyDB\n"
                }
            },
            "requiredInputs": [
                "defaultSchema",
                "projectId",
                "type",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PostgresCredential resources.\n",
                "properties": {
                    "credentialId": {
                        "type": "integer",
                        "description": "The system Postgres/Redshift/AlloyDB credential ID\n"
                    },
                    "defaultSchema": {
                        "type": "string",
                        "description": "Default schema name\n"
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Whether the Postgres/Redshift/AlloyDB credential is active\n"
                    },
                    "numThreads": {
                        "type": "integer",
                        "description": "Number of threads to use\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password for Postgres/Redshift/AlloyDB\n",
                        "secret": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the Postgres/Redshift/AlloyDB credential in\n",
                        "willReplaceOnChanges": true
                    },
                    "targetName": {
                        "type": "string",
                        "description": "Default schema name\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of connection. One of (postgres/redshift). Use postgres for alloydb connections\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username for Postgres/Redshift/AlloyDB\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/project:Project": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst dbtProject = new dbtcloud.Project(\"dbt_project\", {name: \"Analytics\"});\nconst dbtProjectWithSubdir = new dbtcloud.Project(\"dbt_project_with_subdir\", {\n    name: \"Analytics in Subdir\",\n    dbtProjectSubdirectory: \"/path\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ndbt_project = dbtcloud.Project(\"dbt_project\", name=\"Analytics\")\ndbt_project_with_subdir = dbtcloud.Project(\"dbt_project_with_subdir\",\n    name=\"Analytics in Subdir\",\n    dbt_project_subdirectory=\"/path\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dbtProject = new DbtCloud.Project(\"dbt_project\", new()\n    {\n        Name = \"Analytics\",\n    });\n\n    var dbtProjectWithSubdir = new DbtCloud.Project(\"dbt_project_with_subdir\", new()\n    {\n        Name = \"Analytics in Subdir\",\n        DbtProjectSubdirectory = \"/path\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewProject(ctx, \"dbt_project\", \u0026dbtcloud.ProjectArgs{\n\t\t\tName: pulumi.String(\"Analytics\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbtcloud.NewProject(ctx, \"dbt_project_with_subdir\", \u0026dbtcloud.ProjectArgs{\n\t\t\tName:                   pulumi.String(\"Analytics in Subdir\"),\n\t\t\tDbtProjectSubdirectory: pulumi.String(\"/path\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.Project;\nimport com.pulumi.dbtcloud.ProjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dbtProject = new Project(\"dbtProject\", ProjectArgs.builder()\n            .name(\"Analytics\")\n            .build());\n\n        var dbtProjectWithSubdir = new Project(\"dbtProjectWithSubdir\", ProjectArgs.builder()\n            .name(\"Analytics in Subdir\")\n            .dbtProjectSubdirectory(\"/path\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dbtProject:\n    type: dbtcloud:Project\n    name: dbt_project\n    properties:\n      name: Analytics\n  dbtProjectWithSubdir:\n    type: dbtcloud:Project\n    name: dbt_project_with_subdir\n    properties:\n      name: Analytics in Subdir\n      dbtProjectSubdirectory: /path\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_project.my_project\n\n  id = \"project_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_project.my_project\n\n  id = \"12345\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/project:Project my_project \"project_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/project:Project my_project 12345\n```\n\n",
            "properties": {
                "dbtProjectSubdirectory": {
                    "type": "string",
                    "description": "dbt project subdirectory path\n"
                },
                "name": {
                    "type": "string",
                    "description": "Project name\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "dbtProjectSubdirectory": {
                    "type": "string",
                    "description": "dbt project subdirectory path\n"
                },
                "name": {
                    "type": "string",
                    "description": "Project name\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Project resources.\n",
                "properties": {
                    "dbtProjectSubdirectory": {
                        "type": "string",
                        "description": "dbt project subdirectory path\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Project name\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/projectArtefacts:ProjectArtefacts": {
            "description": "[Deprecated] Resource for mentioning what jobs are the source of truth for the legacy dbt Docs and dbt Source Freshness pages. dbt Explorer doesn't require this config anymore.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myProjectArtefacts = new dbtcloud.ProjectArtefacts(\"my_project_artefacts\", {\n    projectId: dbtProject.id,\n    docsJobId: prodJob.id,\n    freshnessJobId: prodJob.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_project_artefacts = dbtcloud.ProjectArtefacts(\"my_project_artefacts\",\n    project_id=dbt_project[\"id\"],\n    docs_job_id=prod_job[\"id\"],\n    freshness_job_id=prod_job[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myProjectArtefacts = new DbtCloud.ProjectArtefacts(\"my_project_artefacts\", new()\n    {\n        ProjectId = dbtProject.Id,\n        DocsJobId = prodJob.Id,\n        FreshnessJobId = prodJob.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewProjectArtefacts(ctx, \"my_project_artefacts\", \u0026dbtcloud.ProjectArtefactsArgs{\n\t\t\tProjectId:      pulumi.Any(dbtProject.Id),\n\t\t\tDocsJobId:      pulumi.Any(prodJob.Id),\n\t\t\tFreshnessJobId: pulumi.Any(prodJob.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.ProjectArtefacts;\nimport com.pulumi.dbtcloud.ProjectArtefactsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myProjectArtefacts = new ProjectArtefacts(\"myProjectArtefacts\", ProjectArtefactsArgs.builder()\n            .projectId(dbtProject.id())\n            .docsJobId(prodJob.id())\n            .freshnessJobId(prodJob.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myProjectArtefacts:\n    type: dbtcloud:ProjectArtefacts\n    name: my_project_artefacts\n    properties:\n      projectId: ${dbtProject.id}\n      docsJobId: ${prodJob.id}\n      freshnessJobId: ${prodJob.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_project_artefacts.my_artefacts\n\n  id = \"project_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_project_artefacts.my_artefacts\n\n  id = \"12345\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/projectArtefacts:ProjectArtefacts my_artefacts \"project_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/projectArtefacts:ProjectArtefacts my_artefacts 12345\n```\n\n",
            "properties": {
                "docsJobId": {
                    "type": "integer",
                    "description": "Docs Job ID\n"
                },
                "freshnessJobId": {
                    "type": "integer",
                    "description": "Freshness Job ID\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID\n"
                }
            },
            "required": [
                "projectId"
            ],
            "inputProperties": {
                "docsJobId": {
                    "type": "integer",
                    "description": "Docs Job ID\n"
                },
                "freshnessJobId": {
                    "type": "integer",
                    "description": "Freshness Job ID\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectArtefacts resources.\n",
                "properties": {
                    "docsJobId": {
                        "type": "integer",
                        "description": "Docs Job ID\n"
                    },
                    "freshnessJobId": {
                        "type": "integer",
                        "description": "Freshness Job ID\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/projectConnection:ProjectConnection": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst dbtProjectConnection = new dbtcloud.ProjectConnection(\"dbt_project_connection\", {\n    projectId: dbtProject.id,\n    connectionId: dbtConnection.connectionId,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ndbt_project_connection = dbtcloud.ProjectConnection(\"dbt_project_connection\",\n    project_id=dbt_project[\"id\"],\n    connection_id=dbt_connection[\"connectionId\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dbtProjectConnection = new DbtCloud.ProjectConnection(\"dbt_project_connection\", new()\n    {\n        ProjectId = dbtProject.Id,\n        ConnectionId = dbtConnection.ConnectionId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewProjectConnection(ctx, \"dbt_project_connection\", \u0026dbtcloud.ProjectConnectionArgs{\n\t\t\tProjectId:    pulumi.Any(dbtProject.Id),\n\t\t\tConnectionId: pulumi.Any(dbtConnection.ConnectionId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.ProjectConnection;\nimport com.pulumi.dbtcloud.ProjectConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dbtProjectConnection = new ProjectConnection(\"dbtProjectConnection\", ProjectConnectionArgs.builder()\n            .projectId(dbtProject.id())\n            .connectionId(dbtConnection.connectionId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dbtProjectConnection:\n    type: dbtcloud:ProjectConnection\n    name: dbt_project_connection\n    properties:\n      projectId: ${dbtProject.id}\n      connectionId: ${dbtConnection.connectionId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_project_connection.my_project\n\n  id = \"project_id:connection_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_project_connection.my_project\n\n  id = \"12345:5678\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/projectConnection:ProjectConnection my_project \"project_id:connection_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/projectConnection:ProjectConnection my_project 12345:5678\n```\n\n",
            "properties": {
                "connectionId": {
                    "type": "integer",
                    "description": "Connection ID\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID\n"
                }
            },
            "required": [
                "connectionId",
                "projectId"
            ],
            "inputProperties": {
                "connectionId": {
                    "type": "integer",
                    "description": "Connection ID\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "connectionId",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectConnection resources.\n",
                "properties": {
                    "connectionId": {
                        "type": "integer",
                        "description": "Connection ID\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/projectRepository:ProjectRepository": {
            "description": "This resource allows you to link a dbt Cloud project to a git repository.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst dbtProjectRepository = new dbtcloud.ProjectRepository(\"dbt_project_repository\", {\n    projectId: dbtProject.id,\n    repositoryId: dbtRepository.repositoryId,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ndbt_project_repository = dbtcloud.ProjectRepository(\"dbt_project_repository\",\n    project_id=dbt_project[\"id\"],\n    repository_id=dbt_repository[\"repositoryId\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dbtProjectRepository = new DbtCloud.ProjectRepository(\"dbt_project_repository\", new()\n    {\n        ProjectId = dbtProject.Id,\n        RepositoryId = dbtRepository.RepositoryId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewProjectRepository(ctx, \"dbt_project_repository\", \u0026dbtcloud.ProjectRepositoryArgs{\n\t\t\tProjectId:    pulumi.Any(dbtProject.Id),\n\t\t\tRepositoryId: pulumi.Any(dbtRepository.RepositoryId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.ProjectRepository;\nimport com.pulumi.dbtcloud.ProjectRepositoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dbtProjectRepository = new ProjectRepository(\"dbtProjectRepository\", ProjectRepositoryArgs.builder()\n            .projectId(dbtProject.id())\n            .repositoryId(dbtRepository.repositoryId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dbtProjectRepository:\n    type: dbtcloud:ProjectRepository\n    name: dbt_project_repository\n    properties:\n      projectId: ${dbtProject.id}\n      repositoryId: ${dbtRepository.repositoryId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_project_repository.my_project\n\n  id = \"project_id:repository_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_project_repository.my_project\n\n  id = \"12345:5678\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/projectRepository:ProjectRepository my_project \"project_id:repository_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/projectRepository:ProjectRepository my_project 12345:5678\n```\n\n",
            "properties": {
                "projectId": {
                    "type": "integer",
                    "description": "Project ID\n"
                },
                "repositoryId": {
                    "type": "integer",
                    "description": "Repository ID\n"
                }
            },
            "required": [
                "projectId",
                "repositoryId"
            ],
            "inputProperties": {
                "projectId": {
                    "type": "integer",
                    "description": "Project ID\n",
                    "willReplaceOnChanges": true
                },
                "repositoryId": {
                    "type": "integer",
                    "description": "Repository ID\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "repositoryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectRepository resources.\n",
                "properties": {
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID\n",
                        "willReplaceOnChanges": true
                    },
                    "repositoryId": {
                        "type": "integer",
                        "description": "Repository ID\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/repository:Repository": {
            "description": "This resource allows you to manage connections to git repositories in dbt Cloud.\n\nBy itself, this resource won't show you the repository in the dbt Cloud UI. \nYou will need to also set up a `dbtcloud.ProjectRepository` resource as well to link your dbt Cloud project and the git repository.\n\nIn order to find the `github_installation_id`, you can log in to dbt Cloud, replace `\u003cdbt_cloud_url\u003e` by your dbt Cloud\nURL and run the following commands in the Google Chrome console:\n\n```javascript\ndbt_cloud_api_result = await (fetch('https://\u003cdbt_cloud_url\u003e/api/v2/integrations/github/installations/').then(res =\u003e res.json()));\nconsole.log(\"github_application_id: \" + dbt_cloud_api_result.filter(res =\u003e res[\"access_tokens_url\"].includes(\"github\"))[0][\"id\"]);\n```\n\nAlternatively, you can go to the page `https://\u003cdbt_cloud_url\u003e/api/v2/integrations/github/installations/` and read the\nvalue of `id`  or use the `http` provider to retrieve it automatically like in the example below.\n\n{{% examples %}}\n## Example Usage\n\n### repo cloned via the GitHub integration, manually entering the `github_installation_id`\nresource \"dbtcloud.Repository\" \"github_repo\" {\n  project_id             = dbtcloud_project.dbt_project.id\n  remote_url             = \"git@github.com:\u003cgithub_org\u003e/\u003cgithub_repo\u003e.git\"\n  github_installation_id = 9876\n  git_clone_strategy     = \"github_app\"\n}\n\n\n### repo cloned via the GitHub integration, with auto-retrieval of the `github_installation_id`\n# here, we assume that `token` and `host_url` are respectively accessible via `var.dbt_token` and `var.dbt_host_url`\n# NOTE: the following requires connecting via a user token and can't be retrieved with a service token\ndata \"http\" \"github_installations_response\" {\n  url = format(\"%s/v2/integrations/github/installations/\", var.dbt_host_url)\n  request_headers = {\n    Authorization = format(\"Bearer %s\", var.dbt_token)\n  }\n}\n\nlocals {\n  github_installation_id = jsondecode(data.http.github_installations_response.response_body)[0].id\n}\n\nresource \"dbtcloud.Repository\" \"github_repo_other\" {\n  project_id             = dbtcloud_project.dbt_project.id\n  remote_url             = \"git@github.com:\u003cgithub_org\u003e/\u003cgithub_repo\u003e.git\"\n  github_installation_id = local.github_installation_id\n  git_clone_strategy     = \"github_app\"\n}\n\n\n### repo cloned via the GitLab integration\n# as of 15 Sept 2023 this resource requires using a user token and can't be set with a service token - CC-791\nresource \"dbtcloud.Repository\" \"gitlab_repo\" {\n  project_id         = dbtcloud_project.dbt_project.id\n  remote_url         = \"\u003cgitlab-group\u003e/\u003cgitlab-project\u003e\"\n  gitlab_project_id  = 8765\n  git_clone_strategy = \"deploy_token\"\n}\n\n\n### repo cloned via the deploy token strategy\nresource \"dbtcloud.Repository\" \"deploy_repo\" {\n  project_id         = dbtcloud_project.dbt_project.id\n  remote_url         = \"git://github.com/\u003cgithub_org\u003e/\u003cgithub_repo\u003e.git\"\n  git_clone_strategy = \"deploy_key\"\n}\n\n\n### repo cloned via the Azure Dev Ops integration\nresource \"dbtcloud.Repository\" \"ado_repo\" {\n  project_id = dbtcloud_project.dbt_project.id\n  # the following values can be added manually (IDs can be retrieved from the ADO API) or via data sources\n  # remote_url                              = \"https://abc@dev.azure.com/abc/def/_git/my_repo\"\n  # azure_active_directory_project_id       = \"12345678-1234-1234-1234-1234567890ab\"\n  # azure_active_directory_repository_id    = \"87654321-4321-abcd-abcd-464327678642\"\n  remote_url                                = data.dbtcloud_azure_dev_ops_repository.my_devops_repo.remote_url\n  azure_active_directory_repository_id      = data.dbtcloud_azure_dev_ops_repository.my_devops_repo.id\n  azure_active_directory_project_id         = data.dbtcloud_azure_dev_ops_project.my_devops_project.id\n  azure_bypass_webhook_registration_failure = false\n  git_clone_strategy                        = \"azure_active_directory_app\"\n}\n```\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_repository.my_repository\n\n  id = \"project_id:repository_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_repository.my_repository\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/repository:Repository my_repository \"project_id:repository_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/repository:Repository my_repository 12345:6789\n```\n\n\n{{% /examples %}}",
            "properties": {
                "azureActiveDirectoryProjectId": {
                    "type": "string",
                    "description": "The Azure Dev Ops project ID. It can be retrieved via the Azure API or using the data source `dbtcloud.getAzureDevOpsProject` and the project name - (for ADO native integration only)\n"
                },
                "azureActiveDirectoryRepositoryId": {
                    "type": "string",
                    "description": "The Azure Dev Ops repository ID. It can be retrieved via the Azure API or using the data source `dbtcloud.getAzureDevOpsRepository` along with the ADO Project ID and the repository name - (for ADO native integration only)\n"
                },
                "azureBypassWebhookRegistrationFailure": {
                    "type": "boolean",
                    "description": "If set to False (the default), the connection will fail if the service user doesn't have access to set webhooks (required for auto-triggering CI jobs). If set to True, the connection will be successful but no automated CI job will be triggered - (for ADO native integration only)\n"
                },
                "deployKey": {
                    "type": "string",
                    "description": "Public key generated by dbt when using `deploy_key` clone strategy\n"
                },
                "fetchDeployKey": {
                    "type": "boolean",
                    "description": "Whether we should return the public deploy key - (for the `deploy_key` strategy)\n",
                    "deprecationMessage": "This field is deprecated and will be removed in a future version of the provider, please remove it from your configuration. The key is always fetched when the clone strategy is `deploy_key`"
                },
                "gitCloneStrategy": {
                    "type": "string",
                    "description": "Git clone strategy for the repository. Can be `deploy_key` (default) for cloning via SSH Deploy Key, `github_app` for GitHub native integration, `deploy_token` for the GitLab native integration and `azure_active_directory_app` for ADO native integration\n"
                },
                "githubInstallationId": {
                    "type": "integer",
                    "description": "Identifier for the GitHub App - (for GitHub native integration only)\n"
                },
                "gitlabProjectId": {
                    "type": "integer",
                    "description": "Identifier for the Gitlab project -  (for GitLab native integration only)\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the repository is active\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the repository in\n"
                },
                "remoteUrl": {
                    "type": "string",
                    "description": "Git URL for the repository or \u003cGroup\u003e/\u003cProject\u003e for Gitlab\n"
                },
                "repositoryCredentialsId": {
                    "type": "integer",
                    "description": "Credentials ID for the repository (From the repository side not the dbt Cloud ID)\n"
                },
                "repositoryId": {
                    "type": "integer",
                    "description": "Repository Identifier\n"
                }
            },
            "required": [
                "deployKey",
                "projectId",
                "remoteUrl",
                "repositoryCredentialsId",
                "repositoryId"
            ],
            "inputProperties": {
                "azureActiveDirectoryProjectId": {
                    "type": "string",
                    "description": "The Azure Dev Ops project ID. It can be retrieved via the Azure API or using the data source `dbtcloud.getAzureDevOpsProject` and the project name - (for ADO native integration only)\n",
                    "willReplaceOnChanges": true
                },
                "azureActiveDirectoryRepositoryId": {
                    "type": "string",
                    "description": "The Azure Dev Ops repository ID. It can be retrieved via the Azure API or using the data source `dbtcloud.getAzureDevOpsRepository` along with the ADO Project ID and the repository name - (for ADO native integration only)\n",
                    "willReplaceOnChanges": true
                },
                "azureBypassWebhookRegistrationFailure": {
                    "type": "boolean",
                    "description": "If set to False (the default), the connection will fail if the service user doesn't have access to set webhooks (required for auto-triggering CI jobs). If set to True, the connection will be successful but no automated CI job will be triggered - (for ADO native integration only)\n",
                    "willReplaceOnChanges": true
                },
                "fetchDeployKey": {
                    "type": "boolean",
                    "description": "Whether we should return the public deploy key - (for the `deploy_key` strategy)\n",
                    "deprecationMessage": "This field is deprecated and will be removed in a future version of the provider, please remove it from your configuration. The key is always fetched when the clone strategy is `deploy_key`"
                },
                "gitCloneStrategy": {
                    "type": "string",
                    "description": "Git clone strategy for the repository. Can be `deploy_key` (default) for cloning via SSH Deploy Key, `github_app` for GitHub native integration, `deploy_token` for the GitLab native integration and `azure_active_directory_app` for ADO native integration\n",
                    "willReplaceOnChanges": true
                },
                "githubInstallationId": {
                    "type": "integer",
                    "description": "Identifier for the GitHub App - (for GitHub native integration only)\n",
                    "willReplaceOnChanges": true
                },
                "gitlabProjectId": {
                    "type": "integer",
                    "description": "Identifier for the Gitlab project -  (for GitLab native integration only)\n",
                    "willReplaceOnChanges": true
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the repository is active\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the repository in\n",
                    "willReplaceOnChanges": true
                },
                "remoteUrl": {
                    "type": "string",
                    "description": "Git URL for the repository or \u003cGroup\u003e/\u003cProject\u003e for Gitlab\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "remoteUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Repository resources.\n",
                "properties": {
                    "azureActiveDirectoryProjectId": {
                        "type": "string",
                        "description": "The Azure Dev Ops project ID. It can be retrieved via the Azure API or using the data source `dbtcloud.getAzureDevOpsProject` and the project name - (for ADO native integration only)\n",
                        "willReplaceOnChanges": true
                    },
                    "azureActiveDirectoryRepositoryId": {
                        "type": "string",
                        "description": "The Azure Dev Ops repository ID. It can be retrieved via the Azure API or using the data source `dbtcloud.getAzureDevOpsRepository` along with the ADO Project ID and the repository name - (for ADO native integration only)\n",
                        "willReplaceOnChanges": true
                    },
                    "azureBypassWebhookRegistrationFailure": {
                        "type": "boolean",
                        "description": "If set to False (the default), the connection will fail if the service user doesn't have access to set webhooks (required for auto-triggering CI jobs). If set to True, the connection will be successful but no automated CI job will be triggered - (for ADO native integration only)\n",
                        "willReplaceOnChanges": true
                    },
                    "deployKey": {
                        "type": "string",
                        "description": "Public key generated by dbt when using `deploy_key` clone strategy\n"
                    },
                    "fetchDeployKey": {
                        "type": "boolean",
                        "description": "Whether we should return the public deploy key - (for the `deploy_key` strategy)\n",
                        "deprecationMessage": "This field is deprecated and will be removed in a future version of the provider, please remove it from your configuration. The key is always fetched when the clone strategy is `deploy_key`"
                    },
                    "gitCloneStrategy": {
                        "type": "string",
                        "description": "Git clone strategy for the repository. Can be `deploy_key` (default) for cloning via SSH Deploy Key, `github_app` for GitHub native integration, `deploy_token` for the GitLab native integration and `azure_active_directory_app` for ADO native integration\n",
                        "willReplaceOnChanges": true
                    },
                    "githubInstallationId": {
                        "type": "integer",
                        "description": "Identifier for the GitHub App - (for GitHub native integration only)\n",
                        "willReplaceOnChanges": true
                    },
                    "gitlabProjectId": {
                        "type": "integer",
                        "description": "Identifier for the Gitlab project -  (for GitLab native integration only)\n",
                        "willReplaceOnChanges": true
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Whether the repository is active\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the repository in\n",
                        "willReplaceOnChanges": true
                    },
                    "remoteUrl": {
                        "type": "string",
                        "description": "Git URL for the repository or \u003cGroup\u003e/\u003cProject\u003e for Gitlab\n",
                        "willReplaceOnChanges": true
                    },
                    "repositoryCredentialsId": {
                        "type": "integer",
                        "description": "Credentials ID for the repository (From the repository side not the dbt Cloud ID)\n"
                    },
                    "repositoryId": {
                        "type": "integer",
                        "description": "Repository Identifier\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/serviceToken:ServiceToken": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst testServiceToken = new dbtcloud.ServiceToken(\"test_service_token\", {\n    name: \"Test Service Token\",\n    serviceTokenPermissions: [\n        {\n            permissionSet: \"git_admin\",\n            allProjects: true,\n        },\n        {\n            permissionSet: \"job_admin\",\n            allProjects: false,\n            projectId: dbtProject.id,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ntest_service_token = dbtcloud.ServiceToken(\"test_service_token\",\n    name=\"Test Service Token\",\n    service_token_permissions=[\n        dbtcloud.ServiceTokenServiceTokenPermissionArgs(\n            permission_set=\"git_admin\",\n            all_projects=True,\n        ),\n        dbtcloud.ServiceTokenServiceTokenPermissionArgs(\n            permission_set=\"job_admin\",\n            all_projects=False,\n            project_id=dbt_project[\"id\"],\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServiceToken = new DbtCloud.ServiceToken(\"test_service_token\", new()\n    {\n        Name = \"Test Service Token\",\n        ServiceTokenPermissions = new[]\n        {\n            new DbtCloud.Inputs.ServiceTokenServiceTokenPermissionArgs\n            {\n                PermissionSet = \"git_admin\",\n                AllProjects = true,\n            },\n            new DbtCloud.Inputs.ServiceTokenServiceTokenPermissionArgs\n            {\n                PermissionSet = \"job_admin\",\n                AllProjects = false,\n                ProjectId = dbtProject.Id,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewServiceToken(ctx, \"test_service_token\", \u0026dbtcloud.ServiceTokenArgs{\n\t\t\tName: pulumi.String(\"Test Service Token\"),\n\t\t\tServiceTokenPermissions: dbtcloud.ServiceTokenServiceTokenPermissionArray{\n\t\t\t\t\u0026dbtcloud.ServiceTokenServiceTokenPermissionArgs{\n\t\t\t\t\tPermissionSet: pulumi.String(\"git_admin\"),\n\t\t\t\t\tAllProjects:   pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026dbtcloud.ServiceTokenServiceTokenPermissionArgs{\n\t\t\t\t\tPermissionSet: pulumi.String(\"job_admin\"),\n\t\t\t\t\tAllProjects:   pulumi.Bool(false),\n\t\t\t\t\tProjectId:     pulumi.Any(dbtProject.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.ServiceToken;\nimport com.pulumi.dbtcloud.ServiceTokenArgs;\nimport com.pulumi.dbtcloud.inputs.ServiceTokenServiceTokenPermissionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServiceToken = new ServiceToken(\"testServiceToken\", ServiceTokenArgs.builder()\n            .name(\"Test Service Token\")\n            .serviceTokenPermissions(            \n                ServiceTokenServiceTokenPermissionArgs.builder()\n                    .permissionSet(\"git_admin\")\n                    .allProjects(true)\n                    .build(),\n                ServiceTokenServiceTokenPermissionArgs.builder()\n                    .permissionSet(\"job_admin\")\n                    .allProjects(false)\n                    .projectId(dbtProject.id())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testServiceToken:\n    type: dbtcloud:ServiceToken\n    name: test_service_token\n    properties:\n      name: Test Service Token\n      serviceTokenPermissions:\n        - permissionSet: git_admin\n          allProjects: true\n        - permissionSet: job_admin\n          allProjects: false\n          projectId: ${dbtProject.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_group.my_service_token\n\n  id = \"service_token_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_group.my_service_token\n\n  id = \"12345\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/serviceToken:ServiceToken my_service_token \"service_token_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/serviceToken:ServiceToken my_service_token 12345\n```\n\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Service token name\n"
                },
                "serviceTokenPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/dbtcloud:index/ServiceTokenServiceTokenPermission:ServiceTokenServiceTokenPermission"
                    },
                    "description": "Permissions set for the service token\n"
                },
                "state": {
                    "type": "integer",
                    "description": "Service token state (1 is active, 2 is inactive)\n"
                },
                "tokenString": {
                    "type": "string",
                    "description": "Service token secret value (only accessible on creation))\n",
                    "secret": true
                },
                "uid": {
                    "type": "string",
                    "description": "Service token UID (part of the token)\n"
                }
            },
            "required": [
                "name",
                "tokenString",
                "uid"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Service token name\n",
                    "willReplaceOnChanges": true
                },
                "serviceTokenPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/dbtcloud:index/ServiceTokenServiceTokenPermission:ServiceTokenServiceTokenPermission"
                    },
                    "description": "Permissions set for the service token\n"
                },
                "state": {
                    "type": "integer",
                    "description": "Service token state (1 is active, 2 is inactive)\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceToken resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Service token name\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceTokenPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/ServiceTokenServiceTokenPermission:ServiceTokenServiceTokenPermission"
                        },
                        "description": "Permissions set for the service token\n"
                    },
                    "state": {
                        "type": "integer",
                        "description": "Service token state (1 is active, 2 is inactive)\n"
                    },
                    "tokenString": {
                        "type": "string",
                        "description": "Service token secret value (only accessible on creation))\n",
                        "secret": true
                    },
                    "uid": {
                        "type": "string",
                        "description": "Service token UID (part of the token)\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/snowflakeCredential:SnowflakeCredential": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst prodCredential = new dbtcloud.SnowflakeCredential(\"prod_credential\", {\n    projectId: dbtProject.id,\n    authType: \"password\",\n    numThreads: 16,\n    schema: \"SCHEMA\",\n    user: \"user\",\n    password: \"password\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nprod_credential = dbtcloud.SnowflakeCredential(\"prod_credential\",\n    project_id=dbt_project[\"id\"],\n    auth_type=\"password\",\n    num_threads=16,\n    schema=\"SCHEMA\",\n    user=\"user\",\n    password=\"password\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodCredential = new DbtCloud.SnowflakeCredential(\"prod_credential\", new()\n    {\n        ProjectId = dbtProject.Id,\n        AuthType = \"password\",\n        NumThreads = 16,\n        Schema = \"SCHEMA\",\n        User = \"user\",\n        Password = \"password\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewSnowflakeCredential(ctx, \"prod_credential\", \u0026dbtcloud.SnowflakeCredentialArgs{\n\t\t\tProjectId:  pulumi.Any(dbtProject.Id),\n\t\t\tAuthType:   pulumi.String(\"password\"),\n\t\t\tNumThreads: pulumi.Int(16),\n\t\t\tSchema:     pulumi.String(\"SCHEMA\"),\n\t\t\tUser:       pulumi.String(\"user\"),\n\t\t\tPassword:   pulumi.String(\"password\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.SnowflakeCredential;\nimport com.pulumi.dbtcloud.SnowflakeCredentialArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodCredential = new SnowflakeCredential(\"prodCredential\", SnowflakeCredentialArgs.builder()\n            .projectId(dbtProject.id())\n            .authType(\"password\")\n            .numThreads(16)\n            .schema(\"SCHEMA\")\n            .user(\"user\")\n            .password(\"password\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodCredential:\n    type: dbtcloud:SnowflakeCredential\n    name: prod_credential\n    properties:\n      projectId: ${dbtProject.id}\n      authType: password\n      numThreads: 16\n      schema: SCHEMA\n      user: user\n      password: password\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_snowflake_credential.prod_snowflake_credential\n\n  id = \"project_id:credential_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_snowflake_credential.prod_snowflake_credential\n\n  id = \"12345:6789\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/snowflakeCredential:SnowflakeCredential prod_snowflake_credential \"project_id:credential_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/snowflakeCredential:SnowflakeCredential prod_snowflake_credential 12345:6789\n```\n\n",
            "properties": {
                "authType": {
                    "type": "string",
                    "description": "The type of Snowflake credential ('password' or 'keypair')\n"
                },
                "credentialId": {
                    "type": "integer",
                    "description": "The system Snowflake credential ID\n"
                },
                "database": {
                    "type": "string",
                    "description": "Database to connect to\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the Snowflake credential is active\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for Snowflake\n",
                    "secret": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private key for Snowflake\n",
                    "secret": true
                },
                "privateKeyPassphrase": {
                    "type": "string",
                    "description": "Private key passphrase for Snowflake\n",
                    "secret": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Snowflake credential in\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role to assume\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Default schema name\n"
                },
                "user": {
                    "type": "string",
                    "description": "Username for Snowflake\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "Warehouse to use\n"
                }
            },
            "required": [
                "authType",
                "credentialId",
                "numThreads",
                "projectId",
                "schema",
                "user"
            ],
            "inputProperties": {
                "authType": {
                    "type": "string",
                    "description": "The type of Snowflake credential ('password' or 'keypair')\n"
                },
                "database": {
                    "type": "string",
                    "description": "Database to connect to\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether the Snowflake credential is active\n"
                },
                "numThreads": {
                    "type": "integer",
                    "description": "Number of threads to use\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for Snowflake\n",
                    "secret": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private key for Snowflake\n",
                    "secret": true
                },
                "privateKeyPassphrase": {
                    "type": "string",
                    "description": "Private key passphrase for Snowflake\n",
                    "secret": true
                },
                "projectId": {
                    "type": "integer",
                    "description": "Project ID to create the Snowflake credential in\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "Role to assume\n"
                },
                "schema": {
                    "type": "string",
                    "description": "Default schema name\n"
                },
                "user": {
                    "type": "string",
                    "description": "Username for Snowflake\n"
                },
                "warehouse": {
                    "type": "string",
                    "description": "Warehouse to use\n"
                }
            },
            "requiredInputs": [
                "authType",
                "numThreads",
                "projectId",
                "schema",
                "user"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SnowflakeCredential resources.\n",
                "properties": {
                    "authType": {
                        "type": "string",
                        "description": "The type of Snowflake credential ('password' or 'keypair')\n"
                    },
                    "credentialId": {
                        "type": "integer",
                        "description": "The system Snowflake credential ID\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Database to connect to\n"
                    },
                    "isActive": {
                        "type": "boolean",
                        "description": "Whether the Snowflake credential is active\n"
                    },
                    "numThreads": {
                        "type": "integer",
                        "description": "Number of threads to use\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password for Snowflake\n",
                        "secret": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Private key for Snowflake\n",
                        "secret": true
                    },
                    "privateKeyPassphrase": {
                        "type": "string",
                        "description": "Private key passphrase for Snowflake\n",
                        "secret": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the Snowflake credential in\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "Role to assume\n"
                    },
                    "schema": {
                        "type": "string",
                        "description": "Default schema name\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "Username for Snowflake\n"
                    },
                    "warehouse": {
                        "type": "string",
                        "description": "Warehouse to use\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/userGroups:UserGroups": {
            "description": "Assigns a set of dbt Cloud groups to a given User ID. \n\n\u003e If additional groups were assigned manually in dbt Cloud, they will be removed. The full list of groups need to be provided as config.\n\t\t\n\u003e This resource does not currently support deletion (e.g. a deleted resource will stay as-is in dbt Cloud).\nThis is intentional in order to prevent accidental deletion of all users groups assigned to a user.\nIf you would like a different behavior, please open an issue on GitHub. To remove all groups for a user, set \"group_ids\" to the empty set \"[]\".\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// we can assign groups to users\nconst myUserGroups = new dbtcloud.UserGroups(\"my_user_groups\", {\n    userId: myUser.id,\n    groupIds: [\n        1234,\n        myGroup.id,\n        myGroupId,\n    ],\n});\n// as Delete is not handled currently, by design, removing all groups from a user can be done with\nconst myOtherUserGroups = new dbtcloud.UserGroups(\"my_other_user_groups\", {\n    userId: 123456,\n    groupIds: [],\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# we can assign groups to users\nmy_user_groups = dbtcloud.UserGroups(\"my_user_groups\",\n    user_id=my_user[\"id\"],\n    group_ids=[\n        1234,\n        my_group[\"id\"],\n        my_group_id,\n    ])\n# as Delete is not handled currently, by design, removing all groups from a user can be done with\nmy_other_user_groups = dbtcloud.UserGroups(\"my_other_user_groups\",\n    user_id=123456,\n    group_ids=[])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // we can assign groups to users\n    var myUserGroups = new DbtCloud.UserGroups(\"my_user_groups\", new()\n    {\n        UserId = myUser.Id,\n        GroupIds = new[]\n        {\n            1234,\n            myGroup.Id,\n            myGroupId,\n        },\n    });\n\n    // as Delete is not handled currently, by design, removing all groups from a user can be done with\n    var myOtherUserGroups = new DbtCloud.UserGroups(\"my_other_user_groups\", new()\n    {\n        UserId = 123456,\n        GroupIds = new[] {},\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// we can assign groups to users\n\t\t_, err := dbtcloud.NewUserGroups(ctx, \"my_user_groups\", \u0026dbtcloud.UserGroupsArgs{\n\t\t\tUserId: pulumi.Any(myUser.Id),\n\t\t\tGroupIds: pulumi.IntArray{\n\t\t\t\tpulumi.Int(1234),\n\t\t\t\tmyGroup.Id,\n\t\t\t\tmyGroupId,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// as Delete is not handled currently, by design, removing all groups from a user can be done with\n\t\t_, err = dbtcloud.NewUserGroups(ctx, \"my_other_user_groups\", \u0026dbtcloud.UserGroupsArgs{\n\t\t\tUserId:   pulumi.Int(123456),\n\t\t\tGroupIds: pulumi.IntArray{},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.UserGroups;\nimport com.pulumi.dbtcloud.UserGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // we can assign groups to users\n        var myUserGroups = new UserGroups(\"myUserGroups\", UserGroupsArgs.builder()\n            .userId(myUser.id())\n            .groupIds(            \n                1234,\n                myGroup.id(),\n                myGroupId)\n            .build());\n\n        // as Delete is not handled currently, by design, removing all groups from a user can be done with\n        var myOtherUserGroups = new UserGroups(\"myOtherUserGroups\", UserGroupsArgs.builder()\n            .userId(123456)\n            .groupIds()\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # we can assign groups to users\n  myUserGroups:\n    type: dbtcloud:UserGroups\n    name: my_user_groups\n    properties:\n      userId: ${myUser.id}\n      groupIds:\n        - 1234\n        - ${myGroup.id}\n        - ${myGroupId}\n  # as Delete is not handled currently, by design, removing all groups from a user can be done with\n  myOtherUserGroups:\n    type: dbtcloud:UserGroups\n    name: my_other_user_groups\n    properties:\n      userId: 123456\n      groupIds: []\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nImport using the User ID\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_user_groups.my_user_groups\n\n  id = \"user_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_user_groups.my_user_groups\n\n  id = \"123456\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/userGroups:UserGroups my_user_groups \"user_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/userGroups:UserGroups my_user_groups 123456\n```\n\n",
            "properties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "IDs of the groups to assign to the user. If additional groups were assigned manually in dbt Cloud, they will be removed.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The internal ID of a dbt Cloud user\n"
                }
            },
            "required": [
                "groupIds",
                "userId"
            ],
            "inputProperties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "IDs of the groups to assign to the user. If additional groups were assigned manually in dbt Cloud, they will be removed.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The internal ID of a dbt Cloud user\n"
                }
            },
            "requiredInputs": [
                "groupIds",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserGroups resources.\n",
                "properties": {
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "IDs of the groups to assign to the user. If additional groups were assigned manually in dbt Cloud, they will be removed.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The internal ID of a dbt Cloud user\n"
                    }
                },
                "type": "object"
            }
        },
        "dbtcloud:index/webhook:Webhook": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst testWebhook = new dbtcloud.Webhook(\"test_webhook\", {\n    name: \"test-webhook\",\n    description: \"Test webhook\",\n    clientUrl: \"http://localhost/nothing\",\n    eventTypes: [\n        \"job.run.started\",\n        \"job.run.completed\",\n    ],\n    jobIds: [\n        1234,\n        5678,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ntest_webhook = dbtcloud.Webhook(\"test_webhook\",\n    name=\"test-webhook\",\n    description=\"Test webhook\",\n    client_url=\"http://localhost/nothing\",\n    event_types=[\n        \"job.run.started\",\n        \"job.run.completed\",\n    ],\n    job_ids=[\n        1234,\n        5678,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testWebhook = new DbtCloud.Webhook(\"test_webhook\", new()\n    {\n        Name = \"test-webhook\",\n        Description = \"Test webhook\",\n        ClientUrl = \"http://localhost/nothing\",\n        EventTypes = new[]\n        {\n            \"job.run.started\",\n            \"job.run.completed\",\n        },\n        JobIds = new[]\n        {\n            1234,\n            5678,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.NewWebhook(ctx, \"test_webhook\", \u0026dbtcloud.WebhookArgs{\n\t\t\tName:        pulumi.String(\"test-webhook\"),\n\t\t\tDescription: pulumi.String(\"Test webhook\"),\n\t\t\tClientUrl:   pulumi.String(\"http://localhost/nothing\"),\n\t\t\tEventTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"job.run.started\"),\n\t\t\t\tpulumi.String(\"job.run.completed\"),\n\t\t\t},\n\t\t\tJobIds: pulumi.IntArray{\n\t\t\t\tpulumi.Int(1234),\n\t\t\t\tpulumi.Int(5678),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.Webhook;\nimport com.pulumi.dbtcloud.WebhookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testWebhook = new Webhook(\"testWebhook\", WebhookArgs.builder()\n            .name(\"test-webhook\")\n            .description(\"Test webhook\")\n            .clientUrl(\"http://localhost/nothing\")\n            .eventTypes(            \n                \"job.run.started\",\n                \"job.run.completed\")\n            .jobIds(            \n                1234,\n                5678)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testWebhook:\n    type: dbtcloud:Webhook\n    name: test_webhook\n    properties:\n      name: test-webhook\n      description: Test webhook\n      clientUrl: http://localhost/nothing\n      eventTypes:\n        - job.run.started\n        - job.run.completed\n      jobIds:\n        - 1234\n        - 5678\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nusing  import blocks (requires Terraform \u003e= 1.5)\n\nimport {\n\n  to = dbtcloud_webhook.my_webhook\n\n  id = \"webhook_id\"\n\n}\n\nimport {\n\n  to = dbtcloud_webhook.my_webhook\n\n  id = \"wsu_abcdefg\"\n\n}\n\nusing the older import command\n\n```sh\n$ pulumi import dbtcloud:index/webhook:Webhook my_webhook \"webhook_id\"\n```\n\n```sh\n$ pulumi import dbtcloud:index/webhook:Webhook my_webhook wsu_abcdefg\n```\n\n",
            "properties": {
                "accountIdentifier": {
                    "type": "string",
                    "description": "Webhooks Account Identifier\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "Webhooks active flag\n"
                },
                "clientUrl": {
                    "type": "string",
                    "description": "Webhooks Client URL\n"
                },
                "description": {
                    "type": "string",
                    "description": "Webhooks Description\n"
                },
                "eventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Webhooks Event Types\n"
                },
                "hmacSecret": {
                    "type": "string",
                    "description": "Secret key for the webhook. Can be used to validate the authenticity of the webhook.\n",
                    "secret": true
                },
                "httpStatusCode": {
                    "type": "string",
                    "description": "Latest HTTP status of the webhook\n"
                },
                "jobIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook, An empty list will trigger on all jobs\n"
                },
                "name": {
                    "type": "string",
                    "description": "Webhooks Name\n"
                },
                "webhookId": {
                    "type": "string",
                    "description": "Webhooks ID\n"
                }
            },
            "required": [
                "accountIdentifier",
                "clientUrl",
                "eventTypes",
                "hmacSecret",
                "httpStatusCode",
                "name",
                "webhookId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "Webhooks active flag\n"
                },
                "clientUrl": {
                    "type": "string",
                    "description": "Webhooks Client URL\n"
                },
                "description": {
                    "type": "string",
                    "description": "Webhooks Description\n"
                },
                "eventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Webhooks Event Types\n"
                },
                "jobIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of job IDs to trigger the webhook, An empty list will trigger on all jobs\n"
                },
                "name": {
                    "type": "string",
                    "description": "Webhooks Name\n"
                }
            },
            "requiredInputs": [
                "clientUrl",
                "eventTypes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Webhook resources.\n",
                "properties": {
                    "accountIdentifier": {
                        "type": "string",
                        "description": "Webhooks Account Identifier\n"
                    },
                    "active": {
                        "type": "boolean",
                        "description": "Webhooks active flag\n"
                    },
                    "clientUrl": {
                        "type": "string",
                        "description": "Webhooks Client URL\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Webhooks Description\n"
                    },
                    "eventTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Webhooks Event Types\n"
                    },
                    "hmacSecret": {
                        "type": "string",
                        "description": "Secret key for the webhook. Can be used to validate the authenticity of the webhook.\n",
                        "secret": true
                    },
                    "httpStatusCode": {
                        "type": "string",
                        "description": "Latest HTTP status of the webhook\n"
                    },
                    "jobIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of job IDs to trigger the webhook, An empty list will trigger on all jobs\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Webhooks Name\n"
                    },
                    "webhookId": {
                        "type": "string",
                        "description": "Webhooks ID\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "dbtcloud:index/getAzureDevOpsProject:getAzureDevOpsProject": {
            "description": "Use this data source to retrieve the ID of an Azure Dev Ops project \nbased on its name.\n\t\t\nThis data source requires connecting with a user token and doesn't work with a service token.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myAdoProject = dbtcloud.getAzureDevOpsProject({\n    name: \"my-project-name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_ado_project = dbtcloud.get_azure_dev_ops_project(name=\"my-project-name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myAdoProject = DbtCloud.GetAzureDevOpsProject.Invoke(new()\n    {\n        Name = \"my-project-name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.GetAzureDevOpsProject(ctx, \u0026dbtcloud.GetAzureDevOpsProjectArgs{\n\t\t\tName: \"my-project-name\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetAzureDevOpsProjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myAdoProject = DbtcloudFunctions.getAzureDevOpsProject(GetAzureDevOpsProjectArgs.builder()\n            .name(\"my-project-name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myAdoProject:\n    fn::invoke:\n      Function: dbtcloud:getAzureDevOpsProject\n      Arguments:\n        name: my-project-name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAzureDevOpsProject.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the ADO project\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAzureDevOpsProject.\n",
                "properties": {
                    "id": {
                        "description": "The internal Azure Dev Ops ID of the ADO Project\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the ADO project\n",
                        "type": "string"
                    },
                    "url": {
                        "description": "The URL of the ADO project\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id",
                    "name",
                    "url"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getAzureDevOpsRepository:getAzureDevOpsRepository": {
            "description": "Use this data source to retrieve the ID and details of an Azure Dev Ops repository \nbased on its name and the ID of the Azure Dev Ops project it belongs to.\n\t\t\nThis data source requires connecting with a user token and doesn't work with a service token.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myAdoRepository = dbtcloud.getAzureDevOpsRepository({\n    name: \"my-repo-name\",\n    azureDevOpsProjectId: myAdoProject.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_ado_repository = dbtcloud.get_azure_dev_ops_repository(name=\"my-repo-name\",\n    azure_dev_ops_project_id=my_ado_project[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myAdoRepository = DbtCloud.GetAzureDevOpsRepository.Invoke(new()\n    {\n        Name = \"my-repo-name\",\n        AzureDevOpsProjectId = myAdoProject.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.GetAzureDevOpsRepository(ctx, \u0026dbtcloud.GetAzureDevOpsRepositoryArgs{\n\t\t\tName:                 \"my-repo-name\",\n\t\t\tAzureDevOpsProjectId: myAdoProject.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetAzureDevOpsRepositoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myAdoRepository = DbtcloudFunctions.getAzureDevOpsRepository(GetAzureDevOpsRepositoryArgs.builder()\n            .name(\"my-repo-name\")\n            .azureDevOpsProjectId(myAdoProject.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myAdoRepository:\n    fn::invoke:\n      Function: dbtcloud:getAzureDevOpsRepository\n      Arguments:\n        name: my-repo-name\n        azureDevOpsProjectId: ${myAdoProject.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAzureDevOpsRepository.\n",
                "properties": {
                    "azureDevOpsProjectId": {
                        "type": "string",
                        "description": "The internal Azure Dev Ops ID of the ADO Project. Can be retrieved using the data source dbtcloud*azure*dev*ops*project and the project name\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ADO repository\n"
                    }
                },
                "type": "object",
                "required": [
                    "azureDevOpsProjectId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAzureDevOpsRepository.\n",
                "properties": {
                    "azureDevOpsProjectId": {
                        "description": "The internal Azure Dev Ops ID of the ADO Project. Can be retrieved using the data source dbtcloud*azure*dev*ops*project and the project name\n",
                        "type": "string"
                    },
                    "defaultBranch": {
                        "description": "The default branch of the ADO repository\n",
                        "type": "string"
                    },
                    "detailsUrl": {
                        "description": "The URL of the ADO repository showing details about the repository and its attributes\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The internal Azure Dev Ops ID of the ADO Repository\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the ADO repository\n",
                        "type": "string"
                    },
                    "remoteUrl": {
                        "description": "The HTTP URL of the ADO repository used to connect to dbt Cloud\n",
                        "type": "string"
                    },
                    "webUrl": {
                        "description": "The URL of the ADO repository accessible in the browser\n",
                        "type": "string"
                    }
                },
                "required": [
                    "azureDevOpsProjectId",
                    "defaultBranch",
                    "detailsUrl",
                    "id",
                    "name",
                    "remoteUrl",
                    "webUrl"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getBigQueryConnection:getBigQueryConnection": {
            "inputs": {
                "description": "A collection of arguments for invoking getBigQueryConnection.\n",
                "properties": {
                    "connectionId": {
                        "type": "integer",
                        "description": "Connection Identifier\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the connection in\n"
                    }
                },
                "type": "object",
                "required": [
                    "connectionId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getBigQueryConnection.\n",
                "properties": {
                    "authProviderX509CertUrl": {
                        "description": "Auth Provider X509 Cert URL for the Service Account\n",
                        "type": "string"
                    },
                    "authUri": {
                        "description": "Auth URI for the Service Account\n",
                        "type": "string"
                    },
                    "clientEmail": {
                        "description": "Service Account email\n",
                        "type": "string"
                    },
                    "clientId": {
                        "description": "Client ID of the Service Account\n",
                        "type": "string"
                    },
                    "clientX509CertUrl": {
                        "description": "Client X509 Cert URL for the Service Account\n",
                        "type": "string"
                    },
                    "connectionId": {
                        "description": "Connection Identifier\n",
                        "type": "integer"
                    },
                    "dataprocClusterName": {
                        "description": "Dataproc cluster name for PySpark workloads\n",
                        "type": "string"
                    },
                    "dataprocRegion": {
                        "description": "Google Cloud region for PySpark workloads on Dataproc\n",
                        "type": "string"
                    },
                    "executionProject": {
                        "description": "Project to bill for query execution\n",
                        "type": "string"
                    },
                    "gcpProjectId": {
                        "description": "GCP project ID\n",
                        "type": "string"
                    },
                    "gcsBucket": {
                        "description": "URI for a Google Cloud Storage bucket to host Python code executed via Datapro\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isActive": {
                        "description": "Whether the connection is active\n",
                        "type": "boolean"
                    },
                    "isConfiguredForOauth": {
                        "description": "Whether the connection is configured for OAuth or not\n",
                        "type": "boolean"
                    },
                    "location": {
                        "description": "Location to create new Datasets in\n",
                        "type": "string"
                    },
                    "maximumBytesBilled": {
                        "description": "Max number of bytes that can be billed for a given BigQuery query\n",
                        "type": "integer"
                    },
                    "name": {
                        "description": "Connection name\n",
                        "type": "string"
                    },
                    "priority": {
                        "description": "The priority with which to execute BigQuery queries\n",
                        "type": "string"
                    },
                    "privateKey": {
                        "description": "Private key of the Service Account\n",
                        "type": "string"
                    },
                    "privateKeyId": {
                        "description": "Private key ID of the Service Account\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Project ID to create the connection in\n",
                        "type": "integer"
                    },
                    "retries": {
                        "description": "Number of retries for queries\n",
                        "type": "integer"
                    },
                    "timeoutSeconds": {
                        "description": "Timeout in seconds for queries\n",
                        "type": "integer"
                    },
                    "tokenUri": {
                        "description": "Token URI for the Service Account\n",
                        "type": "string"
                    },
                    "type": {
                        "description": "The type of connection\n",
                        "type": "string"
                    }
                },
                "required": [
                    "authProviderX509CertUrl",
                    "authUri",
                    "clientEmail",
                    "clientId",
                    "clientX509CertUrl",
                    "connectionId",
                    "dataprocClusterName",
                    "dataprocRegion",
                    "executionProject",
                    "gcpProjectId",
                    "gcsBucket",
                    "isActive",
                    "isConfiguredForOauth",
                    "location",
                    "maximumBytesBilled",
                    "name",
                    "priority",
                    "privateKey",
                    "privateKeyId",
                    "projectId",
                    "retries",
                    "timeoutSeconds",
                    "tokenUri",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getBigQueryCredential:getBigQueryCredential": {
            "inputs": {
                "description": "A collection of arguments for invoking getBigQueryCredential.\n",
                "properties": {
                    "credentialId": {
                        "type": "integer",
                        "description": "Credential ID\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID\n"
                    }
                },
                "type": "object",
                "required": [
                    "credentialId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getBigQueryCredential.\n",
                "properties": {
                    "credentialId": {
                        "description": "Credential ID\n",
                        "type": "integer"
                    },
                    "dataset": {
                        "description": "Default dataset name\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isActive": {
                        "description": "Whether the BigQuery credential is active\n",
                        "type": "boolean"
                    },
                    "numThreads": {
                        "description": "Number of threads to use\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "Project ID\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "credentialId",
                    "dataset",
                    "isActive",
                    "numThreads",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getConnection:getConnection": {
            "inputs": {
                "description": "A collection of arguments for invoking getConnection.\n",
                "properties": {
                    "connectionId": {
                        "type": "integer",
                        "description": "ID for the connection\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the connection in\n"
                    }
                },
                "type": "object",
                "required": [
                    "connectionId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getConnection.\n",
                "properties": {
                    "account": {
                        "description": "Account for the connection\n",
                        "type": "string"
                    },
                    "allowKeepAlive": {
                        "description": "Flag for whether or not to use the keep session alive parameter in the connection\n",
                        "type": "boolean"
                    },
                    "allowSso": {
                        "description": "Flag for whether or not to use SSO for the connection\n",
                        "type": "boolean"
                    },
                    "connectionId": {
                        "description": "ID for the connection\n",
                        "type": "integer"
                    },
                    "database": {
                        "description": "Database name for the connection\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isActive": {
                        "description": "Whether the connection is active\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "Connection name\n",
                        "type": "string"
                    },
                    "privateLinkEndpointId": {
                        "description": "The ID of the PrivateLink connection\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Project ID to create the connection in\n",
                        "type": "integer"
                    },
                    "role": {
                        "description": "Role name for the connection\n",
                        "type": "string"
                    },
                    "type": {
                        "description": "Connection type\n",
                        "type": "string"
                    },
                    "warehouse": {
                        "description": "Warehouse name for the connection\n",
                        "type": "string"
                    }
                },
                "required": [
                    "account",
                    "allowKeepAlive",
                    "allowSso",
                    "connectionId",
                    "database",
                    "isActive",
                    "name",
                    "privateLinkEndpointId",
                    "projectId",
                    "role",
                    "type",
                    "warehouse",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getDatabricksCredential:getDatabricksCredential": {
            "inputs": {
                "description": "A collection of arguments for invoking getDatabricksCredential.\n",
                "properties": {
                    "credentialId": {
                        "type": "integer",
                        "description": "Credential ID\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID\n"
                    }
                },
                "type": "object",
                "required": [
                    "credentialId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabricksCredential.\n",
                "properties": {
                    "adapterId": {
                        "description": "Databricks adapter ID for the credential\n",
                        "type": "integer"
                    },
                    "catalog": {
                        "description": "The catalog where to create models\n",
                        "type": "string"
                    },
                    "credentialId": {
                        "description": "Credential ID\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "numThreads": {
                        "description": "Number of threads to use\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "Project ID\n",
                        "type": "integer"
                    },
                    "schema": {
                        "description": "The schema where to create models\n",
                        "type": "string"
                    },
                    "targetName": {
                        "description": "Target name\n",
                        "type": "string"
                    }
                },
                "required": [
                    "adapterId",
                    "catalog",
                    "credentialId",
                    "numThreads",
                    "projectId",
                    "schema",
                    "targetName",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getEnvironment:getEnvironment": {
            "description": "Retrieve data for a single environment\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEnvironment.\n",
                "properties": {
                    "environmentId": {
                        "type": "integer",
                        "description": "The ID of the environment\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The project ID to which the environment belong\n"
                    }
                },
                "type": "object",
                "required": [
                    "environmentId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEnvironment.\n",
                "properties": {
                    "credentialsId": {
                        "description": "The project ID to which the environment belong\n",
                        "type": "integer"
                    },
                    "customBranch": {
                        "description": "The custom branch name to use\n",
                        "type": "string"
                    },
                    "dbtVersion": {
                        "description": "Version number of dbt to use in this environment.\n",
                        "type": "string"
                    },
                    "deploymentType": {
                        "description": "The type of deployment environment (currently 'production', 'staging' or empty)\n",
                        "type": "string"
                    },
                    "environmentId": {
                        "description": "The ID of the environment\n",
                        "type": "integer"
                    },
                    "extendedAttributesId": {
                        "description": "The ID of the extended attributes applied\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the environment\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "The project ID to which the environment belong\n",
                        "type": "integer"
                    },
                    "type": {
                        "description": "The type of environment (must be either development or deployment)\n",
                        "type": "string"
                    },
                    "useCustomBranch": {
                        "description": "Whether to use a custom git branch in this environment\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "credentialsId",
                    "customBranch",
                    "dbtVersion",
                    "deploymentType",
                    "environmentId",
                    "extendedAttributesId",
                    "name",
                    "projectId",
                    "type",
                    "useCustomBranch",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getEnvironmentVariable:getEnvironmentVariable": {
            "inputs": {
                "description": "A collection of arguments for invoking getEnvironmentVariable.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name for the variable\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID the variable exists in\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEnvironmentVariable.\n",
                "properties": {
                    "environmentValues": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Map containing the environment variables\n",
                        "type": "object"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Name for the variable\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Project ID the variable exists in\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "environmentValues",
                    "name",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getEnvironments:getEnvironments": {
            "description": "Retrieve data for multiple environments\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEnvironments.\n",
                "properties": {
                    "projectId": {
                        "type": "integer",
                        "description": "The project ID to filter the environments for [Optional]\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getEnvironments.\n",
                "properties": {
                    "environments": {
                        "description": "The list of environments\n",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/getEnvironmentsEnvironment:getEnvironmentsEnvironment"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "The project ID to filter the environments for [Optional]\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "environments",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getExtendedAttributes:getExtendedAttributes": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myExtendedAttributes = dbtcloud.getExtendedAttributes({\n    extendedAttributesId: 12345,\n    projectId: 6789,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_extended_attributes = dbtcloud.get_extended_attributes(extended_attributes_id=12345,\n    project_id=6789)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExtendedAttributes = DbtCloud.GetExtendedAttributes.Invoke(new()\n    {\n        ExtendedAttributesId = 12345,\n        ProjectId = 6789,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.LookupExtendedAttributes(ctx, \u0026dbtcloud.LookupExtendedAttributesArgs{\n\t\t\tExtendedAttributesId: 12345,\n\t\t\tProjectId:            6789,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetExtendedAttributesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myExtendedAttributes = DbtcloudFunctions.getExtendedAttributes(GetExtendedAttributesArgs.builder()\n            .extendedAttributesId(12345)\n            .projectId(6789)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myExtendedAttributes:\n    fn::invoke:\n      Function: dbtcloud:getExtendedAttributes\n      Arguments:\n        extendedAttributesId: 12345\n        projectId: 6789\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getExtendedAttributes.\n",
                "properties": {
                    "extendedAttributesId": {
                        "type": "integer",
                        "description": "ID of the extended attributes\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID the extended attributes refers to\n"
                    }
                },
                "type": "object",
                "required": [
                    "extendedAttributesId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getExtendedAttributes.\n",
                "properties": {
                    "extendedAttributes": {
                        "description": "A JSON string listing the extended attributes mapping\n",
                        "type": "string"
                    },
                    "extendedAttributesId": {
                        "description": "ID of the extended attributes\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Project ID the extended attributes refers to\n",
                        "type": "integer"
                    },
                    "state": {
                        "description": "The state of the extended attributes (1 = active, 2 = inactive)\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "extendedAttributes",
                    "extendedAttributesId",
                    "projectId",
                    "state",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getGroup:getGroup": {
            "description": "Retrieve group details\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "assignByDefault": {
                        "description": "Whether the group will be assigned by default to users. The value needs to be the same for all partial permissions for the same group.\n",
                        "type": "boolean"
                    },
                    "groupId": {
                        "description": "The ID of the group\n",
                        "type": "integer"
                    },
                    "groupPermissions": {
                        "description": "Partial permissions for the group. Those permissions will be added/removed when config is added/removed.\n",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/getGroupGroupPermission:getGroupGroupPermission"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The ID of this resource\n",
                        "type": "integer"
                    },
                    "name": {
                        "description": "Group name\n",
                        "type": "string"
                    },
                    "ssoMappingGroups": {
                        "description": "SSO mapping group names for this group\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "assignByDefault",
                    "groupId",
                    "groupPermissions",
                    "id",
                    "name",
                    "ssoMappingGroups"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getGroupUsers:getGroupUsers": {
            "description": "Returns a list of users assigned to a specific dbt Cloud group\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myGroupUsers = dbtcloud.getGroupUsers({\n    groupId: 1234,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_group_users = dbtcloud.get_group_users(group_id=1234)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myGroupUsers = DbtCloud.GetGroupUsers.Invoke(new()\n    {\n        GroupId = 1234,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.GetGroupUsers(ctx, \u0026dbtcloud.GetGroupUsersArgs{\n\t\t\tGroupId: 1234,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetGroupUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myGroupUsers = DbtcloudFunctions.getGroupUsers(GetGroupUsersArgs.builder()\n            .groupId(1234)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myGroupUsers:\n    fn::invoke:\n      Function: dbtcloud:getGroupUsers\n      Arguments:\n        groupId: 1234\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupUsers.\n",
                "properties": {
                    "groupId": {
                        "type": "integer",
                        "description": "ID of the group\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupUsers.\n",
                "properties": {
                    "groupId": {
                        "description": "ID of the group\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "users": {
                        "description": "List of users (map of ID and email) in the group\n",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/getGroupUsersUser:getGroupUsersUser"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "groupId",
                    "users",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getJob:getJob": {
            "inputs": {
                "description": "A collection of arguments for invoking getJob.\n",
                "properties": {
                    "jobId": {
                        "type": "integer",
                        "description": "ID of the job\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "ID of the project the job is in\n"
                    }
                },
                "type": "object",
                "required": [
                    "jobId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getJob.\n",
                "properties": {
                    "deferringEnvironmentId": {
                        "description": "ID of the environment this job defers to\n",
                        "type": "integer"
                    },
                    "deferringJobId": {
                        "description": "ID of the job this job defers to\n",
                        "type": "integer"
                    },
                    "description": {
                        "description": "Long description for the job\n",
                        "type": "string"
                    },
                    "environmentId": {
                        "description": "ID of the environment the job is in\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "jobCompletionTriggerConditions": {
                        "description": "Which other job should trigger this job when it finishes, and on which conditions.\n",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/getJobJobCompletionTriggerCondition:getJobJobCompletionTriggerCondition"
                        },
                        "language": {
                            "csharp": {
                                "name": "CompletionTriggerCondition"
                            }
                        },
                        "type": "array"
                    },
                    "jobId": {
                        "description": "ID of the job\n",
                        "type": "integer"
                    },
                    "name": {
                        "description": "Given name for the job\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "ID of the project the job is in\n",
                        "type": "integer"
                    },
                    "selfDeferring": {
                        "description": "Whether this job defers on a previous run of itself (overrides value in deferring*job*id)\n",
                        "type": "boolean"
                    },
                    "timeoutSeconds": {
                        "description": "Number of seconds before the job times out\n",
                        "type": "integer"
                    },
                    "triggers": {
                        "additionalProperties": {
                            "type": "boolean"
                        },
                        "description": "Flags for which types of triggers to use, keys of github*webhook, git*provider*webhook, schedule, on*merge\n",
                        "type": "object"
                    },
                    "triggersOnDraftPr": {
                        "description": "Whether the CI job should be automatically triggered on draft PRs\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "deferringEnvironmentId",
                    "deferringJobId",
                    "description",
                    "environmentId",
                    "jobCompletionTriggerConditions",
                    "jobId",
                    "name",
                    "projectId",
                    "selfDeferring",
                    "timeoutSeconds",
                    "triggers",
                    "triggersOnDraftPr",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getNotification:getNotification": {
            "description": "Retrieve notification details\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myNotification = dbtcloud.getNotification({\n    notificationId: 12345,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_notification = dbtcloud.get_notification(notification_id=12345)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myNotification = DbtCloud.GetNotification.Invoke(new()\n    {\n        NotificationId = 12345,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.LookupNotification(ctx, \u0026dbtcloud.LookupNotificationArgs{\n\t\t\tNotificationId: 12345,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetNotificationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myNotification = DbtcloudFunctions.getNotification(GetNotificationArgs.builder()\n            .notificationId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myNotification:\n    fn::invoke:\n      Function: dbtcloud:getNotification\n      Arguments:\n        notificationId: 12345\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNotification.\n",
                "properties": {
                    "notificationId": {
                        "type": "integer",
                        "description": "The ID of the notification\n"
                    }
                },
                "type": "object",
                "required": [
                    "notificationId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNotification.\n",
                "properties": {
                    "externalEmail": {
                        "description": "The external email to receive the notification\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "notificationId": {
                        "description": "The ID of the notification\n",
                        "type": "integer"
                    },
                    "notificationType": {
                        "description": "Type of notification (1 = dbt Cloud user email (default): does not require an external_email ; 2 = Slack channel: requires `slack_channel_id` and `slack_channel_name` ; 4 = external email: requires setting an `external_email`)\n",
                        "type": "integer"
                    },
                    "onCancels": {
                        "description": "List of job IDs to trigger the webhook on cancel\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "onFailures": {
                        "description": "List of job IDs to trigger the webhook on failure\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "onSuccesses": {
                        "description": "List of job IDs to trigger the webhook on success\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "slackChannelId": {
                        "description": "The ID of the Slack channel to receive the notification. It can be found at the bottom of the Slack channel settings\n",
                        "type": "string"
                    },
                    "slackChannelName": {
                        "description": "The name of the slack channel\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "State of the notification (1 = active (default), 2 = inactive)\n",
                        "type": "integer"
                    },
                    "userId": {
                        "description": "Internal dbt Cloud User ID. Must be the user_id for an existing user even if the notification is an external one\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "externalEmail",
                    "notificationId",
                    "notificationType",
                    "onCancels",
                    "onFailures",
                    "onSuccesses",
                    "slackChannelId",
                    "slackChannelName",
                    "state",
                    "userId",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getPostgresCredential:getPostgresCredential": {
            "inputs": {
                "description": "A collection of arguments for invoking getPostgresCredential.\n",
                "properties": {
                    "credentialId": {
                        "type": "integer",
                        "description": "Credential ID\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID\n"
                    }
                },
                "type": "object",
                "required": [
                    "credentialId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPostgresCredential.\n",
                "properties": {
                    "credentialId": {
                        "description": "Credential ID\n",
                        "type": "integer"
                    },
                    "defaultSchema": {
                        "description": "Default schema name\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isActive": {
                        "description": "Whether the Postgres credential is active\n",
                        "type": "boolean"
                    },
                    "numThreads": {
                        "description": "Number of threads to use\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "Project ID\n",
                        "type": "integer"
                    },
                    "username": {
                        "description": "Username for Postgres\n",
                        "type": "string"
                    }
                },
                "required": [
                    "credentialId",
                    "defaultSchema",
                    "isActive",
                    "numThreads",
                    "projectId",
                    "username",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getPrivatelinkEndpoint:getPrivatelinkEndpoint": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst testWithName = dbtcloud.getPrivatelinkEndpoint({\n    name: \"My Endpoint Name\",\n});\nconst testWithUrl = dbtcloud.getPrivatelinkEndpoint({\n    privateLinkEndpointUrl: \"abc.privatelink.def.com\",\n});\n// in case multiple endpoints have the same name or URL\nconst testWithNameAndUrl = dbtcloud.getPrivatelinkEndpoint({\n    name: \"My Endpoint Name\",\n    privateLinkEndpointUrl: \"abc.privatelink.def.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\ntest_with_name = dbtcloud.get_privatelink_endpoint(name=\"My Endpoint Name\")\ntest_with_url = dbtcloud.get_privatelink_endpoint(private_link_endpoint_url=\"abc.privatelink.def.com\")\n# in case multiple endpoints have the same name or URL\ntest_with_name_and_url = dbtcloud.get_privatelink_endpoint(name=\"My Endpoint Name\",\n    private_link_endpoint_url=\"abc.privatelink.def.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testWithName = DbtCloud.GetPrivatelinkEndpoint.Invoke(new()\n    {\n        Name = \"My Endpoint Name\",\n    });\n\n    var testWithUrl = DbtCloud.GetPrivatelinkEndpoint.Invoke(new()\n    {\n        PrivateLinkEndpointUrl = \"abc.privatelink.def.com\",\n    });\n\n    // in case multiple endpoints have the same name or URL\n    var testWithNameAndUrl = DbtCloud.GetPrivatelinkEndpoint.Invoke(new()\n    {\n        Name = \"My Endpoint Name\",\n        PrivateLinkEndpointUrl = \"abc.privatelink.def.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.GetPrivatelinkEndpoint(ctx, \u0026dbtcloud.GetPrivatelinkEndpointArgs{\n\t\t\tName: pulumi.StringRef(\"My Endpoint Name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbtcloud.GetPrivatelinkEndpoint(ctx, \u0026dbtcloud.GetPrivatelinkEndpointArgs{\n\t\t\tPrivateLinkEndpointUrl: pulumi.StringRef(\"abc.privatelink.def.com\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// in case multiple endpoints have the same name or URL\n\t\t_, err = dbtcloud.GetPrivatelinkEndpoint(ctx, \u0026dbtcloud.GetPrivatelinkEndpointArgs{\n\t\t\tName:                   pulumi.StringRef(\"My Endpoint Name\"),\n\t\t\tPrivateLinkEndpointUrl: pulumi.StringRef(\"abc.privatelink.def.com\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetPrivatelinkEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testWithName = DbtcloudFunctions.getPrivatelinkEndpoint(GetPrivatelinkEndpointArgs.builder()\n            .name(\"My Endpoint Name\")\n            .build());\n\n        final var testWithUrl = DbtcloudFunctions.getPrivatelinkEndpoint(GetPrivatelinkEndpointArgs.builder()\n            .privateLinkEndpointUrl(\"abc.privatelink.def.com\")\n            .build());\n\n        // in case multiple endpoints have the same name or URL\n        final var testWithNameAndUrl = DbtcloudFunctions.getPrivatelinkEndpoint(GetPrivatelinkEndpointArgs.builder()\n            .name(\"My Endpoint Name\")\n            .privateLinkEndpointUrl(\"abc.privatelink.def.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  testWithName:\n    fn::invoke:\n      Function: dbtcloud:getPrivatelinkEndpoint\n      Arguments:\n        name: My Endpoint Name\n  testWithUrl:\n    fn::invoke:\n      Function: dbtcloud:getPrivatelinkEndpoint\n      Arguments:\n        privateLinkEndpointUrl: abc.privatelink.def.com\n  # in case multiple endpoints have the same name or URL\n  testWithNameAndUrl:\n    fn::invoke:\n      Function: dbtcloud:getPrivatelinkEndpoint\n      Arguments:\n        name: My Endpoint Name\n        privateLinkEndpointUrl: abc.privatelink.def.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpoint.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Given descriptive name for the PrivateLink Endpoint (name and/or private*link*endpoint_url need to be provided to return data for the datasource)\n"
                    },
                    "privateLinkEndpointUrl": {
                        "type": "string",
                        "description": "The URL of the PrivateLink Endpoint (private*link*endpoint_url and/or name need to be provided to return data for the datasource)\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpoint.\n",
                "properties": {
                    "cidrRange": {
                        "description": "The CIDR range of the PrivateLink Endpoint\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The internal ID of the PrivateLink Endpoint\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Given descriptive name for the PrivateLink Endpoint (name and/or private*link*endpoint_url need to be provided to return data for the datasource)\n",
                        "type": "string"
                    },
                    "privateLinkEndpointUrl": {
                        "description": "The URL of the PrivateLink Endpoint (private*link*endpoint_url and/or name need to be provided to return data for the datasource)\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "PrivatelinkEndpoint state should be 1 = active, as 2 = deleted\n",
                        "type": "integer"
                    },
                    "type": {
                        "description": "Type of the PrivateLink Endpoint\n",
                        "type": "string"
                    }
                },
                "required": [
                    "cidrRange",
                    "id",
                    "state",
                    "type"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getProject:getProject": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\n// projects data sources can use the project_id parameter (preferred uniqueness is ensured)\nconst testProject = dbtcloud.getProject({\n    projectId: dbtCloudProjectId,\n});\n// or they can use project names\n// the provider will raise an error if more than one project is found with the same name\nconst anotherTestProject = dbtcloud.getProject({\n    name: \"My other project name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\n# projects data sources can use the project_id parameter (preferred uniqueness is ensured)\ntest_project = dbtcloud.get_project(project_id=dbt_cloud_project_id)\n# or they can use project names\n# the provider will raise an error if more than one project is found with the same name\nanother_test_project = dbtcloud.get_project(name=\"My other project name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // projects data sources can use the project_id parameter (preferred uniqueness is ensured)\n    var testProject = DbtCloud.GetProject.Invoke(new()\n    {\n        ProjectId = dbtCloudProjectId,\n    });\n\n    // or they can use project names\n    // the provider will raise an error if more than one project is found with the same name\n    var anotherTestProject = DbtCloud.GetProject.Invoke(new()\n    {\n        Name = \"My other project name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// projects data sources can use the project_id parameter (preferred uniqueness is ensured)\n\t\t_, err := dbtcloud.LookupProject(ctx, \u0026dbtcloud.LookupProjectArgs{\n\t\t\tProjectId: pulumi.IntRef(dbtCloudProjectId),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// or they can use project names\n\t\t// the provider will raise an error if more than one project is found with the same name\n\t\t_, err = dbtcloud.LookupProject(ctx, \u0026dbtcloud.LookupProjectArgs{\n\t\t\tName: pulumi.StringRef(\"My other project name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetProjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // projects data sources can use the project_id parameter (preferred uniqueness is ensured)\n        final var testProject = DbtcloudFunctions.getProject(GetProjectArgs.builder()\n            .projectId(dbtCloudProjectId)\n            .build());\n\n        // or they can use project names\n        // the provider will raise an error if more than one project is found with the same name\n        final var anotherTestProject = DbtcloudFunctions.getProject(GetProjectArgs.builder()\n            .name(\"My other project name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  # projects data sources can use the project_id parameter (preferred uniqueness is ensured)\n  testProject:\n    fn::invoke:\n      Function: dbtcloud:getProject\n      Arguments:\n        projectId: ${dbtCloudProjectId}\n  # or they can use project names\n  # // the provider will raise an error if more than one project is found with the same name\n  anotherTestProject:\n    fn::invoke:\n      Function: dbtcloud:getProject\n      Arguments:\n        name: My other project name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProject.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Given name for project\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "ID of the project to represent\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProject.\n",
                "properties": {
                    "connectionId": {
                        "description": "ID of the connection associated with the project\n",
                        "type": "integer"
                    },
                    "docsJobId": {
                        "description": "ID of Job for the documentation\n",
                        "type": "integer"
                    },
                    "freshnessJobId": {
                        "description": "ID of Job for source freshness\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Given name for project\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "ID of the project to represent\n",
                        "type": "integer"
                    },
                    "repositoryId": {
                        "description": "ID of the repository associated with the project\n",
                        "type": "integer"
                    },
                    "state": {
                        "description": "Project state should be 1 = active, as 2 = deleted\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "connectionId",
                    "docsJobId",
                    "freshnessJobId",
                    "name",
                    "repositoryId",
                    "state",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getRepository:getRepository": {
            "inputs": {
                "description": "A collection of arguments for invoking getRepository.\n",
                "properties": {
                    "fetchDeployKey": {
                        "type": "boolean",
                        "description": "Whether we should return the public deploy key\n",
                        "deprecationMessage": "This field is deprecated and will be removed in a future version of the provider. The key is always fetched when the clone strategy is `deploy_key`"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID to create the repository in\n"
                    },
                    "repositoryId": {
                        "type": "integer",
                        "description": "ID for the repository\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "repositoryId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRepository.\n",
                "properties": {
                    "deployKey": {
                        "description": "Public key generated by dbt when using `deploy_key` clone strategy\n",
                        "type": "string"
                    },
                    "fetchDeployKey": {
                        "deprecationMessage": "This field is deprecated and will be removed in a future version of the provider. The key is always fetched when the clone strategy is `deploy_key`",
                        "description": "Whether we should return the public deploy key\n",
                        "type": "boolean"
                    },
                    "gitCloneStrategy": {
                        "description": "Git clone strategy for the repository\n",
                        "type": "string"
                    },
                    "githubInstallationId": {
                        "description": "Identifier for the GitHub installation\n",
                        "type": "integer"
                    },
                    "gitlabProjectId": {
                        "description": "Identifier for the Gitlab project\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isActive": {
                        "description": "Whether the repository is active\n",
                        "type": "boolean"
                    },
                    "projectId": {
                        "description": "Project ID to create the repository in\n",
                        "type": "integer"
                    },
                    "remoteUrl": {
                        "description": "Connection name\n",
                        "type": "string"
                    },
                    "repositoryCredentialsId": {
                        "description": "Credentials ID for the repository (From the repository side not the dbt Cloud ID)\n",
                        "type": "integer"
                    },
                    "repositoryId": {
                        "description": "ID for the repository\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "deployKey",
                    "gitCloneStrategy",
                    "githubInstallationId",
                    "gitlabProjectId",
                    "isActive",
                    "projectId",
                    "remoteUrl",
                    "repositoryCredentialsId",
                    "repositoryId",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getServiceToken:getServiceToken": {
            "inputs": {
                "description": "A collection of arguments for invoking getServiceToken.\n",
                "properties": {
                    "serviceTokenId": {
                        "type": "integer",
                        "description": "ID of the service token\n"
                    }
                },
                "type": "object",
                "required": [
                    "serviceTokenId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServiceToken.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Service token name\n",
                        "type": "string"
                    },
                    "serviceTokenId": {
                        "description": "ID of the service token\n",
                        "type": "integer"
                    },
                    "serviceTokenPermissions": {
                        "description": "Permissions set for the service token\n",
                        "items": {
                            "$ref": "#/types/dbtcloud:index/getServiceTokenServiceTokenPermission:getServiceTokenServiceTokenPermission"
                        },
                        "type": "array"
                    },
                    "uid": {
                        "description": "The UID of the service token (part of the token secret)\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "serviceTokenId",
                    "serviceTokenPermissions",
                    "uid",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getSnowflakeCredential:getSnowflakeCredential": {
            "inputs": {
                "description": "A collection of arguments for invoking getSnowflakeCredential.\n",
                "properties": {
                    "credentialId": {
                        "type": "integer",
                        "description": "Credential ID\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "Project ID\n"
                    }
                },
                "type": "object",
                "required": [
                    "credentialId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSnowflakeCredential.\n",
                "properties": {
                    "authType": {
                        "description": "The type of Snowflake credential ('password' or 'keypair')\n",
                        "type": "string"
                    },
                    "credentialId": {
                        "description": "Credential ID\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isActive": {
                        "description": "Whether the Snowflake credential is active\n",
                        "type": "boolean"
                    },
                    "numThreads": {
                        "description": "Number of threads to use\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "Project ID\n",
                        "type": "integer"
                    },
                    "schema": {
                        "description": "Default schema name\n",
                        "type": "string"
                    },
                    "user": {
                        "description": "Username for Snowflake\n",
                        "type": "string"
                    }
                },
                "required": [
                    "authType",
                    "credentialId",
                    "isActive",
                    "numThreads",
                    "projectId",
                    "schema",
                    "user",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getUser:getUser": {
            "description": "Retrieve user details\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myUser = dbtcloud.getUser({\n    email: \"my_user@email.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_user = dbtcloud.get_user(email=\"my_user@email.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myUser = DbtCloud.GetUser.Invoke(new()\n    {\n        Email = \"my_user@email.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.GetUser(ctx, \u0026dbtcloud.GetUserArgs{\n\t\t\tEmail: \"my_user@email.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myUser = DbtcloudFunctions.getUser(GetUserArgs.builder()\n            .email(\"my_user@email.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myUser:\n    fn::invoke:\n      Function: dbtcloud:getUser\n      Arguments:\n        email: my_user@email.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUser.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "Email for the user\n"
                    }
                },
                "type": "object",
                "required": [
                    "email"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUser.\n",
                "properties": {
                    "email": {
                        "description": "Email for the user\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "ID of the user\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "email",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getUserGroups:getUserGroups": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as dbtcloud from \"@pulumi/dbtcloud\";\n\nconst myUserGroups = dbtcloud.getUserGroups({\n    userId: 12345,\n});\n```\n```python\nimport pulumi\nimport pulumi_dbtcloud as dbtcloud\n\nmy_user_groups = dbtcloud.get_user_groups(user_id=12345)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DbtCloud = Pulumi.DbtCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myUserGroups = DbtCloud.GetUserGroups.Invoke(new()\n    {\n        UserId = 12345,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-dbtcloud/sdk/go/dbtcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbtcloud.LookupUserGroups(ctx, \u0026dbtcloud.LookupUserGroupsArgs{\n\t\t\tUserId: 12345,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.dbtcloud.DbtcloudFunctions;\nimport com.pulumi.dbtcloud.inputs.GetUserGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myUserGroups = DbtcloudFunctions.getUserGroups(GetUserGroupsArgs.builder()\n            .userId(12345)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  myUserGroups:\n    fn::invoke:\n      Function: dbtcloud:getUserGroups\n      Arguments:\n        userId: 12345\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUserGroups.\n",
                "properties": {
                    "userId": {
                        "type": "integer",
                        "description": "ID of the user\n"
                    }
                },
                "type": "object",
                "required": [
                    "userId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUserGroups.\n",
                "properties": {
                    "groupIds": {
                        "description": "IDs of the groups assigned to the user\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "userId": {
                        "description": "ID of the user\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "groupIds",
                    "userId",
                    "id"
                ],
                "type": "object"
            }
        },
        "dbtcloud:index/getWebhook:getWebhook": {
            "inputs": {
                "description": "A collection of arguments for invoking getWebhook.\n",
                "properties": {
                    "webhookId": {
                        "type": "string",
                        "description": "Webhooks ID\n"
                    }
                },
                "type": "object",
                "required": [
                    "webhookId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWebhook.\n",
                "properties": {
                    "accountIdentifier": {
                        "description": "Webhooks Account Identifier\n",
                        "type": "string"
                    },
                    "active": {
                        "description": "Webhooks active flag\n",
                        "type": "boolean"
                    },
                    "clientUrl": {
                        "description": "Webhooks Client URL\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "Webhooks Description\n",
                        "type": "string"
                    },
                    "eventTypes": {
                        "description": "Webhooks Event Types\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "httpStatusCode": {
                        "description": "Webhooks HTTP Status Code\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "jobIds": {
                        "description": "List of job IDs to trigger the webhook\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "name": {
                        "description": "Webhooks Name\n",
                        "type": "string"
                    },
                    "webhookId": {
                        "description": "Webhooks ID\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accountIdentifier",
                    "active",
                    "clientUrl",
                    "description",
                    "eventTypes",
                    "httpStatusCode",
                    "jobIds",
                    "name",
                    "webhookId",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}